
> trafikskolax@1.0.0 build
> next build

   â–² Next.js 15.2.4
   - Environments: .env.local

   Creating an optimized production build ...


C:\projects\trafikskola\TrafikskolaX\node_modules\.pnpm\next@15.2.4_react-dom@19.0.0_react@19.0.0__react@19.0.0\node_modules\next\dist\compiled\webpack\bundle5.js:29
var I;var P;var R;var $;var L;var q;var K;var ae;var ge;var be;var xe;var ve;var Ce;var Ne;var He;var Qe;var Je;var Ve;var Ke;var Ye;var Xe;var Ze;var et;(function(I){var P=typeof global==="object"?global:typeof self==="object"?self:typeof this==="object"?this:{};if(typeof define==="function"&&define.amd){define("tslib",["exports"],(function(v){I(createExporter(P,createExporter(v)))}))}else if(true&&typeof v.exports==="object"){I(createExporter(P,createExporter(v.exports)))}else{I(createExporter(P))}function createExporter(v,I){if(v!==P){if(typeof Object.create==="function"){Object.defineProperty(v,"__esModule",{value:true})}else{v.__esModule=true}}return function(P,R){return v[P]=I?I(P,R):R}}})((function(v){var tt=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(v,I){v.__proto__=I}||function(v,I){for(var P in I)if(I.hasOwnProperty(P))v[P]=I[P]};I=function(v,I){tt(v,I);function __(){this.constructor=v}v.prototype=I===null?Object.create(I):(__.prototype=I.prototype,new __)};P=Object.assign||function(v){for(var I,P=1,R=arguments.length;P<R;P++){I=arguments[P];for(var $ in I)if(Object.prototype.hasOwnProperty.call(I,$))v[$]=I[$]}return v};R=function(v,I){var P={};for(var R in v)if(Object.prototype.hasOwnProperty.call(v,R)&&I.indexOf(R)<0)P[R]=v[R];if(v!=null&&typeof Object.getOwnPropertySymbols==="function")for(var $=0,R=Object.getOwnPropertySymbols(v);$<R.length;$++){if(I.indexOf(R[$])<0&&Object.prototype.propertyIsEnumerable.call(v,R[$]))P[R[$]]=v[R[$]]}return P};$=function(v,I,P,R){var $=arguments.length,L=$<3?I:R===null?R=Object.getOwnPropertyDescriptor(I,P):R,q;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")L=Reflect.decorate(v,I,P,R);else for(var K=v.length-1;K>=0;K--)if(q=v[K])L=($<3?q(L):$>3?q(I,P,L):q(I,P))||L;return $>3&&L&&Object.defineProperty(I,P,L),L};L=function(v,I){return function(P,R){I(P,R,v)}};q=function(v,I){if(typeof Reflect==="object"&&typeof Reflect.metadata==="function")return Reflect.metadata(v,I)};K=function(v,I,P,R){function adopt(v){return v instanceof P?v:new P((function(I){I(v)}))}return new(P||(P=Promise))((function(P,$){function fulfilled(v){try{step(R.next(v))}catch(v){$(v)}}function rejected(v){try{step(R["throw"](v))}catch(v){$(v)}}function step(v){v.done?P(v.value):adopt(v.value).then(fulfilled,rejected)}step((R=R.apply(v,I||[])).next())}))};ae=function(v,I){var P={label:0,sent:function(){if(L[0]&1)throw L[1];return L[1]},trys:[],ops:[]},R,$,L,q;return q={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(q[Symbol.iterator]=function(){return this}),q;function verb(v){return function(I){return step([v,I])}}function step(q){if(R)throw new TypeError("Generator is already executing.");while(P)try{if(R=1,$&&(L=q[0]&2?$["return"]:q[0]?$["throw"]||((L=$["return"])&&L.call($),0):$.next)&&!(L=L.call($,q[1])).done)return L;if($=0,L)q=[q[0]&2,L.value];switch(q[0]){case 0:case 1:L=q;break;case 4:P.label++;return{value:q[1],done:false};case 5:P.label++;$=q[1];q=[0];continue;case 7:q=P.ops.pop();P.trys.pop();continue;default:if(!(L=P.trys,L=L.length>0&&L[L.length-1])&&(q[0]===6||q[0]===2)){P=0;continue}if(q[0]===3&&(!L||q[1]>L[0]&&q[1]<L[3])){P.label=q[1];break}if(q[0]===6&&P.label<L[1]){P.label=L[1];L=q;break}if(L&&P.label<L[2]){P.label=L[2];P.ops.push(q);break}if(L[2])P.ops.pop();P.trys.pop();continue}q=I.call(v,P)}catch(v){q=[6,v];$=0}finally{R=L=0}if(q[0]&5)throw q[1];return{value:q[0]?q[1]:void 0,done:true}}};et=function(v,I,P,R){if(R===undefined)R=P;v[R]=I[P]};ge=function(v,I){for(var P in v)if(P!=="default"&&!I.hasOwnProperty(P))I[P]=v[P]};be=function(v){var I=typeof Symbol==="function"&&Symbol.iterator,P=I&&v[I],R=0;if(P)return P.call(v);if(v&&typeof v.length==="number")return{next:function(){if(v&&R>=v.length)v=void 0;return{value:v&&v[R++],done:!v}}};throw new TypeError(I?"Object is not iterable.":"Symbol.iterator is not defined.")};xe=function(v,I){var P=typeof Symbol==="function"&&v[Symbol.iterator];if(!P)return v;var R=P.call(v),$,L=[],q;try{while((I===void 0||I-- >0)&&!($=R.next()).done)L.push($.value)}catch(v){q={error:v}}finally{try{if($&&!$.done&&(P=R["return"]))P.call(R)}finally{if(q)throw q.error}}return L};ve=function(){for(var v=[],I=0;I<arguments.length;I++)v=v.concat(xe(arguments[I]));return v};Ce=function(){for(var v=0,I=0,P=arguments.length;I<P;I++)v+=arguments[I].length;for(var R=Array(v),$=0,I=0;I<P;I++)for(var L=arguments[I],q=0,K=L.length;q<K;q++,$++)R[$]=L[q];return R};Ne=function(v){return this instanceof Ne?(this.v=v,this):new Ne(v)};He=function(v,I,P){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var R=P.apply(v,I||[]),$,L=[];return $={},verb("next"),verb("throw"),verb("return"),$[Symbol.asyncIterator]=function(){return this},$;function verb(v){if(R[v])$[v]=function(I){return new Promise((function(P,R){L.push([v,I,P,R])>1||resume(v,I)}))}}function resume(v,I){try{step(R[v](I))}catch(v){settle(L[0][3],v)}}function step(v){v.value instanceof Ne?Promise.resolve(v.value.v).then(fulfill,reject):settle(L[0][2],v)}function fulfill(v){resume("next",v)}function reject(v){resume("throw",v)}function settle(v,I){if(v(I),L.shift(),L.length)resume(L[0][0],L[0][1])}};Qe=function(v){var I,P;return I={},verb("next"),verb("throw",(function(v){throw v})),verb("return"),I[Symbol.iterator]=function(){return this},I;function verb(R,$){I[R]=v[R]?function(I){return(P=!P)?{value:Ne(v[R](I)),done:R==="return"}:$?$(I):I}:$}};Je=function(v){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var I=v[Symbol.asyncIterator],P;return I?I.call(v):(v=typeof be==="function"?be(v):v[Symbol.iterator](),P={},verb("next"),verb("throw"),verb("return"),P[Symbol.asyncIterator]=function(){return this},P);function verb(I){P[I]=v[I]&&function(P){return new Promise((function(R,$){P=v[I](P),settle(R,$,P.done,P.value)}))}}function settle(v,I,P,R){Promise.resolve(R).then((function(I){v({value:I,done:P})}),I)}};Ve=function(v,I){if(Object.defineProperty){Object.defineProperty(v,"raw",{value:I})}else{v.raw=I}return v};Ke=function(v){if(v&&v.__esModule)return v;var I={};if(v!=null)for(var P in v)if(Object.hasOwnProperty.call(v,P))I[P]=v[P];I["default"]=v;return I};Ye=function(v){return v&&v.__esModule?v:{default:v}};Xe=function(v,I){if(!I.has(v)){throw new TypeError("attempted to get private field on non-instance")}return I.get(v)};Ze=function(v,I,P){if(!I.has(v)){throw new TypeError("attempted to set private field on non-instance")}I.set(v,P);return P};v("__extends",I);v("__assign",P);v("__rest",R);v("__decorate",$);v("__param",L);v("__metadata",q);v("__awaiter",K);v("__generator",ae);v("__exportStar",ge);v("__createBinding",et);v("__values",be);v("__read",xe);v("__spread",ve);v("__spreadArrays",Ce);v("__await",Ne);v("__asyncGenerator",He);v("__asyncDelegator",Qe);v("__asyncValues",Je);v("__makeTemplateObject",Ve);v("__importStar",Ke);v("__importDefault",Ye);v("__classPrivateFieldGet",Xe);v("__classPrivateFieldSet",Ze)}))},22733:function(v,I,P){"use strict";const R=P(89959);const{JAVASCRIPT_MODULE_TYPE_AUTO:$,JAVASCRIPT_MODULE_TYPE_DYNAMIC:L,JAVASCRIPT_MODULE_TYPE_ESM:q}=P(6041);const K=P(5205);const ae=P(94252);const ge=P(34022);const be=P(28665);const xe=P(36926);const{toConstantDependency:ve,evaluateToString:Ce}=P(59932);const Ne=P(81397);const He=P(69559);function getReplacements(v,I){return{__webpack_require__:{expr:K.require,req:[K.require],type:"function",assign:false},__webpack_public_path__:{expr:K.publicPath,req:[K.publicPath],type:"string",assign:true},__webpack_base_uri__:{expr:K.baseURI,req:[K.baseURI],type:"string",assign:true},__webpack_modules__:{expr:K.moduleFactories,req:[K.moduleFactories],type:"object",assign:false},__webpack_chunk_load__:{expr:K.ensureChunk,req:[K.ensureChunk],type:"function",assign:true},__non_webpack_require__:{expr:v?`__WEBPACK_EXTERNAL_createRequire(${I}.url)`:"require",req:null,type:undefined,assign:true},__webpack_nonce__:{expr:K.scriptNonce,req:[K.scriptNonce],type:"string",assign:true},__webpack_hash__:{expr:`${K.getFullHash}()`,req:[K.getFullHash],type:"string",assign:false},__webpack_chunkname__:{expr:K.chunkName,req:[K.chunkName],type:"string",assign:false},__webpack_get_script_filename__:{expr:K.getChunkScriptFilename,req:[K.getChunkScriptFilename],type:"function",assign:true},__webpack_runtime_id__:{expr:K.runtimeId,req:[K.runtimeId],assign:false},"require.onError":{expr:K.uncaughtErrorHandler,req:[K.uncaughtErrorHandler],type:undefined,assign:true},__system_context__:{expr:K.systemContext,req:[K.systemContext],type:"object",assign:false},__webpack_share_scopes__:{expr:K.shareScopeMap,req:[K.shareScopeMap],type:"object",assign:false},__webpack_init_sharing__:{expr:K.initializeSharing,req:[K.initializeSharing],type:"function",assign:true}}}const Qe="APIPlugin";class APIPlugin{constructor(v={}){this.options=v}apply(v){v.hooks.compilation.tap(Qe,((v,{normalModuleFactory:I})=>{const P=v.outputOptions.importMetaName;const Je=getReplacements(this.options.module,P);v.dependencyTemplates.set(ge,new ge.Template);v.hooks.runtimeRequirementInTree.for(K.chunkName).tap(Qe,(I=>{v.addRuntimeModule(I,new Ne(I.name));return true}));v.hooks.runtimeRequirementInTree.for(K.getFullHash).tap(Qe,((I,P)=>{v.addRuntimeModule(I,new He);return true}));const Ve=xe.getCompilationHooks(v);Ve.renderModuleContent.tap(Qe,((v,I,P)=>{if(I.buildInfo.needCreateRequire){const v=P.runtimeTemplate.supportNodePrefixForCoreModules();const I=[new R(`import { createRequire as __WEBPACK_EXTERNAL_createRequire } from "${v?"node:":""}module";\n`,R.STAGE_HARMONY_IMPORTS,0,"external module node-commonjs")];P.chunkInitFragments.push(...I)}return v}));const handler=v=>{for(const I of Object.keys(Je)){const P=Je[I];v.hooks.expression.for(I).tap(Qe,(R=>{const $=ve(v,P.expr,P.req);if(I==="__non_webpack_require__"&&this.options.module){v.state.module.buildInfo.needCreateRequire=true}return $(R)}));if(P.assign===false){v.hooks.assign.for(I).tap(Qe,(v=>{const P=new ae(`${I} must not be assigned`);P.loc=v.loc;throw P}))}if(P.type){v.hooks.evaluateTypeof.for(I).tap(Qe,Ce(P.type))}}v.hooks.expression.for("__webpack_layer__").tap(Qe,(I=>{const P=new ge(JSON.stringify(v.state.module.layer),I.range);P.loc=I.loc;v.state.module.addPresentationalDependency(P);return true}));v.hooks.evaluateIdentifier.for("__webpack_layer__").tap(Qe,(I=>(v.state.module.layer===null?(new be).setNull():(new be).setString(v.state.module.layer)).setRange(I.range)));v.hooks.evaluateTypeof.for("__webpack_layer__").tap(Qe,(I=>(new be).setString(v.state.module.layer===null?"object":"string").setRange(I.range)));v.hooks.expression.for("__webpack_module__.id").tap(Qe,(I=>{v.state.module.buildInfo.moduleConcatenationBailout="__webpack_module__.id";const P=new ge(`${v.state.module.moduleArgument}.id`,I.range,[K.moduleId]);P.loc=I.loc;v.state.module.addPresentationalDependency(P);return true}));v.hooks.expression.for("__webpack_module__").tap(Qe,(I=>{v.state.module.buildInfo.moduleConcatenationBailout="__webpack_module__";const P=new ge(v.state.module.moduleArgument,I.range,[K.module]);P.loc=I.loc;v.state.module.addPresentationalDependency(P);return true}));v.hooks.evaluateTypeof.for("__webpack_module__").tap(Qe,Ce("object"))};I.hooks.parser.for($).tap(Qe,handler);I.hooks.parser.for(L).tap(Qe,handler);I.hooks.parser.for(q).tap(Qe,handler)}))}}v.exports=APIPlugin},50655:function(v,I,P){"use strict";const R=P(94252);const $=/at ([a-zA-Z0-9_.]*)/;function createMessage(v){return`Abstract method${v?` ${v}`:""}. Must be overridden.`}function Message(){this.stack=undefined;Error.captureStackTrace(this);const v=this.stack.split("\n")[3].match($);this.message=v&&v[1]?createMessage(v[1]):createMessage()}class AbstractMethodError extends R{constructor(){super((new Message).message);this.name="AbstractMethodError"}}v.exports=AbstractMethodError},67927:function(v,I,P){"use strict";const R=P(98733);const $=P(65317);class AsyncDependenciesBlock extends R{constructor(v,I,P){super();if(typeof v==="string"){v={name:v}}else if(!v){v={name:undefined}}this.groupOptions=v;this.loc=I;this.request=P;this._stringifiedGroupOptions=undefined}get chunkName(){return this.groupOptions.name}set chunkName(v){if(this.groupOptions.name!==v){this.groupOptions.name=v;this._stringifiedGroupOptions=undefined}}updateHash(v,I){const{chunkGraph:P}=I;if(this._stringifiedGroupOptions===undefined){this._stringifiedGroupOptions=JSON.stringify(this.groupOptions)}const R=P.getBlockChunkGroup(this);v.update(`${this._stringifiedGroupOptions}${R?R.id:""}`);super.updateHash(v,I)}serialize(v){const{write:I}=v;I(this.groupOptions);I(this.loc);I(this.request);super.serialize(v)}deserialize(v){const{read:I}=v;this.groupOptions=I();this.loc=I();this.request=I();super.deserialize(v)}}$(AsyncDependenciesBlock,"webpack/lib/AsyncDependenciesBlock");Object.defineProperty(AsyncDependenciesBlock.prototype,"module",{get(){throw new Error("module property was removed from AsyncDependenciesBlock (it's not needed)")},set(){throw new Error("module property was removed from AsyncDependenciesBlock (it's not needed)")}});v.exports=AsyncDependenciesBlock},61993:function(v,I,P){"use strict";const R=P(94252);class AsyncDependencyToInitialChunkError extends R{constructor(v,I,P){super(`It's not allowed to load an initial chunk on demand. The chunk name "${v}" is already used by an entrypoint.`);this.name="AsyncDependencyToInitialChunkError";this.module=I;this.loc=P}}v.exports=AsyncDependencyToInitialChunkError},88920:function(v,I,P){"use strict";const R=P(78175);const $=P(32594);const L=P(27561);class AutomaticPrefetchPlugin{apply(v){v.hooks.compilation.tap("AutomaticPrefetchPlugin",((v,{normalModuleFactory:I})=>{v.dependencyFactories.set(L,I)}));let I=null;v.hooks.afterCompile.tap("AutomaticPrefetchPlugin",(v=>{I=[];for(const P of v.modules){if(P instanceof $){I.push({context:P.context,request:P.request})}}}));v.hooks.make.tapAsync("AutomaticPrefetchPlugin",((P,$)=>{if(!I)return $();R.each(I,((I,R)=>{P.addModuleChain(I.context||v.context,new L(`!!${I.request}`),R)}),(v=>{I=null;$(v)}))}))}}v.exports=AutomaticPrefetchPlugin},34748:function(v,I,P){"use strict";const{ConcatSource:R}=P(51255);const $=P(29327);const L=P(20610);const q=P(57227);const K=P(86750);const ae=K(P(46393),(()=>P(95340)),{name:"Banner Plugin",baseDataPath:"options"});const wrapComment=v=>{if(!v.includes("\n")){return q.toComment(v)}return`/*!\n * ${v.replace(/\*\//g,"* /").split("\n").join("\n * ").replace(/\s+\n/g,"\n").trimEnd()}\n */`};class BannerPlugin{constructor(v){if(typeof v==="string"||typeof v==="function"){v={banner:v}}ae(v);this.options=v;const I=v.banner;if(typeof I==="function"){const v=I;this.banner=this.options.raw?v:I=>wrapComment(v(I))}else{const v=this.options.raw?I:wrapComment(I);this.banner=()=>v}}apply(v){const I=this.options;const P=this.banner;const q=L.matchObject.bind(undefined,I);const K=new WeakMap;const ae=this.options.stage||$.PROCESS_ASSETS_STAGE_ADDITIONS;v.hooks.compilation.tap("BannerPlugin",(v=>{v.hooks.processAssets.tap({name:"BannerPlugin",stage:ae},(()=>{for(const $ of v.chunks){if(I.entryOnly&&!$.canBeInitial()){continue}for(const L of $.files){if(!q(L)){continue}const ae={chunk:$,filename:L};const ge=v.getPath(P,ae);v.updateAsset(L,(v=>{const P=K.get(v);if(!P||P.comment!==ge){const P=I.footer?new R(v,"\n",ge):new R(ge,"\n",v);K.set(v,{source:P,comment:ge});return P}return P.source}))}}}))}))}}v.exports=BannerPlugin},37292:function(v,I,P){"use strict";const{AsyncParallelHook:R,AsyncSeriesBailHook:$,SyncHook:L}=P(84891);const{makeWebpackError:q,makeWebpackErrorCallback:K}=P(73404);const needCalls=(v,I)=>P=>{if(--v===0){return I(P)}if(P&&v>0){v=0;return I(P)}};class Cache{constructor(){this.hooks={get:new $(["identifier","etag","gotHandlers"]),store:new R(["identifier","etag","data"]),storeBuildDependencies:new R(["dependencies"]),beginIdle:new L([]),endIdle:new R([]),shutdown:new R([])}}get(v,I,P){const R=[];this.hooks.get.callAsync(v,I,R,((v,I)=>{if(v){P(q(v,"Cache.hooks.get"));return}if(I===null){I=undefined}if(R.length>1){const v=needCalls(R.length,(()=>P(null,I)));for(const P of R){P(I,v)}}else if(R.length===1){R[0](I,(()=>P(null,I)))}else{P(null,I)}}))}store(v,I,P,R){this.hooks.store.callAsync(v,I,P,K(R,"Cache.hooks.store"))}storeBuildDependencies(v,I){this.hooks.storeBuildDependencies.callAsync(v,K(I,"Cache.hooks.storeBuildDependencies"))}beginIdle(){this.hooks.beginIdle.call()}endIdle(v){this.hooks.endIdle.callAsync(K(v,"Cache.hooks.endIdle"))}shutdown(v){this.hooks.shutdown.callAsync(K(v,"Cache.hooks.shutdown"))}}Cache.STAGE_MEMORY=-10;Cache.STAGE_DEFAULT=0;Cache.STAGE_DISK=10;Cache.STAGE_NETWORK=20;v.exports=Cache},44747:function(v,I,P){"use strict";const{forEachBail:R}=P(90878);const $=P(78175);const L=P(95399);const q=P(67792);class MultiItemCache{constructor(v){this._items=v;if(v.length===1)return v[0]}get(v){R(this._items,((v,I)=>v.get(I)),v)}getPromise(){const next=v=>this._items[v].getPromise().then((I=>{if(I!==undefined)return I;if(++v<this._items.length)return next(v)}));return next(0)}store(v,I){$.each(this._items,((I,P)=>I.store(v,P)),I)}storePromise(v){return Promise.all(this._items.map((I=>I.storePromise(v)))).then((()=>{}))}}class ItemCacheFacade{constructor(v,I,P){this._cache=v;this._name=I;this._etag=P}get(v){this._cache.get(this._name,this._etag,v)}getPromise(){return new Promise(((v,I)=>{this._cache.get(this._name,this._etag,((P,R)=>{if(P){I(P)}else{v(R)}}))}))}store(v,I){this._cache.store(this._name,this._etag,v,I)}storePromise(v){return new Promise(((I,P)=>{this._cache.store(this._name,this._etag,v,(v=>{if(v){P(v)}else{I()}}))}))}provide(v,I){this.get(((P,R)=>{if(P)return I(P);if(R!==undefined)return R;v(((v,P)=>{if(v)return I(v);this.store(P,(v=>{if(v)return I(v);I(null,P)}))}))}))}async providePromise(v){const I=await this.getPromise();if(I!==undefined)return I;const P=await v();await this.storePromise(P);return P}}class CacheFacade{constructor(v,I,P){this._cache=v;this._name=I;this._hashFunction=P}getChildCache(v){return new CacheFacade(this._cache,`${this._name}|${v}`,this._hashFunction)}getItemCache(v,I){return new ItemCacheFacade(this._cache,`${this._name}|${v}`,I)}getLazyHashedEtag(v){return L(v,this._hashFunction)}mergeEtags(v,I){return q(v,I)}get(v,I,P){this._cache.get(`${this._name}|${v}`,I,P)}getPromise(v,I){return new Promise(((P,R)=>{this._cache.get(`${this._name}|${v}`,I,((v,I)=>{if(v){R(v)}else{P(I)}}))}))}store(v,I,P,R){this._cache.store(`${this._name}|${v}`,I,P,R)}storePromise(v,I,P){return new Promise(((R,$)=>{this._cache.store(`${this._name}|${v}`,I,P,(v=>{if(v){$(v)}else{R()}}))}))}provide(v,I,P,R){this.get(v,I,(($,L)=>{if($)return R($);if(L!==undefined)return L;P(((P,$)=>{if(P)return R(P);this.store(v,I,$,(v=>{if(v)return R(v);R(null,$)}))}))}))}async providePromise(v,I,P){const R=await this.getPromise(v,I);if(R!==undefined)return R;const $=await P();await this.storePromise(v,I,$);return $}}v.exports=CacheFacade;v.exports.ItemCacheFacade=ItemCacheFacade;v.exports.MultiItemCache=MultiItemCache},76649:function(v,I,P){"use strict";const R=P(94252);const sortModules=v=>v.sort(((v,I)=>{const P=v.identifier();const R=I.identifier();if(P<R)return-1;if(P>R)return 1;return 0}));const createModulesListMessage=(v,I)=>v.map((v=>{let P=`* ${v.identifier()}`;const R=Array.from(I.getIncomingConnectionsByOriginModule(v).keys()).filter(Boolean);if(R.length>0){P+=`\n    Used by ${R.length} module(s), i. e.`;P+=`\n    ${R[0].identifier()}`}return P})).join("\n");class CaseSensitiveModulesWarning extends R{constructor(v,I){const P=sortModules(Array.from(v));const R=createModulesListMessage(P,I);super(`There are multiple modules with names that only differ in casing.\nThis can lead to unexpected behavior when compiling on a filesystem with other case-semantic.\nUse equal casing. Compare these module identifiers:\n${R}`);this.name="CaseSensitiveModulesWarning";this.module=P[0]}}v.exports=CaseSensitiveModulesWarning},56754:function(v,I,P){"use strict";const R=P(23630);const $=P(59818);const{intersect:L}=P(81956);const q=P(6022);const K=P(89453);const{compareModulesByIdentifier:ae,compareChunkGroupsByIndex:ge,compareModulesById:be}=P(21398);const{createArrayToSetDeprecationSet:xe}=P(10416);const{mergeRuntime:ve}=P(86620);const Ce=xe("chunk.files");let Ne=1e3;class Chunk{constructor(v,I=true){this.id=null;this.ids=null;this.debugId=Ne++;this.name=v;this.idNameHints=new q;this.preventIntegration=false;this.filenameTemplate=undefined;this.cssFilenameTemplate=undefined;this._groups=new q(undefined,ge);this.runtime=undefined;this.files=I?new Ce:new Set;this.auxiliaryFiles=new Set;this.rendered=false;this.hash=undefined;this.contentHash=Object.create(null);this.renderedHash=undefined;this.chunkReason=undefined;this.extraAsync=false}get entryModule(){const v=Array.from(R.getChunkGraphForChunk(this,"Chunk.entryModule","DEP_WEBPACK_CHUNK_ENTRY_MODULE").getChunkEntryModulesIterable(this));if(v.length===0){return undefined}else if(v.length===1){return v[0]}throw new Error("Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)")}hasEntryModule(){return R.getChunkGraphForChunk(this,"Chunk.hasEntryModule","DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE").getNumberOfEntryModules(this)>0}addModule(v){const I=R.getChunkGraphForChunk(this,"Chunk.addModule","DEP_WEBPACK_CHUNK_ADD_MODULE");if(I.isModuleInChunk(v,this))return false;I.connectChunkAndModule(this,v);return true}removeModule(v){R.getChunkGraphForChunk(this,"Chunk.removeModule","DEP_WEBPACK_CHUNK_REMOVE_MODULE").disconnectChunkAndModule(this,v)}getNumberOfModules(){return R.getChunkGraphForChunk(this,"Chunk.getNumberOfModules","DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES").getNumberOfChunkModules(this)}get modulesIterable(){const v=R.getChunkGraphForChunk(this,"Chunk.modulesIterable","DEP_WEBPACK_CHUNK_MODULES_ITERABLE");return v.getOrderedChunkModulesIterable(this,ae)}compareTo(v){const I=R.getChunkGraphForChunk(this,"Chunk.compareTo","DEP_WEBPACK_CHUNK_COMPARE_TO");return I.compareChunks(this,v)}containsModule(v){return R.getChunkGraphForChunk(this,"Chunk.containsModule","DEP_WEBPACK_CHUNK_CONTAINS_MODULE").isModuleInChunk(v,this)}getModules(){return R.getChunkGraphForChunk(this,"Chunk.getModules","DEP_WEBPACK_CHUNK_GET_MODULES").getChunkModules(this)}remove(){const v=R.getChunkGraphForChunk(this,"Chunk.remove","DEP_WEBPACK_CHUNK_REMOVE");v.disconnectChunk(this);this.disconnectFromGroups()}moveModule(v,I){const P=R.getChunkGraphForChunk(this,"Chunk.moveModule","DEP_WEBPACK_CHUNK_MOVE_MODULE");P.disconnectChunkAndModule(this,v);P.connectChunkAndModule(I,v)}integrate(v){const I=R.getChunkGraphForChunk(this,"Chunk.integrate","DEP_WEBPACK_CHUNK_INTEGRATE");if(I.canChunksBeIntegrated(this,v)){I.integrateChunks(this,v);return true}return false}canBeIntegrated(v){const I=R.getChunkGraphForChunk(this,"Chunk.canBeIntegrated","DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED");return I.canChunksBeIntegrated(this,v)}isEmpty(){const v=R.getChunkGraphForChunk(this,"Chunk.isEmpty","DEP_WEBPACK_CHUNK_IS_EMPTY");return v.getNumberOfChunkModules(this)===0}modulesSize(){const v=R.getChunkGraphForChunk(this,"Chunk.modulesSize","DEP_WEBPACK_CHUNK_MODULES_SIZE");return v.getChunkModulesSize(this)}size(v={}){const I=R.getChunkGraphForChunk(this,"Chunk.size","DEP_WEBPACK_CHUNK_SIZE");return I.getChunkSize(this,v)}integratedSize(v,I){const P=R.getChunkGraphForChunk(this,"Chunk.integratedSize","DEP_WEBPACK_CHUNK_INTEGRATED_SIZE");return P.getIntegratedChunksSize(this,v,I)}getChunkModuleMaps(v){const I=R.getChunkGraphForChunk(this,"Chunk.getChunkModuleMaps","DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS");const P=Object.create(null);const $=Object.create(null);for(const R of this.getAllAsyncChunks()){let L;for(const q of I.getOrderedChunkModulesIterable(R,be(I))){if(v(q)){if(L===undefined){L=[];P[R.id]=L}const v=I.getModuleId(q);L.push(v);$[v]=I.getRenderedModuleHash(q,undefined)}}}return{id:P,hash:$}}hasModuleInGraph(v,I){const P=R.getChunkGraphForChunk(this,"Chunk.hasModuleInGraph","DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH");return P.hasModuleInGraph(this,v,I)}getChunkMaps(v){const I=Object.create(null);const P=Object.create(null);const R=Object.create(null);for(const $ of this.getAllAsyncChunks()){const L=$.id;I[L]=v?$.hash:$.renderedHash;for(const v of Object.keys($.contentHash)){if(!P[v]){P[v]=Object.create(null)}P[v][L]=$.contentHash[v]}if($.name){R[L]=$.name}}return{hash:I,contentHash:P,name:R}}hasRuntime(){for(const v of this._groups){if(v instanceof $&&v.getRuntimeChunk()===this){return true}}return false}canBeInitial(){for(const v of this._groups){if(v.isInitial())return true}return false}isOnlyInitial(){if(this._groups.size<=0)return false;for(const v of this._groups){if(!v.isInitial())return false}return true}getEntryOptions(){for(const v of this._groups){if(v instanceof $){return v.options}}return undefined}addGroup(v){this._groups.add(v)}removeGroup(v){this._groups.delete(v)}isInGroup(v){return this._groups.has(v)}getNumberOfGroups(){return this._groups.size}get groupsIterable(){this._groups.sort();return this._groups}disconnectFromGroups(){for(const v of this._groups){v.removeChunk(this)}}split(v){for(const I of this._groups){I.insertChunk(v,this);v.addGroup(I)}for(const I of this.idNameHints){v.idNameHints.add(I)}v.runtime=ve(v.runtime,this.runtime)}updateHash(v,I){v.update(`${this.id} ${this.ids?this.ids.join():""} ${this.name||""} `);const P=new K;for(const v of I.getChunkModulesIterable(this)){P.add(I.getModuleHash(v,this.runtime))}P.updateHash(v);const R=I.getChunkEntryModulesWithChunkGroupIterable(this);for(const[P,$]of R){v.update(`entry${I.getModuleId(P)}${$.id}`)}}getAllAsyncChunks(){const v=new Set;const I=new Set;const P=L(Array.from(this.groupsIterable,(v=>new Set(v.chunks))));const R=new Set(this.groupsIterable);for(const I of R){for(const P of I.childrenIterable){if(P instanceof $){R.add(P)}else{v.add(P)}}}for(const R of v){for(const v of R.chunks){if(!P.has(v)){I.add(v)}}for(const I of R.childrenIterable){v.add(I)}}return I}getAllInitialChunks(){const v=new Set;const I=new Set(this.groupsIterable);for(const P of I){if(P.isInitial()){for(const I of P.chunks)v.add(I);for(const v of P.childrenIterable)I.add(v)}}return v}getAllReferencedChunks(){const v=new Set(this.groupsIterable);const I=new Set;for(const P of v){for(const v of P.chunks){I.add(v)}for(const I of P.childrenIterable){v.add(I)}}return I}getAllReferencedAsyncEntrypoints(){const v=new Set(this.groupsIterable);const I=new Set;for(const P of v){for(const v of P.asyncEntrypointsIterable){I.add(v)}for(const I of P.childrenIterable){v.add(I)}}return I}hasAsyncChunks(){const v=new Set;const I=L(Array.from(this.groupsIterable,(v=>new Set(v.chunks))));for(const I of this.groupsIterable){for(const P of I.childrenIterable){v.add(P)}}for(const P of v){for(const v of P.chunks){if(!I.has(v)){return true}}for(const I of P.childrenIterable){v.add(I)}}return false}getChildIdsByOrders(v,I){const P=new Map;for(const v of this.groupsIterable){if(v.chunks[v.chunks.length-1]===this){for(const I of v.childrenIterable){for(const v of Object.keys(I.options)){if(v.endsWith("Order")){const R=v.slice(0,v.length-"Order".length);let $=P.get(R);if($===undefined){$=[];P.set(R,$)}$.push({order:I.options[v],group:I})}}}}}const R=Object.create(null);for(const[$,L]of P){L.sort(((I,P)=>{const R=P.order-I.order;if(R!==0)return R;return I.group.compareTo(v,P.group)}));const P=new Set;for(const R of L){for(const $ of R.group.chunks){if(I&&!I($,v))continue;P.add($.id)}}if(P.size>0){R[$]=Array.from(P)}}return R}getChildrenOfTypeInOrder(v,I){const P=[];for(const v of this.groupsIterable){for(const R of v.childrenIterable){const $=R.options[I];if($===undefined)continue;P.push({order:$,group:v,childGroup:R})}}if(P.length===0)return;P.sort(((I,P)=>{const R=P.order-I.order;if(R!==0)return R;return I.group.compareTo(v,P.group)}));const R=[];let $;for(const{group:v,childGroup:I}of P){if($&&$.onChunks===v.chunks){for(const v of I.chunks){$.chunks.add(v)}}else{R.push($={onChunks:v.chunks,chunks:new Set(I.chunks)})}}return R}getChildIdsByOrdersMap(v,I,P){const R=Object.create(null);const addChildIdsByOrdersToMap=I=>{const $=I.getChildIdsByOrders(v,P);for(const v of Object.keys($)){let P=R[v];if(P===undefined){R[v]=P=Object.create(null)}P[I.id]=$[v]}};if(I){const v=new Set;for(const I of this.groupsIterable){for(const P of I.chunks){v.add(P)}}for(const I of v){addChildIdsByOrdersToMap(I)}}for(const v of this.getAllAsyncChunks()){addChildIdsByOrdersToMap(v)}return R}hasChildByOrder(v,I,P,R){if(P){const P=new Set;for(const v of this.groupsIterable){for(const I of v.chunks){P.add(I)}}for(const $ of P){const P=$.getChildIdsByOrders(v,R);if(P[I]!==undefined)return true}}for(const P of this.getAllAsyncChunks()){const $=P.getChildIdsByOrders(v,R);if($[I]!==undefined)return true}return false}}v.exports=Chunk},23630:function(v,I,P){"use strict";const R=P(73837);const $=P(59818);const L=P(73418);const{first:q}=P(81956);const K=P(6022);const{compareModulesById:ae,compareIterables:ge,compareModulesByIdentifier:be,concatComparators:xe,compareSelect:ve,compareIds:Ce}=P(21398);const Ne=P(12471);const He=P(72260);const{RuntimeSpecMap:Qe,RuntimeSpecSet:Je,runtimeToString:Ve,mergeRuntime:Ke,forEachRuntime:Ye}=P(86620);const Xe=new Set;const Ze=BigInt(0);const et=ge(be);class ModuleHashInfo{constructor(v,I){this.hash=v;this.renderedHash=I}}const getArray=v=>Array.from(v);const getModuleRuntimes=v=>{const I=new Je;for(const P of v){I.add(P.runtime)}return I};const modulesBySourceType=v=>I=>{const P=new Map;for(const R of I){const I=v&&v.get(R)||R.getSourceTypes();for(const v of I){let I=P.get(v);if(I===undefined){I=new K;P.set(v,I)}I.add(R)}}for(const[v,R]of P){if(R.size===I.size){P.set(v,I)}}return P};const tt=modulesBySourceType(undefined);const nt=new WeakMap;const createOrderedArrayFunction=v=>{let I=nt.get(v);if(I!==undefined)return I;I=I=>{I.sortWith(v);return Array.from(I)};nt.set(v,I);return I};const getModulesSize=v=>{let I=0;for(const P of v){for(const v of P.getSourceTypes()){I+=P.size(v)}}return I};const getModulesSizes=v=>{const I=Object.create(null);for(const P of v){for(const v of P.getSourceTypes()){I[v]=(I[v]||0)+P.size(v)}}return I};const isAvailableChunk=(v,I)=>{const P=new Set(I.groupsIterable);for(const I of P){if(v.isInGroup(I))continue;if(I.isInitial())return false;for(const v of I.parentsIterable){P.add(v)}}return true};class ChunkGraphModule{constructor(){this.chunks=new K;this.entryInChunks=undefined;this.runtimeInChunks=undefined;this.hashes=undefined;this.id=null;this.runtimeRequirements=undefined;this.graphHashes=undefined;this.graphHashesWithConnections=undefined}}class ChunkGraphChunk{constructor(){this.modules=new K;this.sourceTypesByModule=undefined;this.entryModules=new Map;this.runtimeModules=new K;this.fullHashModules=undefined;this.dependentHashModules=undefined;this.runtimeRequirements=undefined;this.runtimeRequirementsInTree=new Set;this._modulesBySourceType=tt}}class ChunkGraph{constructor(v,I="md4"){this._modules=new WeakMap;this._chunks=new WeakMap;this._blockChunkGroups=new WeakMap;this._runtimeIds=new Map;this.moduleGraph=v;this._hashFunction=I;this._getGraphRoots=this._getGraphRoots.bind(this)}_getChunkGraphModule(v){let I=this._modules.get(v);if(I===undefined){I=new ChunkGraphModule;this._modules.set(v,I)}return I}_getChunkGraphChunk(v){let I=this._chunks.get(v);if(I===undefined){I=new ChunkGraphChunk;this._chunks.set(v,I)}return I}_getGraphRoots(v){const{moduleGraph:I}=this;return Array.from(He(v,(v=>{const P=new Set;const addDependencies=v=>{for(const R of I.getOutgoingConnections(v)){if(!R.module)continue;const v=R.getActiveState(undefined);if(v===false)continue;if(v===L.TRANSITIVE_ONLY){addDependencies(R.module);continue}P.add(R.module)}};addDependencies(v);return P}))).sort(be)}connectChunkAndModule(v,I){const P=this._getChunkGraphModule(I);const R=this._getChunkGraphChunk(v);P.chunks.add(v);R.modules.add(I)}disconnectChunkAndModule(v,I){const P=this._getChunkGraphModule(I);const R=this._getChunkGraphChunk(v);R.modules.delete(I);if(R.sourceTypesByModule)R.sourceTypesByModule.delete(I);P.chunks.delete(v)}disconnectChunk(v){const I=this._getChunkGraphChunk(v);for(const P of I.modules){const I=this._getChunkGraphModule(P);I.chunks.delete(v)}I.modules.clear();v.disconnectFromGroups();ChunkGraph.clearChunkGraphForChunk(v)}attachModules(v,I){const P=this._getChunkGraphChunk(v);for(const v of I){P.modules.add(v)}}attachRuntimeModules(v,I){const P=this._getChunkGraphChunk(v);for(const v of I){P.runtimeModules.add(v)}}attachFullHashModules(v,I){const P=this._getChunkGraphChunk(v);if(P.fullHashModules===undefined)P.fullHashModules=new Set;for(const v of I){P.fullHashModules.add(v)}}attachDependentHashModules(v,I){const P=this._getChunkGraphChunk(v);if(P.dependentHashModules===undefined)P.dependentHashModules=new Set;for(const v of I){P.dependentHashModules.add(v)}}replaceModule(v,I){const P=this._getChunkGraphModule(v);const R=this._getChunkGraphModule(I);for(const $ of P.chunks){const P=this._getChunkGraphChunk($);P.modules.delete(v);P.modules.add(I);R.chunks.add($)}P.chunks.clear();if(P.entryInChunks!==undefined){if(R.entryInChunks===undefined){R.entryInChunks=new Set}for(const $ of P.entryInChunks){const P=this._getChunkGraphChunk($);const L=P.entryModules.get(v);const q=new Map;for(const[R,$]of P.entryModules){if(R===v){q.set(I,L)}else{q.set(R,$)}}P.entryModules=q;R.entryInChunks.add($)}P.entryInChunks=undefined}if(P.runtimeInChunks!==undefined){if(R.runtimeInChunks===undefined){R.runtimeInChunks=new Set}for(const $ of P.runtimeInChunks){const P=this._getChunkGraphChunk($);P.runtimeModules.delete(v);P.runtimeModules.add(I);R.runtimeInChunks.add($);if(P.fullHashModules!==undefined&&P.fullHashModules.has(v)){P.fullHashModules.delete(v);P.fullHashModules.add(I)}if(P.dependentHashModules!==undefined&&P.dependentHashModules.has(v)){P.dependentHashModules.delete(v);P.dependentHashModules.add(I)}}P.runtimeInChunks=undefined}}isModuleInChunk(v,I){const P=this._getChunkGraphChunk(I);return P.modules.has(v)}isModuleInChunkGroup(v,I){for(const P of I.chunks){if(this.isModuleInChunk(v,P))return true}return false}isEntryModule(v){const I=this._getChunkGraphModule(v);return I.entryInChunks!==undefined}getModuleChunksIterable(v){const I=this._getChunkGraphModule(v);return I.chunks}getOrderedModuleChunksIterable(v,I){const P=this._getChunkGraphModule(v);P.chunks.sortWith(I);return P.chunks}getModuleChunks(v){const I=this._getChunkGraphModule(v);return I.chunks.getFromCache(getArray)}getNumberOfModuleChunks(v){const I=this._getChunkGraphModule(v);return I.chunks.size}getModuleRuntimes(v){const I=this._getChunkGraphModule(v);return I.chunks.getFromUnorderedCache(getModuleRuntimes)}getNumberOfChunkModules(v){const I=this._getChunkGraphChunk(v);return I.modules.size}getNumberOfChunkFullHashModules(v){const I=this._getChunkGraphChunk(v);return I.fullHashModules===undefined?0:I.fullHashModules.size}getChunkModulesIterable(v){const I=this._getChunkGraphChunk(v);return I.modules}getChunkModulesIterableBySourceType(v,I){const P=this._getChunkGraphChunk(v);const R=P.modules.getFromUnorderedCache(P._modulesBySourceType).get(I);return R}setChunkModuleSourceTypes(v,I,P){const R=this._getChunkGraphChunk(v);if(R.sourceTypesByModule===undefined){R.sourceTypesByModule=new WeakMap}R.sourceTypesByModule.set(I,P);R._modulesBySourceType=modulesBySourceType(R.sourceTypesByModule)}getChunkModuleSourceTypes(v,I){const P=this._getChunkGraphChunk(v);if(P.sourceTypesByModule===undefined){return I.getSourceTypes()}return P.sourceTypesByModule.get(I)||I.getSourceTypes()}getModuleSourceTypes(v){return this._getOverwrittenModuleSourceTypes(v)||v.getSourceTypes()}_getOverwrittenModuleSourceTypes(v){let I=false;let P;for(const R of this.getModuleChunksIterable(v)){const $=this._getChunkGraphChunk(R);if($.sourceTypesByModule===undefined)return;const L=$.sourceTypesByModule.get(v);if(L===undefined)return;if(!P){P=L;continue}else if(!I){for(const v of L){if(!I){if(!P.has(v)){I=true;P=new Set(P);P.add(v)}}else{P.add(v)}}}else{for(const v of L)P.add(v)}}return P}getOrderedChunkModulesIterable(v,I){const P=this._getChunkGraphChunk(v);P.modules.sortWith(I);return P.modules}getOrderedChunkModulesIterableBySourceType(v,I,P){const R=this._getChunkGraphChunk(v);const $=R.modules.getFromUnorderedCache(R._modulesBySourceType).get(I);if($===undefined)return;$.sortWith(P);return $}getChunkModules(v){const I=this._getChunkGraphChunk(v);return I.modules.getFromUnorderedCache(getArray)}getOrderedChunkModules(v,I){const P=this._getChunkGraphChunk(v);const R=createOrderedArrayFunction(I);return P.modules.getFromUnorderedCache(R)}getChunkModuleIdMap(v,I,P=false){const R=Object.create(null);for(const $ of P?v.getAllReferencedChunks():v.getAllAsyncChunks()){let v;for(const P of this.getOrderedChunkModulesIterable($,ae(this))){if(I(P)){if(v===undefined){v=[];R[$.id]=v}const I=this.getModuleId(P);v.push(I)}}}return R}getChunkModuleRenderedHashMap(v,I,P=0,R=false){const $=Object.create(null);for(const L of R?v.getAllReferencedChunks():v.getAllAsyncChunks()){let v;for(const R of this.getOrderedChunkModulesIterable(L,ae(this))){if(I(R)){if(v===undefined){v=Object.create(null);$[L.id]=v}const I=this.getModuleId(R);const q=this.getRenderedModuleHash(R,L.runtime);v[I]=P?q.slice(0,P):q}}}return $}getChunkConditionMap(v,I){const P=Object.create(null);for(const R of v.getAllReferencedChunks()){P[R.id]=I(R,this)}return P}hasModuleInGraph(v,I,P){const R=new Set(v.groupsIterable);const $=new Set;for(const v of R){for(const R of v.chunks){if(!$.has(R)){$.add(R);if(!P||P(R,this)){for(const v of this.getChunkModulesIterable(R)){if(I(v)){return true}}}}}for(const I of v.childrenIterable){R.add(I)}}return false}compareChunks(v,I){const P=this._getChunkGraphChunk(v);const R=this._getChunkGraphChunk(I);if(P.modules.size>R.modules.size)return-1;if(P.modules.size<R.modules.size)return 1;P.modules.sortWith(be);R.modules.sortWith(be);return et(P.modules,R.modules)}getChunkModulesSize(v){const I=this._getChunkGraphChunk(v);return I.modules.getFromUnorderedCache(getModulesSize)}getChunkModulesSizes(v){const I=this._getChunkGraphChunk(v);return I.modules.getFromUnorderedCache(getModulesSizes)}getChunkRootModules(v){const I=this._getChunkGraphChunk(v);return I.modules.getFromUnorderedCache(this._getGraphRoots)}getChunkSize(v,I={}){const P=this._getChunkGraphChunk(v);const R=P.modules.getFromUnorderedCache(getModulesSize);const $=typeof I.chunkOverhead==="number"?I.chunkOverhead:1e4;const L=typeof I.entryChunkMultiplicator==="number"?I.entryChunkMultiplicator:10;return $+R*(v.canBeInitial()?L:1)}getIntegratedChunksSize(v,I,P={}){const R=this._getChunkGraphChunk(v);const $=this._getChunkGraphChunk(I);const L=new Set(R.modules);for(const v of $.modules)L.add(v);const q=getModulesSize(L);const K=typeof P.chunkOverhead==="number"?P.chunkOverhead:1e4;const ae=typeof P.entryChunkMultiplicator==="number"?P.entryChunkMultiplicator:10;return K+q*(v.canBeInitial()||I.canBeInitial()?ae:1)}canChunksBeIntegrated(v,I){if(v.preventIntegration||I.preventIntegration){return false}const P=v.hasRuntime();const R=I.hasRuntime();if(P!==R){if(P){return isAvailableChunk(v,I)}else if(R){return isAvailableChunk(I,v)}return false}if(this.getNumberOfEntryModules(v)>0||this.getNumberOfEntryModules(I)>0){return false}return true}integrateChunks(v,I){if(v.name&&I.name){if(this.getNumberOfEntryModules(v)>0===this.getNumberOfEntryModules(I)>0){if(v.name.length!==I.name.length){v.name=v.name.length<I.name.length?v.name:I.name}else{v.name=v.name<I.name?v.name:I.name}}else if(this.getNumberOfEntryModules(I)>0){v.name=I.name}}else if(I.name){v.name=I.name}for(const P of I.idNameHints){v.idNameHints.add(P)}v.runtime=Ke(v.runtime,I.runtime);for(const P of this.getChunkModules(I)){this.disconnectChunkAndModule(I,P);this.connectChunkAndModule(v,P)}for(const[P,R]of Array.from(this.getChunkEntryModulesWithChunkGroupIterable(I))){this.disconnectChunkAndEntryModule(I,P);this.connectChunkAndEntryModule(v,P,R)}for(const P of I.groupsIterable){P.replaceChunk(I,v);v.addGroup(P);I.removeGroup(P)}ChunkGraph.clearChunkGraphForChunk(I)}upgradeDependentToFullHashModules(v){const I=this._getChunkGraphChunk(v);if(I.dependentHashModules===undefined)return;if(I.fullHashModules===undefined){I.fullHashModules=I.dependentHashModules}else{for(const v of I.dependentHashModules){I.fullHashModules.add(v)}I.dependentHashModules=undefined}}isEntryModuleInChunk(v,I){const P=this._getChunkGraphChunk(I);return P.entryModules.has(v)}connectChunkAndEntryModule(v,I,P){const R=this._getChunkGraphModule(I);const $=this._getChunkGraphChunk(v);if(R.entryInChunks===undefined){R.entryInChunks=new Set}R.entryInChunks.add(v);$.entryModules.set(I,P)}connectChunkAndRuntimeModule(v,I){const P=this._getChunkGraphModule(I);const R=this._getChunkGraphChunk(v);if(P.runtimeInChunks===undefined){P.runtimeInChunks=new Set}P.runtimeInChunks.add(v);R.runtimeModules.add(I)}addFullHashModuleToChunk(v,I){const P=this._getChunkGraphChunk(v);if(P.fullHashModules===undefined)P.fullHashModules=new Set;P.fullHashModules.add(I)}addDependentHashModuleToChunk(v,I){const P=this._getChunkGraphChunk(v);if(P.dependentHashModules===undefined)P.dependentHashModules=new Set;P.dependentHashModules.add(I)}disconnectChunkAndEntryModule(v,I){const P=this._getChunkGraphModule(I);const R=this._getChunkGraphChunk(v);P.entryInChunks.delete(v);if(P.entryInChunks.size===0){P.entryInChunks=undefined}R.entryModules.delete(I)}disconnectChunkAndRuntimeModule(v,I){const P=this._getChunkGraphModule(I);const R=this._getChunkGraphChunk(v);P.runtimeInChunks.delete(v);if(P.runtimeInChunks.size===0){P.runtimeInChunks=undefined}R.runtimeModules.delete(I)}disconnectEntryModule(v){const I=this._getChunkGraphModule(v);for(const P of I.entryInChunks){const I=this._getChunkGraphChunk(P);I.entryModules.delete(v)}I.entryInChunks=undefined}disconnectEntries(v){const I=this._getChunkGraphChunk(v);for(const P of I.entryModules.keys()){const I=this._getChunkGraphModule(P);I.entryInChunks.delete(v);if(I.entryInChunks.size===0){I.entryInChunks=undefined}}I.entryModules.clear()}getNumberOfEntryModules(v){const I=this._getChunkGraphChunk(v);return I.entryModules.size}getNumberOfRuntimeModules(v){const I=this._getChunkGraphChunk(v);return I.runtimeModules.size}getChunkEntryModulesIterable(v){const I=this._getChunkGraphChunk(v);return I.entryModules.keys()}getChunkEntryDependentChunksIterable(v){const I=new Set;for(const P of v.groupsIterable){if(P instanceof $){const R=P.getEntrypointChunk();const $=this._getChunkGraphChunk(R);for(const P of $.entryModules.values()){for(const $ of P.chunks){if($!==v&&$!==R&&!$.hasRuntime()){I.add($)}}}}}return I}hasChunkEntryDependentChunks(v){const I=this._getChunkGraphChunk(v);for(const P of I.entryModules.values()){for(const I of P.chunks){if(I!==v){return true}}}return false}getChunkRuntimeModulesIterable(v){const I=this._getChunkGraphChunk(v);return I.runtimeModules}getChunkRuntimeModulesInOrder(v){const I=this._getChunkGraphChunk(v);const P=Array.from(I.runtimeModules);P.sort(xe(ve((v=>v.stage),Ce),be));return P}getChunkFullHashModulesIterable(v){const I=this._getChunkGraphChunk(v);return I.fullHashModules}getChunkFullHashModulesSet(v){const I=this._getChunkGraphChunk(v);return I.fullHashModules}getChunkDependentHashModulesIterable(v){const I=this._getChunkGraphChunk(v);return I.dependentHashModules}getChunkEntryModulesWithChunkGroupIterable(v){const I=this._getChunkGraphChunk(v);return I.entryModules}getBlockChunkGroup(v){return this._blockChunkGroups.get(v)}connectBlockAndChunkGroup(v,I){this._blockChunkGroups.set(v,I);I.addBlock(v)}disconnectChunkGroup(v){for(const I of v.blocksIterable){this._blockChunkGroups.delete(I)}v._blocks.clear()}getModuleId(v){const I=this._getChunkGraphModule(v);return I.id}setModuleId(v,I){const P=this._getChunkGraphModule(v);P.id=I}getRuntimeId(v){return this._runtimeIds.get(v)}setRuntimeId(v,I){this._runtimeIds.set(v,I)}_getModuleHashInfo(v,I,P){if(!I){throw new Error(`Module ${v.identifier()} has no hash info for runtime ${Ve(P)} (hashes not set at all)`)}else if(P===undefined){const P=new Set(I.values());if(P.size!==1){throw new Error(`No unique hash info entry for unspecified runtime for ${v.identifier()} (existing runtimes: ${Array.from(I.keys(),(v=>Ve(v))).join(", ")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: "global").`)}return q(P)}else{const R=I.get(P);if(!R){throw new Error(`Module ${v.identifier()} has no hash info for runtime ${Ve(P)} (available runtimes ${Array.from(I.keys(),Ve).join(", ")})`)}return R}}hasModuleHashes(v,I){const P=this._getChunkGraphModule(v);const R=P.hashes;return R&&R.has(I)}getModuleHash(v,I){const P=this._getChunkGraphModule(v);const R=P.hashes;return this._getModuleHashInfo(v,R,I).hash}getRenderedModuleHash(v,I){const P=this._getChunkGraphModule(v);const R=P.hashes;return this._getModuleHashInfo(v,R,I).renderedHash}setModuleHashes(v,I,P,R){const $=this._getChunkGraphModule(v);if($.hashes===undefined){$.hashes=new Qe}$.hashes.set(I,new ModuleHashInfo(P,R))}addModuleRuntimeRequirements(v,I,P,R=true){const $=this._getChunkGraphModule(v);const L=$.runtimeRequirements;if(L===undefined){const v=new Qe;v.set(I,R?P:new Set(P));$.runtimeRequirements=v;return}L.update(I,(v=>{if(v===undefined){return R?P:new Set(P)}else if(!R||v.size>=P.size){for(const I of P)v.add(I);return v}for(const I of v)P.add(I);return P}))}addChunkRuntimeRequirements(v,I){const P=this._getChunkGraphChunk(v);const R=P.runtimeRequirements;if(R===undefined){P.runtimeRequirements=I}else if(R.size>=I.size){for(const v of I)R.add(v)}else{for(const v of R)I.add(v);P.runtimeRequirements=I}}addTreeRuntimeRequirements(v,I){const P=this._getChunkGraphChunk(v);const R=P.runtimeRequirementsInTree;for(const v of I)R.add(v)}getModuleRuntimeRequirements(v,I){const P=this._getChunkGraphModule(v);const R=P.runtimeRequirements&&P.runtimeRequirements.get(I);return R===undefined?Xe:R}getChunkRuntimeRequirements(v){const I=this._getChunkGraphChunk(v);const P=I.runtimeRequirements;return P===undefined?Xe:P}getModuleGraphHash(v,I,P=true){const R=this._getChunkGraphModule(v);return P?this._getModuleGraphHashWithConnections(R,v,I):this._getModuleGraphHashBigInt(R,v,I).toString(16)}getModuleGraphHashBigInt(v,I,P=true){const R=this._getChunkGraphModule(v);return P?BigInt(`0x${this._getModuleGraphHashWithConnections(R,v,I)}`):this._getModuleGraphHashBigInt(R,v,I)}_getModuleGraphHashBigInt(v,I,P){if(v.graphHashes===undefined){v.graphHashes=new Qe}const R=v.graphHashes.provide(P,(()=>{const R=Ne(this._hashFunction);R.update(`${v.id}${this.moduleGraph.isAsync(I)}`);const $=this._getOverwrittenModuleSourceTypes(I);if($!==undefined){for(const v of $)R.update(v)}this.moduleGraph.getExportsInfo(I).updateHash(R,P);return BigInt(`0x${R.digest("hex")}`)}));return R}_getModuleGraphHashWithConnections(v,I,P){if(v.graphHashesWithConnections===undefined){v.graphHashesWithConnections=new Qe}const activeStateToString=v=>{if(v===false)return"F";if(v===true)return"T";if(v===L.TRANSITIVE_ONLY)return"O";throw new Error("Not implemented active state")};const R=I.buildMeta&&I.buildMeta.strictHarmonyModule;return v.graphHashesWithConnections.provide(P,(()=>{const $=this._getModuleGraphHashBigInt(v,I,P).toString(16);const L=this.moduleGraph.getOutgoingConnections(I);const K=new Set;const ae=new Map;const processConnection=(v,I)=>{const P=v.module;I+=P.getExportsType(this.moduleGraph,R);if(I==="Tnamespace")K.add(P);else{const v=ae.get(I);if(v===undefined){ae.set(I,P)}else if(v instanceof Set){v.add(P)}else if(v!==P){ae.set(I,new Set([v,P]))}}};if(P===undefined||typeof P==="string"){for(const v of L){const I=v.getActiveState(P);if(I===false)continue;processConnection(v,I===true?"T":"O")}}else{for(const v of L){const I=new Set;let R="";Ye(P,(P=>{const $=v.getActiveState(P);I.add($);R+=activeStateToString($)+P}),true);if(I.size===1){const v=q(I);if(v===false)continue;R=activeStateToString(v)}processConnection(v,R)}}if(K.size===0&&ae.size===0)return $;const ge=ae.size>1?Array.from(ae).sort((([v],[I])=>v<I?-1:1)):ae;const be=Ne(this._hashFunction);const addModuleToHash=v=>{be.update(this._getModuleGraphHashBigInt(this._getChunkGraphModule(v),v,P).toString(16))};const addModulesToHash=v=>{let I=Ze;for(const R of v){I=I^this._getModuleGraphHashBigInt(this._getChunkGraphModule(R),R,P)}be.update(I.toString(16))};if(K.size===1)addModuleToHash(K.values().next().value);else if(K.size>1)addModulesToHash(K);for(const[v,I]of ge){be.update(v);if(I instanceof Set){addModulesToHash(I)}else{addModuleToHash(I)}}be.update($);return be.digest("hex")}))}getTreeRuntimeRequirements(v){const I=this._getChunkGraphChunk(v);return I.runtimeRequirementsInTree}static getChunkGraphForModule(v,I,P){const $=ot.get(I);if($)return $(v);const L=R.deprecate((v=>{const P=st.get(v);if(!P)throw new Error(`${I}: There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)`);return P}),`${I}: Use new ChunkGraph API`,P);ot.set(I,L);return L(v)}static setChunkGraphForModule(v,I){st.set(v,I)}static clearChunkGraphForModule(v){st.delete(v)}static getChunkGraphForChunk(v,I,P){const $=it.get(I);if($)return $(v);const L=R.deprecate((v=>{const P=rt.get(v);if(!P)throw new Error(`${I}There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)`);return P}),`${I}: Use new ChunkGraph API`,P);it.set(I,L);return L(v)}static setChunkGraphForChunk(v,I){rt.set(v,I)}static clearChunkGraphForChunk(v){rt.delete(v)}}const st=new WeakMap;const rt=new WeakMap;const ot=new Map;const it=new Map;v.exports=ChunkGraph},12068:function(v,I,P){"use strict";const R=P(73837);const $=P(6022);const{compareLocations:L,compareChunks:q,compareIterables:K}=P(21398);let ae=5e3;const getArray=v=>Array.from(v);const sortById=(v,I)=>{if(v.id<I.id)return-1;if(I.id<v.id)return 1;return 0};const sortOrigin=(v,I)=>{const P=v.module?v.module.identifier():"";const R=I.module?I.module.identifier():"";if(P<R)return-1;if(P>R)return 1;return L(v.loc,I.loc)};class ChunkGroup{constructor(v){if(typeof v==="string"){v={name:v}}else if(!v){v={name:undefined}}this.groupDebugId=ae++;this.options=v;this._children=new $(undefined,sortById);this._parents=new $(undefined,sortById);this._asyncEntrypoints=new $(undefined,sortById);this._blocks=new $;this.chunks=[];this.origins=[];this._modulePreOrderIndices=new Map;this._modulePostOrderIndices=new Map;this.index=undefined}addOptions(v){for(const I of Object.keys(v)){const P=I;if(this.options[P]===undefined){this.options[P]=v[P]}else if(this.options[P]!==v[P]){if(P.endsWith("Order")){this.options[P]=Math.max(this.options[P],v[P])}else{throw new Error(`ChunkGroup.addOptions: No option merge strategy for ${P}`)}}}}get name(){return this.options.name}set name(v){this.options.name=v}get debugId(){return Array.from(this.chunks,(v=>v.debugId)).join("+")}get id(){return Array.from(this.chunks,(v=>v.id)).join("+")}unshiftChunk(v){const I=this.chunks.indexOf(v);if(I>0){this.chunks.splice(I,1);this.chunks.unshift(v)}else if(I<0){this.chunks.unshift(v);return true}return false}insertChunk(v,I){const P=this.chunks.indexOf(v);const R=this.chunks.indexOf(I);if(R<0){throw new Error("before chunk not found")}if(P>=0&&P>R){this.chunks.splice(P,1);this.chunks.splice(R,0,v)}else if(P<0){this.chunks.splice(R,0,v);return true}return false}pushChunk(v){const I=this.chunks.indexOf(v);if(I>=0){return false}this.chunks.push(v);return true}replaceChunk(v,I){const P=this.chunks.indexOf(v);if(P<0)return false;const R=this.chunks.indexOf(I);if(R<0){this.chunks[P]=I;return true}if(R<P){this.chunks.splice(P,1);return true}else if(R!==P){this.chunks[P]=I;this.chunks.splice(R,1);return true}}removeChunk(v){const I=this.chunks.indexOf(v);if(I>=0){this.chunks.splice(I,1);return true}return false}isInitial(){return false}addChild(v){const I=this._children.size;this._children.add(v);return I!==this._children.size}getChildren(){return this._children.getFromCache(getArray)}getNumberOfChildren(){return this._children.size}get childrenIterable(){return this._children}removeChild(v){if(!this._children.has(v)){return false}this._children.delete(v);v.removeParent(this);return true}addParent(v){if(!this._parents.has(v)){this._parents.add(v);return true}return false}getParents(){return this._parents.getFromCache(getArray)}getNumberOfParents(){return this._parents.size}hasParent(v){return this._parents.has(v)}get parentsIterable(){return this._parents}removeParent(v){if(this._parents.delete(v)){v.removeChild(this);return true}return false}addAsyncEntrypoint(v){const I=this._asyncEntrypoints.size;this._asyncEntrypoints.add(v);return I!==this._asyncEntrypoints.size}get asyncEntrypointsIterable(){return this._asyncEntrypoints}getBlocks(){return this._blocks.getFromCache(getArray)}getNumberOfBlocks(){return this._blocks.size}hasBlock(v){return this._blocks.has(v)}get blocksIterable(){return this._blocks}addBlock(v){if(!this._blocks.has(v)){this._blocks.add(v);return true}return false}addOrigin(v,I,P){this.origins.push({module:v,loc:I,request:P})}getFiles(){const v=new Set;for(const I of this.chunks){for(const P of I.files){v.add(P)}}return Array.from(v)}remove(){for(const v of this._parents){v._children.delete(this);for(const I of this._children){I.addParent(v);v.addChild(I)}}for(const v of this._children){v._parents.delete(this)}for(const v of this.chunks){v.removeGroup(this)}}sortItems(){this.origins.sort(sortOrigin)}compareTo(v,I){if(this.chunks.length>I.chunks.length)return-1;if(this.chunks.length<I.chunks.length)return 1;return K(q(v))(this.chunks,I.chunks)}getChildrenByOrders(v,I){const P=new Map;for(const v of this._children){for(const I of Object.keys(v.options)){if(I.endsWith("Order")){const R=I.slice(0,I.length-"Order".length);let $=P.get(R);if($===undefined){P.set(R,$=[])}$.push({order:v.options[I],group:v})}}}const R=Object.create(null);for(const[v,$]of P){$.sort(((v,P)=>{const R=P.order-v.order;if(R!==0)return R;return v.group.compareTo(I,P.group)}));R[v]=$.map((v=>v.group))}return R}setModulePreOrderIndex(v,I){this._modulePreOrderIndices.set(v,I)}getModulePreOrderIndex(v){return this._modulePreOrderIndices.get(v)}setModulePostOrderIndex(v,I){this._modulePostOrderIndices.set(v,I)}getModulePostOrderIndex(v){return this._modulePostOrderIndices.get(v)}checkConstraints(){const v=this;for(const I of v._children){if(!I._parents.has(v)){throw new Error(`checkConstraints: child missing parent ${v.debugId} -> ${I.debugId}`)}}for(const I of v._parents){if(!I._children.has(v)){throw new Error(`checkConstraints: parent missing child ${I.debugId} <- ${v.debugId}`)}}}}ChunkGroup.prototype.getModuleIndex=R.deprecate(ChunkGroup.prototype.getModulePreOrderIndex,"ChunkGroup.getModuleIndex was renamed to getModulePreOrderIndex","DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX");ChunkGroup.prototype.getModuleIndex2=R.deprecate(ChunkGroup.prototype.getModulePostOrderIndex,"ChunkGroup.getModuleIndex2 was renamed to getModulePostOrderIndex","DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX_2");v.exports=ChunkGroup},65398:function(v,I,P){"use strict";const R=P(94252);class ChunkRenderError extends R{constructor(v,I,P){super();this.name="ChunkRenderError";this.error=P;this.message=P.message;this.details=P.stack;this.file=I;this.chunk=v}}v.exports=ChunkRenderError},83888:function(v,I,P){"use strict";const R=P(73837);const $=P(13594);const L=$((()=>P(36926)));class ChunkTemplate{constructor(v,I){this._outputOptions=v||{};this.hooks=Object.freeze({renderManifest:{tap:R.deprecate(((v,P)=>{I.hooks.renderManifest.tap(v,((v,I)=>{if(I.chunk.hasRuntime())return v;return P(v,I)}))}),"ChunkTemplate.hooks.renderManifest is deprecated (use Compilation.hooks.renderManifest instead)","DEP_WEBPACK_CHUNK_TEMPLATE_RENDER_MANIFEST")},modules:{tap:R.deprecate(((v,P)=>{L().getCompilationHooks(I).renderChunk.tap(v,((v,R)=>P(v,I.moduleTemplates.javascript,R)))}),"ChunkTemplate.hooks.modules is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderChunk instead)","DEP_WEBPACK_CHUNK_TEMPLATE_MODULES")},render:{tap:R.deprecate(((v,P)=>{L().getCompilationHooks(I).renderChunk.tap(v,((v,R)=>P(v,I.moduleTemplates.javascript,R)))}),"ChunkTemplate.hooks.render is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderChunk instead)","DEP_WEBPACK_CHUNK_TEMPLATE_RENDER")},renderWithEntry:{tap:R.deprecate(((v,P)=>{L().getCompilationHooks(I).render.tap(v,((v,I)=>{if(I.chunkGraph.getNumberOfEntryModules(I.chunk)===0||I.chunk.hasRuntime()){return v}return P(v,I.chunk)}))}),"ChunkTemplate.hooks.renderWithEntry is deprecated (use JavascriptModulesPlugin.getCompilationHooks().render instead)","DEP_WEBPACK_CHUNK_TEMPLATE_RENDER_WITH_ENTRY")},hash:{tap:R.deprecate(((v,P)=>{I.hooks.fullHash.tap(v,P)}),"ChunkTemplate.hooks.hash is deprecated (use Compilation.hooks.fullHash instead)","DEP_WEBPACK_CHUNK_TEMPLATE_HASH")},hashForChunk:{tap:R.deprecate(((v,P)=>{L().getCompilationHooks(I).chunkHash.tap(v,((v,I,R)=>{if(v.hasRuntime())return;P(I,v,R)}))}),"ChunkTemplate.hooks.hashForChunk is deprecated (use JavascriptModulesPlugin.getCompilationHooks().chunkHash instead)","DEP_WEBPACK_CHUNK_TEMPLATE_HASH_FOR_CHUNK")}})}}Object.defineProperty(ChunkTemplate.prototype,"outputOptions",{get:R.deprecate((function(){return this._outputOptions}),"ChunkTemplate.outputOptions is deprecated (use Compilation.outputOptions instead)","DEP_WEBPACK_CHUNK_TEMPLATE_OUTPUT_OPTIONS")});v.exports=ChunkTemplate},26075:function(v,I,P){"use strict";const R=P(78175);const{SyncBailHook:$}=P(84891);const L=P(29327);const q=P(86750);const{join:K}=P(80749);const ae=P(22527);const ge=q(undefined,(()=>{const{definitions:v}=P(59992);return{definitions:v,oneOf:[{$ref:"#/definitions/CleanOptions"}]}}),{name:"Clean Plugin",baseDataPath:"options"});const be=10*1e3;const mergeAssets=(v,I)=>{for(const[P,R]of I){const I=v.get(P);if(!I||R>I)v.set(P,R)}};const getDiffToFs=(v,I,P,$)=>{const L=new Set;for(const[v]of P){L.add(v.replace(/(^|\/)[^/]*$/,""))}for(const v of L){L.add(v.replace(/(^|\/)[^/]*$/,""))}const q=new Set;R.forEachLimit(L,10,((R,$)=>{v.readdir(K(v,I,R),((v,I)=>{if(v){if(v.code==="ENOENT")return $();if(v.code==="ENOTDIR"){q.add(R);return $()}return $(v)}for(const v of I){const I=v;const $=R?`${R}/${I}`:I;if(!L.has($)&&!P.has($)){q.add($)}}$()}))}),(v=>{if(v)return $(v);$(null,q)}))};const getDiffToOldAssets=(v,I)=>{const P=new Set;const R=Date.now();for(const[$,L]of I){if(L>=R)continue;if(!v.has($))P.add($)}return P};const doStat=(v,I,P)=>{if("lstat"in v){v.lstat(I,P)}else{v.stat(I,P)}};const applyDiff=(v,I,P,R,$,L,q)=>{const log=v=>{if(P){R.info(v)}else{R.log(v)}};const ge=Array.from($.keys(),(v=>({type:"check",filename:v,parent:undefined})));const be=new Map;ae(ge,10,(({type:$,filename:q,parent:ae},ge,xe)=>{const handleError=v=>{if(v.code==="ENOENT"){log(`${q} was removed during cleaning by something else`);handleParent();return xe()}return xe(v)};const handleParent=()=>{if(ae&&--ae.remaining===0)ge(ae.job)};const ve=K(v,I,q);switch($){case"check":if(L(q)){be.set(q,0);log(`${q} will be kept`);return process.nextTick(xe)}doStat(v,ve,((I,P)=>{if(I)return handleError(I);if(!P.isDirectory()){ge({type:"unlink",filename:q,parent:ae});return xe()}v.readdir(ve,((v,I)=>{if(v)return handleError(v);const P={type:"rmdir",filename:q,parent:ae};const R=I;if(R.length===0){ge(P)}else{const v={remaining:R.length,job:P};for(const I of R){const P=I;if(P.startsWith(".")){log(`${q} will be kept (dot-files will never be removed)`);continue}ge({type:"check",filename:`${q}/${P}`,parent:v})}}return xe()}))}));break;case"rmdir":log(`${q} will be removed`);if(P){handleParent();return process.nextTick(xe)}if(!v.rmdir){R.warn(`${q} can't be removed because output file system doesn't support removing directories (rmdir)`);return process.nextTick(xe)}v.rmdir(ve,(v=>{if(v)return handleError(v);handleParent();xe()}));break;case"unlink":log(`${q} will be removed`);if(P){handleParent();return process.nextTick(xe)}if(!v.unlink){R.warn(`${q} can't be removed because output file system doesn't support removing files (rmdir)`);return process.nextTick(xe)}v.unlink(ve,(v=>{if(v)return handleError(v);handleParent();xe()}));break}}),(v=>{if(v)return q(v);q(undefined,be)}))};const xe=new WeakMap;class CleanPlugin{static getCompilationHooks(v){if(!(v instanceof L)){throw new TypeError("The 'compilation' argument must be an instance of Compilation")}let I=xe.get(v);if(I===undefined){I={keep:new $(["ignore"])};xe.set(v,I)}return I}constructor(v={}){ge(v);this.options={dry:false,...v}}apply(v){const{dry:I,keep:P}=this.options;const R=typeof P==="function"?P:typeof P==="string"?v=>v.startsWith(P):typeof P==="object"&&P.test?v=>P.test(v):()=>false;let $;v.hooks.emit.tapAsync({name:"CleanPlugin",stage:100},((P,L)=>{const q=CleanPlugin.getCompilationHooks(P);const K=P.getLogger("webpack.CleanPlugin");const ae=v.outputFileSystem;if(!ae.readdir){return L(new Error("CleanPlugin: Output filesystem doesn't support listing directories (readdir)"))}const ge=new Map;const xe=Date.now();for(const v of Object.keys(P.assets)){if(/^[A-Za-z]:\\|^\/|^\\\\/.test(v))continue;let I;let R=v.replace(/\\/g,"/");do{I=R;R=I.replace(/(^|\/)(?!\.\.)[^/]+\/\.\.\//g,"$1")}while(R!==I);if(I.startsWith("../"))continue;const $=P.assetsInfo.get(v);if($&&$.hotModuleReplacement){ge.set(I,xe+be)}else{ge.set(I,0)}}const ve=P.getPath(v.outputPath,{});const isKept=v=>{const I=q.keep.call(v);if(I!==undefined)return I;return R(v)};const diffCallback=(v,P)=>{if(v){$=undefined;L(v);return}applyDiff(ae,ve,I,K,P,isKept,((v,I)=>{if(v){$=undefined}else{if($)mergeAssets(ge,$);$=ge;if(I)mergeAssets($,I)}L(v)}))};if($){diffCallback(null,getDiffToOldAssets(ge,$))}else{getDiffToFs(ae,ve,ge,diffCallback)}}))}}v.exports=CleanPlugin},27880:function(v,I,P){"use strict";const R=P(94252);class CodeGenerationError extends R{constructor(v,I){super();this.name="CodeGenerationError";this.error=I;this.message=I.message;this.details=I.stack;this.module=v}}v.exports=CodeGenerationError},86978:function(v,I,P){"use strict";const{getOrInsert:R}=P(93901);const{first:$}=P(81956);const L=P(12471);const{runtimeToString:q,RuntimeSpecMap:K}=P(86620);class CodeGenerationResults{constructor(v="md4"){this.map=new Map;this._hashFunction=v}get(v,I){const P=this.map.get(v);if(P===undefined){throw new Error(`No code generation entry for ${v.identifier()} (existing entries: ${Array.from(this.map.keys(),(v=>v.identifier())).join(", ")})`)}if(I===undefined){if(P.size>1){const I=new Set(P.values());if(I.size!==1){throw new Error(`No unique code generation entry for unspecified runtime for ${v.identifier()} (existing runtimes: ${Array.from(P.keys(),(v=>q(v))).join(", ")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: "global").`)}return $(I)}return P.values().next().value}const R=P.get(I);if(R===undefined){throw new Error(`No code generation entry for runtime ${q(I)} for ${v.identifier()} (existing runtimes: ${Array.from(P.keys(),(v=>q(v))).join(", ")})`)}return R}has(v,I){const P=this.map.get(v);if(P===undefined){return false}if(I!==undefined){return P.has(I)}else if(P.size>1){const v=new Set(P.values());return v.size===1}return P.size===1}getSource(v,I,P){return this.get(v,I).sources.get(P)}getRuntimeRequirements(v,I){return this.get(v,I).runtimeRequirements}getData(v,I,P){const R=this.get(v,I).data;return R===undefined?undefined:R.get(P)}getHash(v,I){const P=this.get(v,I);if(P.hash!==undefined)return P.hash;const R=L(this._hashFunction);for(const[v,I]of P.sources){R.update(v);I.updateHash(R)}if(P.runtimeRequirements){for(const v of P.runtimeRequirements)R.update(v)}return P.hash=R.digest("hex")}add(v,I,P){const $=R(this.map,v,(()=>new K));$.set(I,P)}}v.exports=CodeGenerationResults},14102:function(v,I,P){"use strict";const R=P(94252);const $=P(65317);class CommentCompilationWarning extends R{constructor(v,I){super(v);this.name="CommentCompilationWarning";this.loc=I}}$(CommentCompilationWarning,"webpack/lib/CommentCompilationWarning");v.exports=CommentCompilationWarning},72812:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$,JAVASCRIPT_MODULE_TYPE_ESM:L}=P(6041);const q=P(5205);const K=P(34022);const ae=Symbol("nested webpack identifier");const ge="CompatibilityPlugin";class CompatibilityPlugin{apply(v){v.hooks.compilation.tap(ge,((v,{normalModuleFactory:I})=>{v.dependencyTemplates.set(K,new K.Template);I.hooks.parser.for(R).tap(ge,((v,I)=>{if(I.browserify!==undefined&&!I.browserify)return;v.hooks.call.for("require").tap(ge,(I=>{if(I.arguments.length!==2)return;const P=v.evaluateExpression(I.arguments[1]);if(!P.isBoolean())return;if(P.asBool()!==true)return;const R=new K("require",I.callee.range);R.loc=I.loc;if(v.state.current.dependencies.length>0){const I=v.state.current.dependencies[v.state.current.dependencies.length-1];if(I.critical&&I.options&&I.options.request==="."&&I.userRequest==="."&&I.options.recursive)v.state.current.dependencies.pop()}v.state.module.addPresentationalDependency(R);return true}))}));const handler=v=>{v.hooks.preStatement.tap(ge,(I=>{if(I.type==="FunctionDeclaration"&&I.id&&I.id.name===q.require){const P=`__nested_webpack_require_${I.range[0]}__`;v.tagVariable(I.id.name,ae,{name:P,declaration:{updated:false,loc:I.id.loc,range:I.id.range}});return true}}));v.hooks.pattern.for(q.require).tap(ge,(I=>{const P=`__nested_webpack_require_${I.range[0]}__`;v.tagVariable(I.name,ae,{name:P,declaration:{updated:false,loc:I.loc,range:I.range}});return true}));v.hooks.pattern.for(q.exports).tap(ge,(I=>{v.tagVariable(I.name,ae,{name:"__nested_webpack_exports__",declaration:{updated:false,loc:I.loc,range:I.range}});return true}));v.hooks.expression.for(ae).tap(ge,(I=>{const{name:P,declaration:R}=v.currentTagData;if(!R.updated){const I=new K(P,R.range);I.loc=R.loc;v.state.module.addPresentationalDependency(I);R.updated=true}const $=new K(P,I.range);$.loc=I.loc;v.state.module.addPresentationalDependency($);return true}));v.hooks.program.tap(ge,((I,P)=>{if(P.length===0)return;const R=P[0];if(R.type==="Line"&&R.range[0]===0){if(v.state.source.slice(0,2).toString()!=="#!")return;const I=new K("//",0);I.loc=R.loc;v.state.module.addPresentationalDependency(I)}}))};I.hooks.parser.for(R).tap(ge,handler);I.hooks.parser.for($).tap(ge,handler);I.hooks.parser.for(L).tap(ge,handler)}))}}v.exports=CompatibilityPlugin},29327:function(v,I,P){"use strict";const R=P(78175);const{HookMap:$,SyncHook:L,SyncBailHook:q,SyncWaterfallHook:K,AsyncSeriesHook:ae,AsyncSeriesBailHook:ge,AsyncParallelHook:be}=P(84891);const xe=P(73837);const{CachedSource:ve}=P(51255);const{MultiItemCache:Ce}=P(44747);const Ne=P(56754);const He=P(23630);const Qe=P(12068);const Je=P(65398);const Ve=P(83888);const Ke=P(27880);const Ye=P(86978);const Xe=P(49790);const Ze=P(51589);const et=P(59818);const tt=P(35199);const nt=P(67222);const{connectChunkGroupAndChunk:st,connectChunkGroupParentAndChild:rt}=P(84017);const{makeWebpackError:ot,tryRunOrWebpackError:it}=P(73404);const at=P(16253);const ct=P(34803);const lt=P(6171);const ut=P(96868);const pt=P(48101);const dt=P(72979);const ft=P(42383);const ht=P(7265);const mt=P(31262);const gt=P(78719);const yt=P(80764);const{WEBPACK_MODULE_TYPE_RUNTIME:bt}=P(6041);const xt=P(5205);const kt=P(92104);const vt=P(74951);const wt=P(94252);const Ct=P(44718);const Et=P(43459);const{Logger:At,LogType:St}=P(64452);const _t=P(58406);const It=P(27045);const{equals:Pt}=P(29179);const Mt=P(18663);const Ot=P(11584);const{getOrInsert:Dt}=P(93901);const Rt=P(97599);const{cachedCleverMerge:Tt}=P(22298);const{compareLocations:$t,concatComparators:Ft,compareSelect:jt,compareIds:Nt,compareStringsNumeric:Lt,compareModulesByIdentifier:Bt}=P(21398);const qt=P(12471);const{arrayToSetDeprecation:zt,soonFrozenObjectDeprecation:Ut,createFakeHook:Gt}=P(10416);const Ht=P(22527);const{getRuntimeKey:Wt}=P(86620);const{isSourceEqual:Qt}=P(48983);const Jt=Object.freeze({});const Vt="esm";const Kt=xe.deprecate((v=>P(32594).getCompilationHooks(v).loader),"Compilation.hooks.normalModuleLoader was moved to NormalModule.getCompilationHooks(compilation).loader","DEP_WEBPACK_COMPILATION_NORMAL_MODULE_LOADER_HOOK");const defineRemovedModuleTemplates=v=>{Object.defineProperties(v,{asset:{enumerable:false,configurable:false,get:()=>{throw new wt("Compilation.moduleTemplates.asset has been removed")}},webassembly:{enumerable:false,configurable:false,get:()=>{throw new wt("Compilation.moduleTemplates.webassembly has been removed")}}});v=undefined};const Yt=jt((v=>v.id),Nt);const Xt=Ft(jt((v=>v.name),Nt),jt((v=>v.fullHash),Nt));const Zt=jt((v=>`${v.message}`),Lt);const en=jt((v=>v.module&&v.module.identifier()||""),Lt);const tn=jt((v=>v.loc),$t);const nn=Ft(en,tn,Zt);const sn=new WeakMap;const rn=new WeakMap;class Compilation{constructor(v,I){this._backCompat=v._backCompat;const getNormalModuleLoader=()=>Kt(this);const P=new ae(["assets"]);let R=new Set;const popNewAssets=v=>{let I;for(const P of Object.keys(v)){if(R.has(P))continue;if(I===undefined){I=Object.create(null)}I[P]=v[P];R.add(P)}return I};P.intercept({name:"Compilation",call:()=>{R=new Set(Object.keys(this.assets))},register:v=>{const{type:I,name:P}=v;const{fn:R,additionalAssets:$,...L}=v;const q=$===true?R:$;const K=q?new WeakSet:undefined;switch(I){case"sync":if(q){this.hooks.processAdditionalAssets.tap(P,(v=>{if(K.has(this.assets))q(v)}))}return{...L,type:"async",fn:(v,I)=>{try{R(v)}catch(v){return I(v)}if(K!==undefined)K.add(this.assets);const P=popNewAssets(v);if(P!==undefined){this.hooks.processAdditionalAssets.callAsync(P,I);return}I()}};case"async":if(q){this.hooks.processAdditionalAssets.tapAsync(P,((v,I)=>{if(K.has(this.assets))return q(v,I);I()}))}return{...L,fn:(v,I)=>{R(v,(P=>{if(P)return I(P);if(K!==undefined)K.add(this.assets);const R=popNewAssets(v);if(R!==undefined){this.hooks.processAdditionalAssets.callAsync(R,I);return}I()}))}};case"promise":if(q){this.hooks.processAdditionalAssets.tapPromise(P,(v=>{if(K.has(this.assets))return q(v);return Promise.resolve()}))}return{...L,fn:v=>{const I=R(v);if(!I||!I.then)return I;return I.then((()=>{if(K!==undefined)K.add(this.assets);const I=popNewAssets(v);if(I!==undefined){return this.hooks.processAdditionalAssets.promise(I)}}))}}}}});const ve=new L(["assets"]);const createProcessAssetsHook=(v,I,R,$)=>{if(!this._backCompat&&$)return;const errorMessage=I=>`Can't automatically convert plugin using Compilation.hooks.${v} to Compilation.hooks.processAssets because ${I}.\nBREAKING CHANGE: Asset processing hooks in Compilation has been merged into a single Compilation.hooks.processAssets hook.`;const getOptions=v=>{if(typeof v==="string")v={name:v};if(v.stage){throw new Error(errorMessage("it's using the 'stage' option"))}return{...v,stage:I}};return Gt({name:v,intercept(v){throw new Error(errorMessage("it's using 'intercept'"))},tap:(v,I)=>{P.tap(getOptions(v),(()=>I(...R())))},tapAsync:(v,I)=>{P.tapAsync(getOptions(v),((v,P)=>I(...R(),P)))},tapPromise:(v,I)=>{P.tapPromise(getOptions(v),(()=>I(...R())))}},`${v} is deprecated (use Compilation.hooks.processAssets instead and use one of Compilation.PROCESS_ASSETS_STAGE_* as stage option)`,$)};this.hooks=Object.freeze({buildModule:new L(["module"]),rebuildModule:new L(["module"]),failedModule:new L(["module","error"]),succeedModule:new L(["module"]),stillValidModule:new L(["module"]),addEntry:new L(["entry","options"]),failedEntry:new L(["entry","options","error"]),succeedEntry:new L(["entry","options","module"]),dependencyReferencedExports:new K(["referencedExports","dependency","runtime"]),executeModule:new L(["options","context"]),prepareModuleExecution:new be(["options","context"]),finishModules:new ae(["modules"]),finishRebuildingModule:new ae(["module"]),unseal:new L([]),seal:new L([]),beforeChunks:new L([]),afterChunks:new L(["chunks"]),optimizeDependencies:new q(["modules"]),afterOptimizeDependencies:new L(["modules"]),optimize:new L([]),optimizeModules:new q(["modules"]),afterOptimizeModules:new L(["modules"]),optimizeChunks:new q(["chunks","chunkGroups"]),afterOptimizeChunks:new L(["chunks","chunkGroups"]),optimizeTree:new ae(["chunks","modules"]),afterOptimizeTree:new L(["chunks","modules"]),optimizeChunkModules:new ge(["chunks","modules"]),afterOptimizeChunkModules:new L(["chunks","modules"]),shouldRecord:new q([]),additionalChunkRuntimeRequirements:new L(["chunk","runtimeRequirements","context"]),runtimeRequirementInChunk:new $((()=>new q(["chunk","runtimeRequirements","context"]))),additionalModuleRuntimeRequirements:new L(["module","runtimeRequirements","context"]),runtimeRequirementInModule:new $((()=>new q(["module","runtimeRequirements","context"]))),additionalTreeRuntimeRequirements:new L(["chunk","runtimeRequirements","context"]),runtimeRequirementInTree:new $((()=>new q(["chunk","runtimeRequirements","context"]))),runtimeModule:new L(["module","chunk"]),reviveModules:new L(["modules","records"]),beforeModuleIds:new L(["modules"]),moduleIds:new L(["modules"]),optimizeModuleIds:new L(["modules"]),afterOptimizeModuleIds:new L(["modules"]),reviveChunks:new L(["chunks","records"]),beforeChunkIds:new L(["chunks"]),chunkIds:new L(["chunks"]),optimizeChunkIds:new L(["chunks"]),afterOptimizeChunkIds:new L(["chunks"]),recordModules:new L(["modules","records"]),recordChunks:new L(["chunks","records"]),optimizeCodeGeneration:new L(["modules"]),beforeModuleHash:new L([]),afterModuleHash:new L([]),beforeCodeGeneration:new L([]),afterCodeGeneration:new L([]),beforeRuntimeRequirements:new L([]),afterRuntimeRequirements:new L([]),beforeHash:new L([]),contentHash:new L(["chunk"]),afterHash:new L([]),recordHash:new L(["records"]),record:new L(["compilation","records"]),beforeModuleAssets:new L([]),shouldGenerateChunkAssets:new q([]),beforeChunkAssets:new L([]),additionalChunkAssets:createProcessAssetsHook("additionalChunkAssets",Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL,(()=>[this.chunks]),"DEP_WEBPACK_COMPILATION_ADDITIONAL_CHUNK_ASSETS"),additionalAssets:createProcessAssetsHook("additionalAssets",Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL,(()=>[])),optimizeChunkAssets:createProcessAssetsHook("optimizeChunkAssets",Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE,(()=>[this.chunks]),"DEP_WEBPACK_COMPILATION_OPTIMIZE_CHUNK_ASSETS"),afterOptimizeChunkAssets:createProcessAssetsHook("afterOptimizeChunkAssets",Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE+1,(()=>[this.chunks]),"DEP_WEBPACK_COMPILATION_AFTER_OPTIMIZE_CHUNK_ASSETS"),optimizeAssets:P,afterOptimizeAssets:ve,processAssets:P,afterProcessAssets:ve,processAdditionalAssets:new ae(["assets"]),needAdditionalSeal:new q([]),afterSeal:new ae([]),renderManifest:new K(["result","options"]),fullHash:new L(["hash"]),chunkHash:new L(["chunk","chunkHash","ChunkHashContext"]),moduleAsset:new L(["module","filename"]),chunkAsset:new L(["chunk","filename"]),assetPath:new K(["path","options","assetInfo"]),needAdditionalPass:new q([]),childCompiler:new L(["childCompiler","compilerName","compilerIndex"]),log:new q(["origin","logEntry"]),processWarnings:new K(["warnings"]),processErrors:new K(["errors"]),statsPreset:new $((()=>new L(["options","context"]))),statsNormalize:new L(["options","context"]),statsFactory:new L(["statsFactory","options"]),statsPrinter:new L(["statsPrinter","options"]),get normalModuleLoader(){return getNormalModuleLoader()}});this.name=undefined;this.startTime=undefined;this.endTime=undefined;this.compiler=v;this.resolverFactory=v.resolverFactory;this.inputFileSystem=v.inputFileSystem;this.fileSystemInfo=new nt(this.inputFileSystem,{unmanagedPaths:v.unmanagedPaths,managedPaths:v.managedPaths,immutablePaths:v.immutablePaths,logger:this.getLogger("webpack.FileSystemInfo"),hashFunction:v.options.output.hashFunction});if(v.fileTimestamps){this.fileSystemInfo.addFileTimestamps(v.fileTimestamps,true)}if(v.contextTimestamps){this.fileSystemInfo.addContextTimestamps(v.contextTimestamps,true)}this.valueCacheVersions=new Map;this.requestShortener=v.requestShortener;this.compilerPath=v.compilerPath;this.logger=this.getLogger("webpack.Compilation");const Ce=v.options;this.options=Ce;this.outputOptions=Ce&&Ce.output;this.bail=Ce&&Ce.bail||false;this.profile=Ce&&Ce.profile||false;this.params=I;this.mainTemplate=new at(this.outputOptions,this);this.chunkTemplate=new Ve(this.outputOptions,this);this.runtimeTemplate=new kt(this,this.outputOptions,this.requestShortener);this.moduleTemplates={javascript:new yt(this.runtimeTemplate,this)};defineRemovedModuleTemplates(this.moduleTemplates);this.moduleMemCaches=undefined;this.moduleMemCaches2=undefined;this.moduleGraph=new pt;this.chunkGraph=undefined;this.codeGenerationResults=undefined;this.processDependenciesQueue=new Mt({name:"processDependencies",parallelism:Ce.parallelism||100,processor:this._processModuleDependencies.bind(this)});this.addModuleQueue=new Mt({name:"addModule",parent:this.processDependenciesQueue,getKey:v=>v.identifier(),processor:this._addModule.bind(this)});this.factorizeQueue=new Mt({name:"factorize",parent:this.addModuleQueue,processor:this._factorizeModule.bind(this)});this.buildQueue=new Mt({name:"build",parent:this.factorizeQueue,processor:this._buildModule.bind(this)});this.rebuildQueue=new Mt({name:"rebuild",parallelism:Ce.parallelism||100,processor:this._rebuildModule.bind(this)});this.creatingModuleDuringBuild=new WeakMap;this.entries=new Map;this.globalEntry={dependencies:[],includeDependencies:[],options:{name:undefined}};this.entrypoints=new Map;this.asyncEntrypoints=[];this.chunks=new Set;this.chunkGroups=[];this.namedChunkGroups=new Map;this.namedChunks=new Map;this.modules=new Set;if(this._backCompat){zt(this.chunks,"Compilation.chunks");zt(this.modules,"Compilation.modules")}this._modules=new Map;this.records=null;this.additionalChunkAssets=[];this.assets={};this.assetsInfo=new Map;this._assetsRelatedIn=new Map;this.errors=[];this.warnings=[];this.children=[];this.logging=new Map;this.dependencyFactories=new Map;this.dependencyTemplates=new Ze(this.outputOptions.hashFunction);this.childrenCounters={};this.usedChunkIds=null;this.usedModuleIds=null;this.needAdditionalPass=false;this._restoredUnsafeCacheModuleEntries=new Set;this._restoredUnsafeCacheEntries=new Map;this.builtModules=new WeakSet;this.codeGeneratedModules=new WeakSet;this.buildTimeExecutedModules=new WeakSet;this.emittedAssets=new Set;this.comparedForEmitAssets=new Set;this.fileDependencies=new Ot;this.contextDependencies=new Ot;this.missingDependencies=new Ot;this.buildDependencies=new Ot;this.compilationDependencies={add:xe.deprecate((v=>this.fileDependencies.add(v)),"Compilation.compilationDependencies is deprecated (used Compilation.fileDependencies instead)","DEP_WEBPACK_COMPILATION_COMPILATION_DEPENDENCIES")};this._modulesCache=this.getCache("Compilation/modules");this._assetsCache=this.getCache("Compilation/assets");this._codeGenerationCache=this.getCache("Compilation/codeGeneration");const Ne=Ce.module.unsafeCache;this._unsafeCache=Boolean(Ne);this._unsafeCachePredicate=typeof Ne==="function"?Ne:()=>true}getStats(){return new vt(this)}createStatsOptions(v,I={}){if(typeof v==="boolean"){v={preset:v===false?"none":"normal"}}else if(typeof v==="string"){v={preset:v}}if(typeof v==="object"&&v!==null){const P={};for(const I in v){P[I]=v[I]}if(P.preset!==undefined){this.hooks.statsPreset.for(P.preset).call(P,I)}this.hooks.statsNormalize.call(P,I);return P}const P={};this.hooks.statsNormalize.call(P,I);return P}createStatsFactory(v){const I=new _t;this.hooks.statsFactory.call(I,v);return I}createStatsPrinter(v){const I=new It;this.hooks.statsPrinter.call(I,v);return I}getCache(v){return this.compiler.getCache(v)}getLogger(v){if(!v){throw new TypeError("Compilation.getLogger(name) called without a name")}let I;return new At(((P,R)=>{if(typeof v==="function"){v=v();if(!v){throw new TypeError("Compilation.getLogger(name) called with a function not returning a name")}}let $;switch(P){case St.warn:case St.error:case St.trace:$=tt.cutOffLoaderExecution(new Error("Trace").stack).split("\n").slice(3);break}const L={time:Date.now(),type:P,args:R,trace:$};if(this.hooks.log.call(v,L)===undefined){if(L.type===St.profileEnd&&typeof console.profileEnd==="function"){console.profileEnd(`[${v}] ${L.args[0]}`)}if(I===undefined){I=this.logging.get(v);if(I===undefined){I=[];this.logging.set(v,I)}}I.push(L);if(L.type===St.profile&&typeof console.profile==="function"){console.profile(`[${v}] ${L.args[0]}`)}}}),(I=>{if(typeof v==="function"){if(typeof I==="function"){return this.getLogger((()=>{if(typeof v==="function"){v=v();if(!v){throw new TypeError("Compilation.getLogger(name) called with a function not returning a name")}}if(typeof I==="function"){I=I();if(!I){throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name")}}return`${v}/${I}`}))}return this.getLogger((()=>{if(typeof v==="function"){v=v();if(!v){throw new TypeError("Compilation.getLogger(name) called with a function not returning a name")}}return`${v}/${I}`}))}if(typeof I==="function"){return this.getLogger((()=>{if(typeof I==="function"){I=I();if(!I){throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name")}}return`${v}/${I}`}))}return this.getLogger(`${v}/${I}`)}))}addModule(v,I){this.addModuleQueue.add(v,I)}_addModule(v,I){const P=v.identifier();const R=this._modules.get(P);if(R){return I(null,R)}const $=this.profile?this.moduleGraph.getProfile(v):undefined;if($!==undefined){$.markRestoringStart()}this._modulesCache.get(P,null,((R,L)=>{if(R)return I(new mt(v,R));if($!==undefined){$.markRestoringEnd();$.markIntegrationStart()}if(L){L.updateCacheModule(v);v=L}this._modules.set(P,v);this.modules.add(v);if(this._backCompat)pt.setModuleGraphForModule(v,this.moduleGraph);if($!==undefined){$.markIntegrationEnd()}I(null,v)}))}getModule(v){const I=v.identifier();return this._modules.get(I)}findModule(v){return this._modules.get(v)}buildModule(v,I){this.buildQueue.add(v,I)}_buildModule(v,I){const P=this.profile?this.moduleGraph.getProfile(v):undefined;if(P!==undefined){P.markBuildingStart()}v.needBuild({compilation:this,fileSystemInfo:this.fileSystemInfo,valueCacheVersions:this.valueCacheVersions},((R,$)=>{if(R)return I(R);if(!$){if(P!==undefined){P.markBuildingEnd()}this.hooks.stillValidModule.call(v);return I()}this.hooks.buildModule.call(v);this.builtModules.add(v);v.build(this.options,this,this.resolverFactory.get("normal",v.resolveOptions),this.inputFileSystem,(R=>{if(P!==undefined){P.markBuildingEnd()}if(R){this.hooks.failedModule.call(v,R);return I(R)}if(P!==undefined){P.markStoringStart()}this._modulesCache.store(v.identifier(),null,v,(R=>{if(P!==undefined){P.markStoringEnd()}if(R){this.hooks.failedModule.call(v,R);return I(new gt(v,R))}this.hooks.succeedModule.call(v);return I()}))}))}))}processModuleDependencies(v,I){this.processDependenciesQueue.add(v,I)}processModuleDependenciesNonRecursive(v){const processDependenciesBlock=I=>{if(I.dependencies){let P=0;for(const R of I.dependencies){this.moduleGraph.setParents(R,I,v,P++)}}if(I.blocks){for(const v of I.blocks)processDependenciesBlock(v)}};processDependenciesBlock(v)}_processModuleDependencies(v,I){const P=[];let R;let $;let L;let q;let K;let ae;let ge;let be;let xe=1;let ve=1;const onDependenciesSorted=v=>{if(v)return I(v);if(P.length===0&&ve===1){return I()}this.processDependenciesQueue.increaseParallelism();for(const v of P){ve++;this.handleModuleCreation(v,(v=>{if(v&&this.bail){if(ve<=0)return;ve=-1;v.stack=v.stack;onTransitiveTasksFinished(v);return}if(--ve===0)onTransitiveTasksFinished()}))}if(--ve===0)onTransitiveTasksFinished()};const onTransitiveTasksFinished=v=>{if(v)return I(v);this.processDependenciesQueue.decreaseParallelism();return I()};const processDependency=(I,P)=>{this.moduleGraph.setParents(I,R,v,P);if(this._unsafeCache){try{const P=sn.get(I);if(P===null)return;if(P!==undefined){if(this._restoredUnsafeCacheModuleEntries.has(P)){this._handleExistingModuleFromUnsafeCache(v,I,P);return}const R=P.identifier();const $=this._restoredUnsafeCacheEntries.get(R);if($!==undefined){sn.set(I,$);this._handleExistingModuleFromUnsafeCache(v,I,$);return}xe++;this._modulesCache.get(R,null,(($,L)=>{if($){if(xe<=0)return;xe=-1;onDependenciesSorted($);return}try{if(!this._restoredUnsafeCacheEntries.has(R)){const $=rn.get(L);if($===undefined){processDependencyForResolving(I);if(--xe===0)onDependenciesSorted();return}if(L!==P){sn.set(I,L)}L.restoreFromUnsafeCache($,this.params.normalModuleFactory,this.params);this._restoredUnsafeCacheEntries.set(R,L);this._restoredUnsafeCacheModuleEntries.add(L);if(!this.modules.has(L)){ve++;this._handleNewModuleFromUnsafeCache(v,I,L,(v=>{if(v){if(ve<=0)return;ve=-1;onTransitiveTasksFinished(v)}if(--ve===0)return onTransitiveTasksFinished()}));if(--xe===0)onDependenciesSorted();return}}if(P!==L){sn.set(I,L)}this._handleExistingModuleFromUnsafeCache(v,I,L)}catch($){if(xe<=0)return;xe=-1;onDependenciesSorted($);return}if(--xe===0)onDependenciesSorted()}));return}}catch(v){console.error(v)}}processDependencyForResolving(I)};const processDependencyForResolving=I=>{const R=I.getResourceIdentifier();if(R!==undefined&&R!==null){const xe=I.category;const ve=I.constructor;if(L===ve){if(ae===xe&&ge===R){be.push(I);return}}else{const v=this.dependencyFactories.get(ve);if(v===undefined){throw new Error(`No module factory available for dependency type: ${ve.name}`)}if(q===v){L=ve;if(ae===xe&&ge===R){be.push(I);return}}else{if(q!==undefined){if($===undefined)$=new Map;$.set(q,K);K=$.get(v);if(K===undefined){K=new Map}}else{K=new Map}L=ve;q=v}}const Ce=xe===Vt?R:`${xe}${R}`;let Ne=K.get(Ce);if(Ne===undefined){K.set(Ce,Ne=[]);P.push({factory:q,dependencies:Ne,context:I.getContext(),originModule:v})}Ne.push(I);ae=xe;ge=R;be=Ne}};try{const I=[v];do{const v=I.pop();if(v.dependencies){R=v;let I=0;for(const P of v.dependencies)processDependency(P,I++)}if(v.blocks){for(const P of v.blocks)I.push(P)}}while(I.length!==0)}catch(v){return I(v)}if(--xe===0)onDependenciesSorted()}_handleNewModuleFromUnsafeCache(v,I,P,R){const $=this.moduleGraph;$.setResolvedModule(v,I,P);$.setIssuerIfUnset(P,v!==undefined?v:null);this._modules.set(P.identifier(),P);this.modules.add(P);if(this._backCompat)pt.setModuleGraphForModule(P,this.moduleGraph);this._handleModuleBuildAndDependencies(v,P,true,false,R)}_handleExistingModuleFromUnsafeCache(v,I,P){const R=this.moduleGraph;R.setResolvedModule(v,I,P)}handleModuleCreation({factory:v,dependencies:I,originModule:P,contextInfo:R,context:$,recursive:L=true,connectOrigin:q=L,checkCycle:K=!L},ae){const ge=this.moduleGraph;const be=this.profile?new ht:undefined;this.factorizeModule({currentProfile:be,factory:v,dependencies:I,factoryResult:true,originModule:P,contextInfo:R,context:$},((v,R)=>{const applyFactoryResultDependencies=()=>{const{fileDependencies:v,contextDependencies:I,missingDependencies:P}=R;if(v){this.fileDependencies.addAll(v)}if(I){this.contextDependencies.addAll(I)}if(P){this.missingDependencies.addAll(P)}};if(v){if(R)applyFactoryResultDependencies();if(I.every((v=>v.optional))){this.warnings.push(v);return ae()}this.errors.push(v);return ae(v)}const $=R.module;if(!$){applyFactoryResultDependencies();return ae()}if(be!==undefined){ge.setProfile($,be)}this.addModule($,((v,xe)=>{if(v){applyFactoryResultDependencies();if(!v.module){v.module=xe}this.errors.push(v);return ae(v)}const ve=xe;if(this._unsafeCache&&R.cacheable!==false&&ve.restoreFromUnsafeCache&&this._unsafeCachePredicate(ve)){const v=ve;for(let R=0;R<I.length;R++){const $=I[R];ge.setResolvedModule(q?P:null,$,v);sn.set($,v)}if(!rn.has(v)){rn.set(v,v.getUnsafeCacheData())}}else{applyFactoryResultDependencies();for(let v=0;v<I.length;v++){const R=I[v];ge.setResolvedModule(q?P:null,R,ve)}}ge.setIssuerIfUnset(ve,P!==undefined?P:null);if(ve!==$&&be!==undefined){const v=ge.getProfile(ve);if(v!==undefined){be.mergeInto(v)}else{ge.setProfile(ve,be)}}this._handleModuleBuildAndDependencies(P,ve,L,K,ae)}))}))}_handleModuleBuildAndDependencies(v,I,P,R,$){let L;if(R&&this.buildQueue.isProcessing(v)){L=this.creatingModuleDuringBuild.get(v);if(L===undefined){L=new Set;this.creatingModuleDuringBuild.set(v,L)}L.add(I);const P=this.creatingModuleDuringBuild.get(I);if(P!==undefined){const v=new Set(P);for(const P of v){const R=this.creatingModuleDuringBuild.get(P);if(R!==undefined){for(const P of R){if(P===I){return $(new Et(I))}v.add(P)}}}}}this.buildModule(I,(v=>{if(L!==undefined){L.delete(I)}if(v){if(!v.module){v.module=I}this.errors.push(v);return $(v)}if(!P){this.processModuleDependenciesNonRecursive(I);$(null,I);return}if(this.processDependenciesQueue.isProcessing(I)){return $(null,I)}this.processModuleDependencies(I,(v=>{if(v){return $(v)}$(null,I)}))}))}_factorizeModule({currentProfile:v,factory:I,dependencies:P,originModule:R,factoryResult:$,contextInfo:L,context:q},K){if(v!==undefined){v.markFactoryStart()}I.create({contextInfo:{issuer:R?R.nameForCondition():"",issuerLayer:R?R.layer:null,compiler:this.compiler.name,...L},resolveOptions:R?R.resolveOptions:undefined,context:q||(R?R.context:this.compiler.context),dependencies:P},((I,L)=>{if(L){if(L.module===undefined&&L instanceof ct){L={module:L}}if(!$){const{fileDependencies:v,contextDependencies:I,missingDependencies:P}=L;if(v){this.fileDependencies.addAll(v)}if(I){this.contextDependencies.addAll(I)}if(P){this.missingDependencies.addAll(P)}}}if(I){const v=new ft(R,I,P.map((v=>v.loc)).find(Boolean));return K(v,$?L:undefined)}if(!L){return K()}if(v!==undefined){v.markFactoryEnd()}K(null,$?L:L.module)}))}addModuleChain(v,I,P){return this.addModuleTree({context:v,dependency:I},P)}addModuleTree({context:v,dependency:I,contextInfo:P},R){if(typeof I!=="object"||I===null||!I.constructor){return R(new wt("Parameter 'dependency' must be a Dependency"))}const $=I.constructor;const L=this.dependencyFactories.get($);if(!L){return R(new wt(`No dependency factory available for this dependency type: ${I.constructor.name}`))}this.handleModuleCreation({factory:L,dependencies:[I],originModule:null,contextInfo:P,context:v},((v,I)=>{if(v&&this.bail){R(v);this.buildQueue.stop();this.rebuildQueue.stop();this.processDependenciesQueue.stop();this.factorizeQueue.stop()}else if(!v&&I){R(null,I)}else{R()}}))}addEntry(v,I,P,R){const $=typeof P==="object"?P:{name:P};this._addEntryItem(v,I,"dependencies",$,R)}addInclude(v,I,P,R){this._addEntryItem(v,I,"includeDependencies",P,R)}_addEntryItem(v,I,P,R,$){const{name:L}=R;let q=L!==undefined?this.entries.get(L):this.globalEntry;if(q===undefined){q={dependencies:[],includeDependencies:[],options:{name:undefined,...R}};q[P].push(I);this.entries.set(L,q)}else{q[P].push(I);for(const v of Object.keys(R)){if(R[v]===undefined)continue;if(q.options[v]===R[v])continue;if(Array.isArray(q.options[v])&&Array.isArray(R[v])&&Pt(q.options[v],R[v])){continue}if(q.options[v]===undefined){q.options[v]=R[v]}else{return $(new wt(`Conflicting entry option ${v} = ${q.options[v]} vs ${R[v]}`))}}}this.hooks.addEntry.call(I,R);this.addModuleTree({context:v,dependency:I,contextInfo:q.options.layer?{issuerLayer:q.options.layer}:undefined},((v,P)=>{if(v){this.hooks.failedEntry.call(I,R,v);return $(v)}this.hooks.succeedEntry.call(I,R,P);return $(null,P)}))}rebuildModule(v,I){this.rebuildQueue.add(v,I)}_rebuildModule(v,I){this.hooks.rebuildModule.call(v);const P=v.dependencies.slice();const R=v.blocks.slice();v.invalidateBuild();this.buildQueue.invalidate(v);this.buildModule(v,($=>{if($){return this.hooks.finishRebuildingModule.callAsync(v,(v=>{if(v){I(ot(v,"Compilation.hooks.finishRebuildingModule"));return}I($)}))}this.processDependenciesQueue.invalidate(v);this.moduleGraph.unfreeze();this.processModuleDependencies(v,($=>{if($)return I($);this.removeReasonsOfDependencyBlock(v,{dependencies:P,blocks:R});this.hooks.finishRebuildingModule.callAsync(v,(P=>{if(P){I(ot(P,"Compilation.hooks.finishRebuildingModule"));return}I(null,v)}))}))}))}_computeAffectedModules(v){const I=this.compiler.moduleMemCaches;if(!I)return;if(!this.moduleMemCaches){this.moduleMemCaches=new Map;this.moduleGraph.setModuleMemCaches(this.moduleMemCaches)}const{moduleGraph:P,moduleMemCaches:R}=this;const $=new Set;const L=new Set;let q=0;let K=0;let ae=0;let ge=0;let be=0;const computeReferences=v=>{let I;for(const R of P.getOutgoingConnections(v)){const v=R.dependency;const P=R.module;if(!v||!P||sn.has(v))continue;if(I===undefined)I=new WeakMap;I.set(v,P)}return I};const compareReferences=(v,I)=>{if(I===undefined)return true;for(const R of P.getOutgoingConnections(v)){const v=R.dependency;if(!v)continue;const P=I.get(v);if(P===undefined)continue;if(P!==R.module)return false}return true};const xe=new Set(v);for(const[v,P]of I){if(xe.has(v)){const q=v.buildInfo;if(q){if(P.buildInfo!==q){const I=new Rt;R.set(v,I);$.add(v);P.buildInfo=q;P.references=computeReferences(v);P.memCache=I;K++}else if(!compareReferences(v,P.references)){const I=new Rt;R.set(v,I);$.add(v);P.references=computeReferences(v);P.memCache=I;ge++}else{R.set(v,P.memCache);ae++}}else{L.add(v);I.delete(v);be++}xe.delete(v)}else{I.delete(v)}}for(const v of xe){const P=v.buildInfo;if(P){const L=new Rt;I.set(v,{buildInfo:P,references:computeReferences(v),memCache:L});R.set(v,L);$.add(v);q++}else{L.add(v);be++}}const reduceAffectType=v=>{let I=false;for(const{dependency:P}of v){if(!P)continue;const v=P.couldAffectReferencingModule();if(v===Xe.TRANSITIVE)return Xe.TRANSITIVE;if(v===false)continue;I=true}return I};const ve=new Set;for(const v of L){for(const[I,R]of P.getIncomingConnectionsByOriginModule(v)){if(!I)continue;if(L.has(I))continue;const v=reduceAffectType(R);if(!v)continue;if(v===true){ve.add(I)}else{L.add(I)}}}for(const v of ve)L.add(v);const Ce=new Set;for(const v of $){for(const[q,K]of P.getIncomingConnectionsByOriginModule(v)){if(!q)continue;if(L.has(q))continue;if($.has(q))continue;const v=reduceAffectType(K);if(!v)continue;if(v===true){Ce.add(q)}else{$.add(q)}const P=new Rt;const ae=I.get(q);ae.memCache=P;R.set(q,P)}}for(const v of Ce)$.add(v);this.logger.log(`${Math.round(100*($.size+L.size)/this.modules.size)}% (${$.size} affected + ${L.size} infected of ${this.modules.size}) modules flagged as affected (${q} new modules, ${K} changed, ${ge} references changed, ${ae} unchanged, ${be} were not built)`)}_computeAffectedModulesWithChunkGraph(){const{moduleMemCaches:v}=this;if(!v)return;const I=this.moduleMemCaches2=new Map;const{moduleGraph:P,chunkGraph:R}=this;const $="memCache2";let L=0;let q=0;let K=0;const computeReferences=v=>{const I=R.getModuleId(v);let $;let L;const q=P.getOutgoingConnectionsByModule(v);if(q!==undefined){for(const v of q.keys()){if(!v)continue;if($===undefined)$=new Map;$.set(v,R.getModuleId(v))}}if(v.blocks.length>0){L=[];const I=Array.from(v.blocks);for(const v of I){const P=R.getBlockChunkGroup(v);if(P){for(const v of P.chunks){L.push(v.id)}}else{L.push(null)}I.push.apply(I,v.blocks)}}return{id:I,modules:$,blocks:L}};const compareReferences=(v,{id:I,modules:P,blocks:$})=>{if(I!==R.getModuleId(v))return false;if(P!==undefined){for(const[v,I]of P){if(R.getModuleId(v)!==I)return false}}if($!==undefined){const I=Array.from(v.blocks);let P=0;for(const v of I){const L=R.getBlockChunkGroup(v);if(L){for(const v of L.chunks){if(P>=$.length||$[P++]!==v.id)return false}}else if(P>=$.length||$[P++]!==null){return false}I.push.apply(I,v.blocks)}if(P!==$.length)return false}return true};for(const[P,R]of v){const v=R.get($);if(v===undefined){const v=new Rt;R.set($,{references:computeReferences(P),memCache:v});I.set(P,v);K++}else if(!compareReferences(P,v.references)){const R=new Rt;v.references=computeReferences(P);v.memCache=R;I.set(P,R);q++}else{I.set(P,v.memCache);L++}}this.logger.log(`${Math.round(100*q/(K+q+L))}% modules flagged as affected by chunk graph (${K} new modules, ${q} changed, ${L} unchanged)`)}finish(v){this.factorizeQueue.clear();if(this.profile){this.logger.time("finish module profiles");const v=P(51887);const I=new v;const R=this.moduleGraph;const $=new Map;for(const v of this.modules){const P=R.getProfile(v);if(!P)continue;$.set(v,P);I.range(P.buildingStartTime,P.buildingEndTime,(v=>P.buildingParallelismFactor=v));I.range(P.factoryStartTime,P.factoryEndTime,(v=>P.factoryParallelismFactor=v));I.range(P.integrationStartTime,P.integrationEndTime,(v=>P.integrationParallelismFactor=v));I.range(P.storingStartTime,P.storingEndTime,(v=>P.storingParallelismFactor=v));I.range(P.restoringStartTime,P.restoringEndTime,(v=>P.restoringParallelismFactor=v));if(P.additionalFactoryTimes){for(const{start:v,end:R}of P.additionalFactoryTimes){const $=(R-v)/P.additionalFactories;I.range(v,R,(v=>P.additionalFactoriesParallelismFactor+=v*$))}}}I.calculate();const L=this.getLogger("webpack.Compilation.ModuleProfile");const logByValue=(v,I)=>{if(v>1e3){L.error(I)}else if(v>500){L.warn(I)}else if(v>200){L.info(I)}else if(v>30){L.log(I)}else{L.debug(I)}};const logNormalSummary=(v,I,P)=>{let R=0;let L=0;for(const[q,K]of $){const $=P(K);const ae=I(K);if(ae===0||$===0)continue;const ge=ae/$;R+=ge;if(ge<=10)continue;logByValue(ge,` | ${Math.round(ge)} ms${$>=1.1?` (parallelism ${Math.round($*10)/10})`:""} ${v} > ${q.readableIdentifier(this.requestShortener)}`);L=Math.max(L,ge)}if(R<=10)return;logByValue(Math.max(R/10,L),`${Math.round(R)} ms ${v}`)};const logByLoadersSummary=(v,I,P)=>{const R=new Map;for(const[v,I]of $){const P=Dt(R,`${v.type}!${v.identifier().replace(/(!|^)[^!]*$/,"")}`,(()=>[]));P.push({module:v,profile:I})}let L=0;let q=0;for(const[$,K]of R){let R=0;let ae=0;for(const{module:$,profile:L}of K){const q=P(L);const K=I(L);if(K===0||q===0)continue;const ge=K/q;R+=ge;if(ge<=10)continue;logByValue(ge,` |  | ${Math.round(ge)} ms${q>=1.1?` (parallelism ${Math.round(q*10)/10})`:""} ${v} > ${$.readableIdentifier(this.requestShortener)}`);ae=Math.max(ae,ge)}L+=R;if(R<=10)continue;const ge=$.indexOf("!");const be=$.slice(ge+1);const xe=$.slice(0,ge);const ve=Math.max(R/10,ae);logByValue(ve,` | ${Math.round(R)} ms ${v} > ${be?`${K.length} x ${xe} with ${this.requestShortener.shorten(be)}`:`${K.length} x ${xe}`}`);q=Math.max(q,ve)}if(L<=10)return;logByValue(Math.max(L/10,q),`${Math.round(L)} ms ${v}`)};logNormalSummary("resolve to new modules",(v=>v.factory),(v=>v.factoryParallelismFactor));logNormalSummary("resolve to existing modules",(v=>v.additionalFactories),(v=>v.additionalFactoriesParallelismFactor));logNormalSummary("integrate modules",(v=>v.restoring),(v=>v.restoringParallelismFactor));logByLoadersSummary("build modules",(v=>v.building),(v=>v.buildingParallelismFactor));logNormalSummary("store modules",(v=>v.storing),(v=>v.storingParallelismFactor));logNormalSummary("restore modules",(v=>v.restoring),(v=>v.restoringParallelismFactor));this.logger.timeEnd("finish module profiles")}this.logger.time("compute affected modules");this._computeAffectedModules(this.modules);this.logger.timeEnd("compute affected modules");this.logger.time("finish modules");const{modules:I,moduleMemCaches:R}=this;this.hooks.finishModules.callAsync(I,(P=>{this.logger.timeEnd("finish modules");if(P)return v(P);this.moduleGraph.freeze("dependency errors");this.logger.time("report dependency errors and warnings");for(const v of I){const I=R&&R.get(v);if(I&&I.get("noWarningsOrErrors"))continue;let P=this.reportDependencyErrorsAndWarnings(v,[v]);const $=v.getErrors();if($!==undefined){for(const I of $){if(!I.module){I.module=v}this.errors.push(I);P=true}}const L=v.getWarnings();if(L!==undefined){for(const I of L){if(!I.module){I.module=v}this.warnings.push(I);P=true}}if(!P&&I)I.set("noWarningsOrErrors",true)}this.moduleGraph.unfreeze();this.logger.timeEnd("report dependency errors and warnings");v()}))}unseal(){this.hooks.unseal.call();this.chunks.clear();this.chunkGroups.length=0;this.namedChunks.clear();this.namedChunkGroups.clear();this.entrypoints.clear();this.additionalChunkAssets.length=0;this.assets={};this.assetsInfo.clear();this.moduleGraph.removeAllModuleAttributes();this.moduleGraph.unfreeze();this.moduleMemCaches2=undefined}seal(v){const finalCallback=I=>{this.factorizeQueue.clear();this.buildQueue.clear();this.rebuildQueue.clear();this.processDependenciesQueue.clear();this.addModuleQueue.clear();return v(I)};const I=new He(this.moduleGraph,this.outputOptions.hashFunction);this.chunkGraph=I;if(this._backCompat){for(const v of this.modules){He.setChunkGraphForModule(v,I)}}this.hooks.seal.call();this.logger.time("optimize dependencies");while(this.hooks.optimizeDependencies.call(this.modules)){}this.hooks.afterOptimizeDependencies.call(this.modules);this.logger.timeEnd("optimize dependencies");this.logger.time("create chunks");this.hooks.beforeChunks.call();this.moduleGraph.freeze("seal");const P=new Map;for(const[v,{dependencies:R,includeDependencies:$,options:L}]of this.entries){const q=this.addChunk(v);if(L.filename){q.filenameTemplate=L.filename}const K=new et(L);if(!L.dependOn&&!L.runtime){K.setRuntimeChunk(q)}K.setEntrypointChunk(q);this.namedChunkGroups.set(v,K);this.entrypoints.set(v,K);this.chunkGroups.push(K);st(K,q);const ae=new Set;for(const $ of[...this.globalEntry.dependencies,...R]){K.addOrigin(null,{name:v},$.request);const R=this.moduleGraph.getModule($);if(R){I.connectChunkAndEntryModule(q,R,K);ae.add(R);const v=P.get(K);if(v===undefined){P.set(K,[R])}else{v.push(R)}}}this.assignDepths(ae);const mapAndSort=v=>v.map((v=>this.moduleGraph.getModule(v))).filter(Boolean).sort(Bt);const ge=[...mapAndSort(this.globalEntry.includeDependencies),...mapAndSort($)];let be=P.get(K);if(be===undefined){P.set(K,be=[])}for(const v of ge){this.assignDepth(v);be.push(v)}}const R=new Set;e:for(const[v,{options:{dependOn:I,runtime:P}}]of this.entries){if(I&&P){const I=new wt(`Entrypoint '${v}' has 'dependOn' and 'runtime' specified. This is not valid.\nEntrypoints that depend on other entrypoints do not have their own runtime.\nThey will use the runtime(s) from referenced entrypoints instead.\nRemove the 'runtime' option from the entrypoint.`);const P=this.entrypoints.get(v);I.chunk=P.getEntrypointChunk();this.errors.push(I)}if(I){const P=this.entrypoints.get(v);const R=P.getEntrypointChunk().getAllReferencedChunks();const $=[];for(const L of I){const I=this.entrypoints.get(L);if(!I){throw new Error(`Entry ${v} depends on ${L}, but this entry was not found`)}if(R.has(I.getEntrypointChunk())){const I=new wt(`Entrypoints '${v}' and '${L}' use 'dependOn' to depend on each other in a circular way.`);const R=P.getEntrypointChunk();I.chunk=R;this.errors.push(I);P.setRuntimeChunk(R);continue e}$.push(I)}for(const v of $){rt(v,P)}}else if(P){const I=this.entrypoints.get(v);let $=this.namedChunks.get(P);if($){if(!R.has($)){const R=new wt(`Entrypoint '${v}' has a 'runtime' option which points to another entrypoint named '${P}'.\nIt's not valid to use other entrypoints as runtime chunk.\nDid you mean to use 'dependOn: ${JSON.stringify(P)}' instead to allow using entrypoint '${v}' within the runtime of entrypoint '${P}'? For this '${P}' must always be loaded when '${v}' is used.\nOr do you want to use the entrypoints '${v}' and '${P}' independently on the same page with a shared runtime? In this case give them both the same value for the 'runtime' option. It must be a name not already used by an entrypoint.`);const $=I.getEntrypointChunk();R.chunk=$;this.errors.push(R);I.setRuntimeChunk($);continue}}else{$=this.addChunk(P);$.preventIntegration=true;R.add($)}I.unshiftChunk($);$.addGroup(I);I.setRuntimeChunk($)}}Ct(this,P);this.hooks.afterChunks.call(this.chunks);this.logger.timeEnd("create chunks");this.logger.time("optimize");this.hooks.optimize.call();while(this.hooks.optimizeModules.call(this.modules)){}this.hooks.afterOptimizeModules.call(this.modules);while(this.hooks.optimizeChunks.call(this.chunks,this.chunkGroups)){}this.hooks.afterOptimizeChunks.call(this.chunks,this.chunkGroups);this.hooks.optimizeTree.callAsync(this.chunks,this.modules,(I=>{if(I){return finalCallback(ot(I,"Compilation.hooks.optimizeTree"))}this.hooks.afterOptimizeTree.call(this.chunks,this.modules);this.hooks.optimizeChunkModules.callAsync(this.chunks,this.modules,(I=>{if(I){return finalCallback(ot(I,"Compilation.hooks.optimizeChunkModules"))}this.hooks.afterOptimizeChunkModules.call(this.chunks,this.modules);const P=this.hooks.shouldRecord.call()!==false;this.hooks.reviveModules.call(this.modules,this.records);this.hooks.beforeModuleIds.call(this.modules);this.hooks.moduleIds.call(this.modules);this.hooks.optimizeModuleIds.call(this.modules);this.hooks.afterOptimizeModuleIds.call(this.modules);this.hooks.reviveChunks.call(this.chunks,this.records);this.hooks.beforeChunkIds.call(this.chunks);this.hooks.chunkIds.call(this.chunks);this.hooks.optimizeChunkIds.call(this.chunks);this.hooks.afterOptimizeChunkIds.call(this.chunks);this.assignRuntimeIds();this.logger.time("compute affected modules with chunk graph");this._computeAffectedModulesWithChunkGraph();this.logger.timeEnd("compute affected modules with chunk graph");this.sortItemsWithChunkIds();if(P){this.hooks.recordModules.call(this.modules,this.records);this.hooks.recordChunks.call(this.chunks,this.records)}this.hooks.optimizeCodeGeneration.call(this.modules);this.logger.timeEnd("optimize");this.logger.time("module hashing");this.hooks.beforeModuleHash.call();this.createModuleHashes();this.hooks.afterModuleHash.call();this.logger.timeEnd("module hashing");this.logger.time("code generation");this.hooks.beforeCodeGeneration.call();this.codeGeneration((I=>{if(I){return finalCallback(I)}this.hooks.afterCodeGeneration.call();this.logger.timeEnd("code generation");this.logger.time("runtime requirements");this.hooks.beforeRuntimeRequirements.call();this.processRuntimeRequirements();this.hooks.afterRuntimeRequirements.call();this.logger.timeEnd("runtime requirements");this.logger.time("hashing");this.hooks.beforeHash.call();const R=this.createHash();this.hooks.afterHash.call();this.logger.timeEnd("hashing");this._runCodeGenerationJobs(R,(I=>{if(I){return finalCallback(I)}if(P){this.logger.time("record hash");this.hooks.recordHash.call(this.records);this.logger.timeEnd("record hash")}this.logger.time("module assets");this.clearAssets();this.hooks.beforeModuleAssets.call();this.createModuleAssets();this.logger.timeEnd("module assets");const cont=()=>{this.logger.time("process assets");this.hooks.processAssets.callAsync(this.assets,(I=>{if(I){return finalCallback(ot(I,"Compilation.hooks.processAssets"))}this.hooks.afterProcessAssets.call(this.assets);this.logger.timeEnd("process assets");this.assets=this._backCompat?Ut(this.assets,"Compilation.assets","DEP_WEBPACK_COMPILATION_ASSETS",`BREAKING CHANGE: No more changes should happen to Compilation.assets after sealing the Compilation.\n\tDo changes to assets earlier, e. g. in Compilation.hooks.processAssets.\n\tMake sure to select an appropriate stage from Compilation.PROCESS_ASSETS_STAGE_*.`):Object.freeze(this.assets);this.summarizeDependencies();if(P){this.hooks.record.call(this,this.records)}if(this.hooks.needAdditionalSeal.call()){this.unseal();return this.seal(v)}return this.hooks.afterSeal.callAsync((v=>{if(v){return finalCallback(ot(v,"Compilation.hooks.afterSeal"))}this.fileSystemInfo.logStatistics();finalCallback()}))}))};this.logger.time("create chunk assets");if(this.hooks.shouldGenerateChunkAssets.call()!==false){this.hooks.beforeChunkAssets.call();this.createChunkAssets((v=>{this.logger.timeEnd("create chunk assets");if(v){return finalCallback(v)}cont()}))}else{this.logger.timeEnd("create chunk assets");cont()}}))}))}))}))}reportDependencyErrorsAndWarnings(v,I){let P=false;for(let R=0;R<I.length;R++){const $=I[R];const L=$.dependencies;for(let I=0;I<L.length;I++){const R=L[I];const $=R.getWarnings(this.moduleGraph);if($){for(let I=0;I<$.length;I++){const L=$[I];const q=new ut(v,L,R.loc);this.warnings.push(q);P=true}}const q=R.getErrors(this.moduleGraph);if(q){for(let I=0;I<q.length;I++){const $=q[I];const L=new lt(v,$,R.loc);this.errors.push(L);P=true}}}if(this.reportDependencyErrorsAndWarnings(v,$.blocks))P=true}return P}codeGeneration(v){const{chunkGraph:I}=this;this.codeGenerationResults=new Ye(this.outputOptions.hashFunction);const P=[];for(const v of this.modules){const R=I.getModuleRuntimes(v);if(R.size===1){for(const $ of R){const R=I.getModuleHash(v,$);P.push({module:v,hash:R,runtime:$,runtimes:[$]})}}else if(R.size>1){const $=new Map;for(const L of R){const R=I.getModuleHash(v,L);const q=$.get(R);if(q===undefined){const I={module:v,hash:R,runtime:L,runtimes:[L]};P.push(I);$.set(R,I)}else{q.runtimes.push(L)}}}}this._runCodeGenerationJobs(P,v)}_runCodeGenerationJobs(v,I){if(v.length===0){return I()}let P=0;let $=0;const{chunkGraph:L,moduleGraph:q,dependencyTemplates:K,runtimeTemplate:ae}=this;const ge=this.codeGenerationResults;const be=[];let xe;const runIteration=()=>{let ve=[];let Ce=new Set;R.eachLimit(v,this.options.parallelism,((v,I)=>{const{module:R}=v;const{codeGenerationDependencies:Ne}=R;if(Ne!==undefined&&(xe===undefined||Ne.some((v=>{const I=q.getModule(v);return xe.has(I)})))){ve.push(v);Ce.add(R);return I()}const{hash:He,runtime:Qe,runtimes:Je}=v;this._codeGenerationModule(R,Qe,Je,He,K,L,q,ae,be,ge,((v,R)=>{if(R)$++;else P++;I(v)}))}),(R=>{if(R)return I(R);if(ve.length>0){if(ve.length===v.length){return I(new Error(`Unable to make progress during code generation because of circular code generation dependency: ${Array.from(Ce,(v=>v.identifier())).join(", ")}`))}v=ve;ve=[];xe=Ce;Ce=new Set;return runIteration()}if(be.length>0){be.sort(jt((v=>v.module),Bt));for(const v of be){this.errors.push(v)}}this.logger.log(`${Math.round(100*$/($+P))}% code generated (${$} generated, ${P} from cache)`);I()}))};runIteration()}_codeGenerationModule(v,I,P,R,$,L,q,K,ae,ge,be){let xe=false;const ve=new Ce(P.map((I=>this._codeGenerationCache.getItemCache(`${v.identifier()}|${Wt(I)}`,`${R}|${$.getHash()}`))));ve.get(((R,Ce)=>{if(R)return be(R);let Ne;if(!Ce){try{xe=true;this.codeGeneratedModules.add(v);Ne=v.codeGeneration({chunkGraph:L,moduleGraph:q,dependencyTemplates:$,runtimeTemplate:K,runtime:I,codeGenerationResults:ge,compilation:this})}catch(R){ae.push(new Ke(v,R));Ne=Ce={sources:new Map,runtimeRequirements:null}}}else{Ne=Ce}for(const I of P){ge.add(v,I,Ne)}if(!Ce){ve.store(Ne,(v=>be(v,xe)))}else{be(null,xe)}}))}_getChunkGraphEntries(){const v=new Set;for(const I of this.entrypoints.values()){const P=I.getRuntimeChunk();if(P)v.add(P)}for(const I of this.asyncEntrypoints){const P=I.getRuntimeChunk();if(P)v.add(P)}return v}processRuntimeRequirements({chunkGraph:v=this.chunkGraph,modules:I=this.modules,chunks:P=this.chunks,codeGenerationResults:R=this.codeGenerationResults,chunkGraphEntries:$=this._getChunkGraphEntries()}={}){const L={chunkGraph:v,codeGenerationResults:R};const{moduleMemCaches2:q}=this;this.logger.time("runtime requirements.modules");const K=this.hooks.additionalModuleRuntimeRequirements;const ae=this.hooks.runtimeRequirementInModule;for(const P of I){if(v.getNumberOfModuleChunks(P)>0){const I=q&&q.get(P);for(const $ of v.getModuleRuntimes(P)){if(I){const R=I.get(`moduleRuntimeRequirements-${Wt($)}`);if(R!==undefined){if(R!==null){v.addModuleRuntimeRequirements(P,$,R,false)}continue}}let q;const ge=R.getRuntimeRequirements(P,$);if(ge&&ge.size>0){q=new Set(ge)}else if(K.isUsed()){q=new Set}else{if(I){I.set(`moduleRuntimeRequirements-${Wt($)}`,null)}continue}K.call(P,q,L);for(const v of q){const I=ae.get(v);if(I!==undefined)I.call(P,q,L)}if(q.size===0){if(I){I.set(`moduleRuntimeRequirements-${Wt($)}`,null)}}else if(I){I.set(`moduleRuntimeRequirements-${Wt($)}`,q);v.addModuleRuntimeRequirements(P,$,q,false)}else{v.addModuleRuntimeRequirements(P,$,q)}}}}this.logger.timeEnd("runtime requirements.modules");this.logger.time("runtime requirements.chunks");for(const I of P){const P=new Set;for(const R of v.getChunkModulesIterable(I)){const $=v.getModuleRuntimeRequirements(R,I.runtime);for(const v of $)P.add(v)}this.hooks.additionalChunkRuntimeRequirements.call(I,P,L);for(const v of P){this.hooks.runtimeRequirementInChunk.for(v).call(I,P,L)}v.addChunkRuntimeRequirements(I,P)}this.logger.timeEnd("runtime requirements.chunks");this.logger.time("runtime requirements.entries");for(const I of $){const P=new Set;for(const R of I.getAllReferencedChunks()){const I=v.getChunkRuntimeRequirements(R);for(const v of I)P.add(v)}this.hooks.additionalTreeRuntimeRequirements.call(I,P,L);for(const v of P){this.hooks.runtimeRequirementInTree.for(v).call(I,P,L)}v.addTreeRuntimeRequirements(I,P)}this.logger.timeEnd("runtime requirements.entries")}addRuntimeModule(v,I,P=this.chunkGraph){if(this._backCompat)pt.setModuleGraphForModule(I,this.moduleGraph);this.modules.add(I);this._modules.set(I.identifier(),I);P.connectChunkAndModule(v,I);P.connectChunkAndRuntimeModule(v,I);if(I.fullHash){P.addFullHashModuleToChunk(v,I)}else if(I.dependentHash){P.addDependentHashModuleToChunk(v,I)}I.attach(this,v,P);const R=this.moduleGraph.getExportsInfo(I);R.setHasProvideInfo();if(typeof v.runtime==="string"){R.setUsedForSideEffectsOnly(v.runtime)}else if(v.runtime===undefined){R.setUsedForSideEffectsOnly(undefined)}else{for(const I of v.runtime){R.setUsedForSideEffectsOnly(I)}}P.addModuleRuntimeRequirements(I,v.runtime,new Set([xt.requireScope]));P.setModuleId(I,"");this.hooks.runtimeModule.call(I,v)}addChunkInGroup(v,I,P,R){if(typeof v==="string"){v={name:v}}const $=v.name;if($){const v=this.namedChunkGroups.get($);if(v!==undefined){if(I){v.addOrigin(I,P,R)}return v}}const L=new Qe(v);if(I)L.addOrigin(I,P,R);const q=this.addChunk($);st(L,q);this.chunkGroups.push(L);if($){this.namedChunkGroups.set($,L)}return L}addAsyncEntrypoint(v,I,P,R){const $=v.name;if($){const v=this.namedChunkGroups.get($);if(v instanceof et){if(v!==undefined){if(I){v.addOrigin(I,P,R)}return v}}else if(v){throw new Error(`Cannot add an async entrypoint with the name '${$}', because there is already an chunk group with this name`)}}const L=this.addChunk($);if(v.filename){L.filenameTemplate=v.filename}const q=new et(v,false);q.setRuntimeChunk(L);q.setEntrypointChunk(L);if($){this.namedChunkGroups.set($,q)}this.chunkGroups.push(q);this.asyncEntrypoints.push(q);st(q,L);if(I){q.addOrigin(I,P,R)}return q}addChunk(v){if(v){const I=this.namedChunks.get(v);if(I!==undefined){return I}}const I=new Ne(v,this._backCompat);this.chunks.add(I);if(this._backCompat)He.setChunkGraphForChunk(I,this.chunkGraph);if(v){this.namedChunks.set(v,I)}return I}assignDepth(v){const I=this.moduleGraph;const P=new Set([v]);let R;I.setDepth(v,0);const processModule=v=>{if(!I.setDepthIfLower(v,R))return;P.add(v)};for(v of P){P.delete(v);R=I.getDepth(v)+1;for(const P of I.getOutgoingConnections(v)){const v=P.module;if(v){processModule(v)}}}}assignDepths(v){const I=this.moduleGraph;const P=new Set(v);let R=P.size;let $=0;let L=0;for(const v of P){I.setDepth(v,$);const q=I.getOutgoingConnectionsByModule(v);if(q){for(const v of q.keys()){if(v)P.add(v)}}L++;if(L>=R){$++;R=P.size}}}getDependencyReferencedExports(v,I){const P=v.getReferencedExports(this.moduleGraph,I);return this.hooks.dependencyReferencedExports.call(P,v,I)}removeReasonsOfDependencyBlock(v,I){if(I.blocks){for(const P of I.blocks){this.removeReasonsOfDependencyBlock(v,P)}}if(I.dependencies){for(const v of I.dependencies){const I=this.moduleGraph.getModule(v);if(I){this.moduleGraph.removeConnection(v);if(this.chunkGraph){for(const v of this.chunkGraph.getModuleChunks(I)){this.patchChunksAfterReasonRemoval(I,v)}}}}}}patchChunksAfterReasonRemoval(v,I){if(!v.hasReasons(this.moduleGraph,I.runtime)){this.removeReasonsOfDependencyBlock(v,v)}if(!v.hasReasonForChunk(I,this.moduleGraph,this.chunkGraph)&&this.chunkGraph.isModuleInChunk(v,I)){this.chunkGraph.disconnectChunkAndModule(I,v);this.removeChunkFromDependencies(v,I)}}removeChunkFromDependencies(v,I){const iteratorDependency=v=>{const P=this.moduleGraph.getModule(v);if(!P){return}this.patchChunksAfterReasonRemoval(P,I)};const P=v.blocks;for(let I=0;I<P.length;I++){const R=P[I];const $=this.chunkGraph.getBlockChunkGroup(R);const L=$.chunks;for(let I=0;I<L.length;I++){const P=L[I];$.removeChunk(P);this.removeChunkFromDependencies(v,P)}}if(v.dependencies){for(const I of v.dependencies)iteratorDependency(I)}}assignRuntimeIds(){const{chunkGraph:v}=this;const processEntrypoint=I=>{const P=I.options.runtime||I.name;const R=I.getRuntimeChunk();v.setRuntimeId(P,R.id)};for(const v of this.entrypoints.values()){processEntrypoint(v)}for(const v of this.asyncEntrypoints){processEntrypoint(v)}}sortItemsWithChunkIds(){for(const v of this.chunkGroups){v.sortItems()}this.errors.sort(nn);this.warnings.sort(nn);this.children.sort(Xt)}summarizeDependencies(){for(let v=0;v<this.children.length;v++){const I=this.children[v];this.fileDependencies.addAll(I.fileDependencies);this.contextDependencies.addAll(I.contextDependencies);this.missingDependencies.addAll(I.missingDependencies);this.buildDependencies.addAll(I.buildDependencies)}for(const v of this.modules){v.addCacheDependencies(this.fileDependencies,this.contextDependencies,this.missingDependencies,this.buildDependencies)}}createModuleHashes(){let v=0;let I=0;const{chunkGraph:P,runtimeTemplate:R,moduleMemCaches2:$}=this;const{hashFunction:L,hashDigest:q,hashDigestLength:K}=this.outputOptions;const ae=[];for(const ge of this.modules){const be=$&&$.get(ge);for(const $ of P.getModuleRuntimes(ge)){if(be){const v=be.get(`moduleHash-${Wt($)}`);if(v!==undefined){P.setModuleHashes(ge,$,v,v.slice(0,K));I++;continue}}v++;const xe=this._createModuleHash(ge,P,$,L,R,q,K,ae);if(be){be.set(`moduleHash-${Wt($)}`,xe)}}}if(ae.length>0){ae.sort(jt((v=>v.module),Bt));for(const v of ae){this.errors.push(v)}}this.logger.log(`${v} modules hashed, ${I} from cache (${Math.round(100*(v+I)/this.modules.size)/100} variants per module in average)`)}_createModuleHash(v,I,P,R,$,L,q,K){let ae;try{const q=qt(R);v.updateHash(q,{chunkGraph:I,runtime:P,runtimeTemplate:$});ae=q.digest(L)}catch(I){K.push(new dt(v,I));ae="XXXXXX"}I.setModuleHashes(v,P,ae,ae.slice(0,q));return ae}createHash(){this.logger.time("hashing: initialize hash");const v=this.chunkGraph;const I=this.runtimeTemplate;const P=this.outputOptions;const R=P.hashFunction;const $=P.hashDigest;const L=P.hashDigestLength;const q=qt(R);if(P.hashSalt){q.update(P.hashSalt)}this.logger.timeEnd("hashing: initialize hash");if(this.children.length>0){this.logger.time("hashing: hash child compilations");for(const v of this.children){q.update(v.hash)}this.logger.timeEnd("hashing: hash child compilations")}if(this.warnings.length>0){this.logger.time("hashing: hash warnings");for(const v of this.warnings){q.update(`${v.message}`)}this.logger.timeEnd("hashing: hash warnings")}if(this.errors.length>0){this.logger.time("hashing: hash errors");for(const v of this.errors){q.update(`${v.message}`)}this.logger.timeEnd("hashing: hash errors")}this.logger.time("hashing: sort chunks");const K=[];const ae=[];for(const v of this.chunks){if(v.hasRuntime()){K.push(v)}else{ae.push(v)}}K.sort(Yt);ae.sort(Yt);const ge=new Map;for(const v of K){ge.set(v,{chunk:v,referencedBy:[],remaining:0})}let be=0;for(const v of ge.values()){for(const I of new Set(Array.from(v.chunk.getAllReferencedAsyncEntrypoints()).map((v=>v.chunks[v.chunks.length-1])))){const P=ge.get(I);P.referencedBy.push(v);v.remaining++;be++}}const xe=[];for(const v of ge.values()){if(v.remaining===0){xe.push(v.chunk)}}if(be>0){const I=[];for(const P of xe){const R=v.getNumberOfChunkFullHashModules(P)!==0;const $=ge.get(P);for(const P of $.referencedBy){if(R){v.upgradeDependentToFullHashModules(P.chunk)}be--;if(--P.remaining===0){I.push(P.chunk)}}if(I.length>0){I.sort(Yt);for(const v of I)xe.push(v);I.length=0}}}if(be>0){const v=[];for(const I of ge.values()){if(I.remaining!==0){v.push(I)}}v.sort(jt((v=>v.chunk),Yt));const I=new wt(`Circular dependency between chunks with runtime (${Array.from(v,(v=>v.chunk.name||v.chunk.id)).join(", ")})\nThis prevents using hashes of each other and should be avoided.`);I.chunk=v[0].chunk;this.warnings.push(I);for(const I of v)xe.push(I.chunk)}this.logger.timeEnd("hashing: sort chunks");const ve=new Set;const Ce=[];const Ne=new Map;const He=[];const processChunk=K=>{this.logger.time("hashing: hash runtime modules");const ae=K.runtime;for(const P of v.getChunkModulesIterable(K)){if(!v.hasModuleHashes(P,ae)){const q=this._createModuleHash(P,v,ae,R,I,$,L,He);let K=Ne.get(q);if(K){const v=K.get(P);if(v){v.runtimes.push(ae);continue}}else{K=new Map;Ne.set(q,K)}const ge={module:P,hash:q,runtime:ae,runtimes:[ae]};K.set(P,ge);Ce.push(ge)}}this.logger.timeAggregate("hashing: hash runtime modules");try{this.logger.time("hashing: hash chunks");const I=qt(R);if(P.hashSalt){I.update(P.hashSalt)}K.updateHash(I,v);this.hooks.chunkHash.call(K,I,{chunkGraph:v,codeGenerationResults:this.codeGenerationResults,moduleGraph:this.moduleGraph,runtimeTemplate:this.runtimeTemplate});const ae=I.digest($);q.update(ae);K.hash=ae;K.renderedHash=K.hash.slice(0,L);const ge=v.getChunkFullHashModulesIterable(K);if(ge){ve.add(K)}else{this.hooks.contentHash.call(K)}}catch(v){this.errors.push(new Je(K,"",v))}this.logger.timeAggregate("hashing: hash chunks")};for(const v of ae)processChunk(v);for(const v of xe)processChunk(v);if(He.length>0){He.sort(jt((v=>v.module),Bt));for(const v of He){this.errors.push(v)}}this.logger.timeAggregateEnd("hashing: hash runtime modules");this.logger.timeAggregateEnd("hashing: hash chunks");this.logger.time("hashing: hash digest");this.hooks.fullHash.call(q);this.fullHash=q.digest($);this.hash=this.fullHash.slice(0,L);this.logger.timeEnd("hashing: hash digest");this.logger.time("hashing: process full hash modules");for(const P of ve){for(const q of v.getChunkFullHashModulesIterable(P)){const K=qt(R);q.updateHash(K,{chunkGraph:v,runtime:P.runtime,runtimeTemplate:I});const ae=K.digest($);const ge=v.getModuleHash(q,P.runtime);v.setModuleHashes(q,P.runtime,ae,ae.slice(0,L));Ne.get(ge).get(q).hash=ae}const q=qt(R);q.update(P.hash);q.update(this.hash);const K=q.digest($);P.hash=K;P.renderedHash=P.hash.slice(0,L);this.hooks.contentHash.call(P)}this.logger.timeEnd("hashing: process full hash modules");return Ce}emitAsset(v,I,P={}){if(this.assets[v]){if(!Qt(this.assets[v],I)){this.errors.push(new wt(`Conflict: Multiple assets emit different content to the same filename ${v}${P.sourceFilename?`. Original source ${P.sourceFilename}`:""}`));this.assets[v]=I;this._setAssetInfo(v,P);return}const R=this.assetsInfo.get(v);const $={...R,...P};this._setAssetInfo(v,$,R);return}this.assets[v]=I;this._setAssetInfo(v,P,undefined)}_setAssetInfo(v,I,P=this.assetsInfo.get(v)){if(I===undefined){this.assetsInfo.delete(v)}else{this.assetsInfo.set(v,I)}const R=P&&P.related;const $=I&&I.related;if(R){for(const I of Object.keys(R)){const remove=P=>{const R=this._assetsRelatedIn.get(P);if(R===undefined)return;const $=R.get(I);if($===undefined)return;$.delete(v);if($.size!==0)return;R.delete(I);if(R.size===0)this._assetsRelatedIn.delete(P)};const P=R[I];if(Array.isArray(P)){for(const v of P){remove(v)}}else if(P){remove(P)}}}if($){for(const I of Object.keys($)){const add=P=>{let R=this._assetsRelatedIn.get(P);if(R===undefined){this._assetsRelatedIn.set(P,R=new Map)}let $=R.get(I);if($===undefined){R.set(I,$=new Set)}$.add(v)};const P=$[I];if(Array.isArray(P)){for(const v of P){add(v)}}else if(P){add(P)}}}}updateAsset(v,I,P=undefined){if(!this.assets[v]){throw new Error(`Called Compilation.updateAsset for not existing filename ${v}`)}this.assets[v]=typeof I==="function"?I(this.assets[v]):I;if(P!==undefined){const I=this.assetsInfo.get(v)||Jt;if(typeof P==="function"){this._setAssetInfo(v,P(I),I)}else{this._setAssetInfo(v,Tt(I,P),I)}}}renameAsset(v,I){const P=this.assets[v];if(!P){throw new Error(`Called Compilation.renameAsset for not existing filename ${v}`)}if(this.assets[I]&&!Qt(this.assets[v],P)){this.errors.push(new wt(`Conflict: Called Compilation.renameAsset for already existing filename ${I} with different content`))}const R=this.assetsInfo.get(v);const $=this._assetsRelatedIn.get(v);if($){for(const[P,R]of $){for(const $ of R){const R=this.assetsInfo.get($);if(!R)continue;const L=R.related;if(!L)continue;const q=L[P];let K;if(Array.isArray(q)){K=q.map((P=>P===v?I:P))}else if(q===v){K=I}else continue;this.assetsInfo.set($,{...R,related:{...L,[P]:K}})}}}this._setAssetInfo(v,undefined,R);this._setAssetInfo(I,R);delete this.assets[v];this.assets[I]=P;for(const P of this.chunks){{const R=P.files.size;P.files.delete(v);if(R!==P.files.size){P.files.add(I)}}{const R=P.auxiliaryFiles.size;P.auxiliaryFiles.delete(v);if(R!==P.auxiliaryFiles.size){P.auxiliaryFiles.add(I)}}}}deleteAsset(v){if(!this.assets[v]){return}delete this.assets[v];const I=this.assetsInfo.get(v);this._setAssetInfo(v,undefined,I);const P=I&&I.related;if(P){for(const v of Object.keys(P)){const checkUsedAndDelete=v=>{if(!this._assetsRelatedIn.has(v)){this.deleteAsset(v)}};const I=P[v];if(Array.isArray(I)){for(const v of I){checkUsedAndDelete(v)}}else if(I){checkUsedAndDelete(I)}}}for(const I of this.chunks){I.files.delete(v);I.auxiliaryFiles.delete(v)}}getAssets(){const v=[];for(const I of Object.keys(this.assets)){if(Object.prototype.hasOwnProperty.call(this.assets,I)){v.push({name:I,source:this.assets[I],info:this.assetsInfo.get(I)||Jt})}}return v}getAsset(v){if(!Object.prototype.hasOwnProperty.call(this.assets,v))return;return{name:v,source:this.assets[v],info:this.assetsInfo.get(v)||Jt}}clearAssets(){for(const v of this.chunks){v.files.clear();v.auxiliaryFiles.clear()}}createModuleAssets(){const{chunkGraph:v}=this;for(const I of this.modules){const P=I.buildInfo;if(P.assets){const R=P.assetsInfo;for(const $ of Object.keys(P.assets)){const L=this.getPath($,{chunkGraph:this.chunkGraph,module:I});for(const P of v.getModuleChunksIterable(I)){P.auxiliaryFiles.add(L)}this.emitAsset(L,P.assets[$],R?R.get($):undefined);this.hooks.moduleAsset.call(I,L)}}}}getRenderManifest(v){return this.hooks.renderManifest.call([],v)}createChunkAssets(v){const I=this.outputOptions;const P=new WeakMap;const $=new Map;R.forEachLimit(this.chunks,15,((v,L)=>{let q;try{q=this.getRenderManifest({chunk:v,hash:this.hash,fullHash:this.fullHash,outputOptions:I,codeGenerationResults:this.codeGenerationResults,moduleTemplates:this.moduleTemplates,dependencyTemplates:this.dependencyTemplates,chunkGraph:this.chunkGraph,moduleGraph:this.moduleGraph,runtimeTemplate:this.runtimeTemplate})}catch(I){this.errors.push(new Je(v,"",I));return L()}R.each(q,((I,R)=>{const L=I.identifier;const q=I.hash;const K=this._assetsCache.getItemCache(L,q);K.get(((L,ae)=>{let ge;let be;let xe;let Ce=true;const errorAndCallback=I=>{const P=be||(typeof be==="string"?be:typeof ge==="string"?ge:"");this.errors.push(new Je(v,P,I));Ce=false;return R()};try{if("filename"in I){be=I.filename;xe=I.info}else{ge=I.filenameTemplate;const v=this.getPathWithInfo(ge,I.pathOptions);be=v.path;xe=I.info?{...v.info,...I.info}:v.info}if(L){return errorAndCallback(L)}let Ne=ae;const He=$.get(be);if(He!==undefined){if(He.hash!==q){Ce=false;return R(new wt(`Conflict: Multiple chunks emit assets to the same filename ${be}`+` (chunks ${He.chunk.id} and ${v.id})`))}Ne=He.source}else if(!Ne){Ne=I.render();if(!(Ne instanceof ve)){const v=P.get(Ne);if(v){Ne=v}else{const v=new ve(Ne);P.set(Ne,v);Ne=v}}}this.emitAsset(be,Ne,xe);if(I.auxiliary){v.auxiliaryFiles.add(be)}else{v.files.add(be)}this.hooks.chunkAsset.call(v,be);$.set(be,{hash:q,source:Ne,chunk:v});if(Ne!==ae){K.store(Ne,(v=>{if(v)return errorAndCallback(v);Ce=false;return R()}))}else{Ce=false;R()}}catch(L){if(!Ce)throw L;errorAndCallback(L)}}))}),L)}),v)}getPath(v,I={}){if(!I.hash){I={hash:this.hash,...I}}return this.getAssetPath(v,I)}getPathWithInfo(v,I={}){if(!I.hash){I={hash:this.hash,...I}}return this.getAssetPathWithInfo(v,I)}getAssetPath(v,I){return this.hooks.assetPath.call(typeof v==="function"?v(I):v,I,undefined)}getAssetPathWithInfo(v,I){const P={};const R=this.hooks.assetPath.call(typeof v==="function"?v(I,P):v,I,P);return{path:R,info:P}}getWarnings(){return this.hooks.processWarnings.call(this.warnings)}getErrors(){return this.hooks.processErrors.call(this.errors)}createChildCompiler(v,I,P){const R=this.childrenCounters[v]||0;this.childrenCounters[v]=R+1;return this.compiler.createChildCompiler(this,v,R,I,P)}executeModule(v,I,P){const $=new Set([v]);Ht($,10,((v,I,P)=>{this.buildQueue.waitFor(v,(R=>{if(R)return P(R);this.processDependenciesQueue.waitFor(v,(R=>{if(R)return P(R);for(const{module:P}of this.moduleGraph.getOutgoingConnections(v)){const v=$.size;$.add(P);if($.size!==v)I(P)}P()}))}))}),(L=>{if(L)return P(L);const q=new He(this.moduleGraph,this.outputOptions.hashFunction);const K="build time";const{hashFunction:ae,hashDigest:ge,hashDigestLength:be}=this.outputOptions;const xe=this.runtimeTemplate;const ve=new Ne("build time chunk",this._backCompat);ve.id=ve.name;ve.ids=[ve.id];ve.runtime=K;const Ce=new et({runtime:K,chunkLoading:false,...I.entryOptions});q.connectChunkAndEntryModule(ve,v,Ce);st(Ce,ve);Ce.setRuntimeChunk(ve);Ce.setEntrypointChunk(ve);const Qe=new Set([ve]);for(const v of $){const I=v.identifier();q.setModuleId(v,I);q.connectChunkAndModule(ve,v)}const Je=[];for(const v of $){this._createModuleHash(v,q,K,ae,xe,ge,be,Je)}const Ve=new Ye(this.outputOptions.hashFunction);const codeGen=(v,I)=>{this._codeGenerationModule(v,K,[K],q.getModuleHash(v,K),this.dependencyTemplates,q,this.moduleGraph,xe,Je,Ve,((v,P)=>{I(v)}))};const reportErrors=()=>{if(Je.length>0){Je.sort(jt((v=>v.module),Bt));for(const v of Je){this.errors.push(v)}Je.length=0}};R.eachLimit($,10,codeGen,(I=>{if(I)return P(I);reportErrors();const L=this.chunkGraph;this.chunkGraph=q;this.processRuntimeRequirements({chunkGraph:q,modules:$,chunks:Qe,codeGenerationResults:Ve,chunkGraphEntries:Qe});this.chunkGraph=L;const Ce=q.getChunkRuntimeModulesIterable(ve);for(const v of Ce){$.add(v);this._createModuleHash(v,q,K,ae,xe,ge,be,Je)}R.eachLimit(Ce,10,codeGen,(I=>{if(I)return P(I);reportErrors();const L=new Map;const ae=new Map;const ge=new Ot;const be=new Ot;const xe=new Ot;const Ce=new Ot;const Ne=new Map;let He=true;const Qe={assets:Ne,__webpack_require__:undefined,chunk:ve,chunkGraph:q};R.eachLimit($,10,((v,I)=>{const P=Ve.get(v,K);const R={module:v,codeGenerationResult:P,preparedInfo:undefined,moduleObject:undefined};L.set(v,R);ae.set(v.identifier(),R);v.addCacheDependencies(ge,be,xe,Ce);if(v.buildInfo.cacheable===false){He=false}if(v.buildInfo&&v.buildInfo.assets){const{assets:I,assetsInfo:P}=v.buildInfo;for(const v of Object.keys(I)){Ne.set(v,{source:I[v],info:P?P.get(v):undefined})}}this.hooks.prepareModuleExecution.callAsync(R,Qe,I)}),(I=>{if(I)return P(I);let R;try{const{strictModuleErrorHandling:I,strictModuleExceptionHandling:P}=this.outputOptions;const __nested_webpack_require_161494__=v=>{const I=K[v];if(I!==undefined){if(I.error)throw I.error;return I.exports}const P=ae.get(v);return __webpack_require_module__(P,v)};const $=__nested_webpack_require_161494__[xt.interceptModuleExecution.replace(`${xt.require}.`,"")]=[];const K=__nested_webpack_require_161494__[xt.moduleCache.replace(`${xt.require}.`,"")]={};Qe.__webpack_require__=__nested_webpack_require_161494__;const __webpack_require_module__=(v,R)=>{const L={id:R,module:{id:R,exports:{},loaded:false,error:undefined},require:__nested_webpack_require_161494__};for(const v of $){v(L)}const q=v.module;this.buildTimeExecutedModules.add(q);const ae=L.module;v.moduleObject=ae;try{if(R)K[R]=ae;it((()=>this.hooks.executeModule.call(v,Qe)),"Compilation.hooks.executeModule");ae.loaded=true;return ae.exports}catch(v){if(P){if(R)delete K[R]}else if(I){ae.error=v}if(!v.module)v.module=q;throw v}};for(const v of q.getChunkRuntimeModulesInOrder(ve)){__webpack_require_module__(L.get(v))}R=__nested_webpack_require_161494__(v.identifier())}catch(I){const R=new wt(`Execution of module code from module graph (${v.readableIdentifier(this.requestShortener)}) failed: ${I.message}`);R.stack=I.stack;R.module=I.module;return P(R)}P(null,{exports:R,assets:Ne,cacheable:He,fileDependencies:ge,contextDependencies:be,missingDependencies:xe,buildDependencies:Ce})}))}))}))}))}checkConstraints(){const v=this.chunkGraph;const I=new Set;for(const P of this.modules){if(P.type===bt)continue;const R=v.getModuleId(P);if(R===null)continue;if(I.has(R)){throw new Error(`checkConstraints: duplicate module id ${R}`)}I.add(R)}for(const I of this.chunks){for(const P of v.getChunkModulesIterable(I)){if(!this.modules.has(P)){throw new Error("checkConstraints: module in chunk but not in compilation "+` ${I.debugId} ${P.debugId}`)}}for(const P of v.getChunkEntryModulesIterable(I)){if(!this.modules.has(P)){throw new Error("checkConstraints: entry module in chunk but not in compilation "+` ${I.debugId} ${P.debugId}`)}}}for(const v of this.chunkGroups){v.checkConstraints()}}}Compilation.prototype.factorizeModule=function(v,I){this.factorizeQueue.add(v,I)};const on=Compilation.prototype;Object.defineProperty(on,"modifyHash",{writable:false,enumerable:false,configurable:false,value:()=>{throw new Error("Compilation.modifyHash was removed in favor of Compilation.hooks.fullHash")}});Object.defineProperty(on,"cache",{enumerable:false,configurable:false,get:xe.deprecate((function(){return this.compiler.cache}),"Compilation.cache was removed in favor of Compilation.getCache()","DEP_WEBPACK_COMPILATION_CACHE"),set:xe.deprecate((v=>{}),"Compilation.cache was removed in favor of Compilation.getCache()","DEP_WEBPACK_COMPILATION_CACHE")});Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL=-2e3;Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS=-1e3;Compilation.PROCESS_ASSETS_STAGE_DERIVED=-200;Compilation.PROCESS_ASSETS_STAGE_ADDITIONS=-100;Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE=100;Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT=200;Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY=300;Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE=400;Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING=500;Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE=700;Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE=1e3;Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH=2500;Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER=3e3;Compilation.PROCESS_ASSETS_STAGE_ANALYSE=4e3;Compilation.PROCESS_ASSETS_STAGE_REPORT=5e3;v.exports=Compilation},46251:function(v,I,P){"use strict";const R=P(54650);const $=P(78175);const{SyncHook:L,SyncBailHook:q,AsyncParallelHook:K,AsyncSeriesHook:ae}=P(84891);const{SizeOnlySource:ge}=P(51255);const be=P(24378);const xe=P(37292);const ve=P(44747);const Ce=P(23630);const Ne=P(29327);const He=P(57753);const Qe=P(9346);const Je=P(48101);const Ve=P(79497);const Ke=P(12981);const Ye=P(62929);const Xe=P(74951);const Ze=P(87370);const et=P(94252);const{Logger:tt}=P(64452);const{join:nt,dirname:st,mkdirp:rt}=P(80749);const{makePathsRelative:ot}=P(46579);const{isSourceEqual:it}=P(48983);const isSorted=v=>{for(let I=1;I<v.length;I++){if(v[I-1]>v[I])return false}return true};const sortObject=(v,I)=>{const P={};for(const R of I.sort()){P[R]=v[R]}return P};const includesHash=(v,I)=>{if(!I)return false;if(Array.isArray(I)){return I.some((I=>v.includes(I)))}return v.includes(I)};class Compiler{constructor(v,I={}){this.hooks=Object.freeze({initialize:new L([]),shouldEmit:new q(["compilation"]),done:new ae(["stats"]),afterDone:new L(["stats"]),additionalPass:new ae([]),beforeRun:new ae(["compiler"]),run:new ae(["compiler"]),emit:new ae(["compilation"]),assetEmitted:new ae(["file","info"]),afterEmit:new ae(["compilation"]),thisCompilation:new L(["compilation","params"]),compilation:new L(["compilation","params"]),normalModuleFactory:new L(["normalModuleFactory"]),contextModuleFactory:new L(["contextModuleFactory"]),beforeCompile:new ae(["params"]),compile:new L(["params"]),make:new K(["compilation"]),finishMake:new ae(["compilation"]),afterCompile:new ae(["compilation"]),readRecords:new ae([]),emitRecords:new ae([]),watchRun:new ae(["compiler"]),failed:new L(["error"]),invalid:new L(["filename","changeTime"]),watchClose:new L([]),shutdown:new ae([]),infrastructureLog:new q(["origin","type","args"]),environment:new L([]),afterEnvironment:new L([]),afterPlugins:new L(["compiler"]),afterResolvers:new L(["compiler"]),entryOption:new q(["context","entry"])});this.webpack=be;this.name=undefined;this.parentCompilation=undefined;this.root=this;this.outputPath="";this.watching=undefined;this.outputFileSystem=null;this.intermediateFileSystem=null;this.inputFileSystem=null;this.watchFileSystem=null;this.recordsInputPath=null;this.recordsOutputPath=null;this.records={};this.managedPaths=new Set;this.unmanagedPaths=new Set;this.immutablePaths=new Set;this.modifiedFiles=undefined;this.removedFiles=undefined;this.fileTimestamps=undefined;this.contextTimestamps=undefined;this.fsStartTime=undefined;this.resolverFactory=new Ye;this.infrastructureLogger=undefined;this.platform={web:null,browser:null,webworker:null,node:null,nwjs:null,electron:null};this.options=I;this.context=v;this.requestShortener=new Ke(v,this.root);this.cache=new xe;this.moduleMemCaches=undefined;this.compilerPath="";this.running=false;this.idle=false;this.watchMode=false;this._backCompat=this.options.experiments.backCompat!==false;this._lastCompilation=undefined;this._lastNormalModuleFactory=undefined;this._assetEmittingSourceCache=new WeakMap;this._assetEmittingWrittenFiles=new Map;this._assetEmittingPreviousFiles=new Set}getCache(v){return new ve(this.cache,`${this.compilerPath}${v}`,this.options.output.hashFunction)}getInfrastructureLogger(v){if(!v){throw new TypeError("Compiler.getInfrastructureLogger(name) called without a name")}return new tt(((I,P)=>{if(typeof v==="function"){v=v();if(!v){throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name")}}if(this.hooks.infrastructureLog.call(v,I,P)===undefined&&this.infrastructureLogger!==undefined){this.infrastructureLogger(v,I,P)}}),(I=>{if(typeof v==="function"){if(typeof I==="function"){return this.getInfrastructureLogger((()=>{if(typeof v==="function"){v=v();if(!v){throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name")}}if(typeof I==="function"){I=I();if(!I){throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name")}}return`${v}/${I}`}))}return this.getInfrastructureLogger((()=>{if(typeof v==="function"){v=v();if(!v){throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name")}}return`${v}/${I}`}))}if(typeof I==="function"){return this.getInfrastructureLogger((()=>{if(typeof I==="function"){I=I();if(!I){throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name")}}return`${v}/${I}`}))}return this.getInfrastructureLogger(`${v}/${I}`)}))}_cleanupLastCompilation(){if(this._lastCompilation!==undefined){for(const v of this._lastCompilation.children){for(const I of v.modules){Ce.clearChunkGraphForModule(I);Je.clearModuleGraphForModule(I);I.cleanupForCache()}for(const I of v.chunks){Ce.clearChunkGraphForChunk(I)}}for(const v of this._lastCompilation.modules){Ce.clearChunkGraphForModule(v);Je.clearModuleGraphForModule(v);v.cleanupForCache()}for(const v of this._lastCompilation.chunks){Ce.clearChunkGraphForChunk(v)}this._lastCompilation=undefined}}_cleanupLastNormalModuleFactory(){if(this._lastNormalModuleFactory!==undefined){this._lastNormalModuleFactory.cleanupForCache();this._lastNormalModuleFactory=undefined}}watch(v,I){if(this.running){return I(new He)}this.running=true;this.watchMode=true;this.watching=new Ze(this,v,I);return this.watching}run(v){if(this.running){return v(new He)}let I;const finalCallback=(P,R)=>{if(I)I.time("beginIdle");this.idle=true;this.cache.beginIdle();this.idle=true;if(I)I.timeEnd("beginIdle");this.running=false;if(P){this.hooks.failed.call(P)}if(v!==undefined)v(P,R);this.hooks.afterDone.call(R)};const P=Date.now();this.running=true;const onCompiled=(v,R)=>{if(v)return finalCallback(v);const $=R;if(this.hooks.shouldEmit.call($)===false){$.startTime=P;$.endTime=Date.now();const v=new Xe($);this.hooks.done.callAsync(v,(I=>{if(I)return finalCallback(I);return finalCallback(null,v)}));return}process.nextTick((()=>{I=$.getLogger("webpack.Compiler");I.time("emitAssets");this.emitAssets($,(v=>{I.timeEnd("emitAssets");if(v)return finalCallback(v);if($.hooks.needAdditionalPass.call()){$.needAdditionalPass=true;$.startTime=P;$.endTime=Date.now();I.time("done hook");const v=new Xe($);this.hooks.done.callAsync(v,(v=>{I.timeEnd("done hook");if(v)return finalCallback(v);this.hooks.additionalPass.callAsync((v=>{if(v)return finalCallback(v);this.compile(onCompiled)}))}));return}I.time("emitRecords");this.emitRecords((v=>{I.timeEnd("emitRecords");if(v)return finalCallback(v);$.startTime=P;$.endTime=Date.now();I.time("done hook");const R=new Xe($);this.hooks.done.callAsync(R,(v=>{I.timeEnd("done hook");if(v)return finalCallback(v);this.cache.storeBuildDependencies($.buildDependencies,(v=>{if(v)return finalCallback(v);return finalCallback(null,R)}))}))}))}))}))};const run=()=>{this.hooks.beforeRun.callAsync(this,(v=>{if(v)return finalCallback(v);this.hooks.run.callAsync(this,(v=>{if(v)return finalCallback(v);this.readRecords((v=>{if(v)return finalCallback(v);this.compile(onCompiled)}))}))}))};if(this.idle){this.cache.endIdle((v=>{if(v)return finalCallback(v);this.idle=false;run()}))}else{run()}}runAsChild(v){const I=Date.now();const finalCallback=(I,P,R)=>{try{v(I,P,R)}catch(v){const I=new et(`compiler.runAsChild callback error: ${v}`);I.details=v.stack;this.parentCompilation.errors.push(I)}};this.compile(((v,P)=>{if(v)return finalCallback(v);const R=P;const $=this.parentCompilation;$.children.push(R);for(const{name:v,source:I,info:P}of R.getAssets()){$.emitAsset(v,I,P)}const L=[];for(const v of R.entrypoints.values()){L.push(...v.chunks)}R.startTime=I;R.endTime=Date.now();return finalCallback(null,L,R)}))}purgeInputFileSystem(){if(this.inputFileSystem&&this.inputFileSystem.purge){this.inputFileSystem.purge()}}emitAssets(v,I){let P;const emitFiles=R=>{if(R)return I(R);const L=v.getAssets();v.assets={...v.assets};const q=new Map;const K=new Set;$.forEachLimit(L,15,(({name:I,source:R,info:$},L)=>{let ae=I;let be=$.immutable;const xe=ae.indexOf("?");if(xe>=0){ae=ae.slice(0,xe);be=be&&(includesHash(ae,$.contenthash)||includesHash(ae,$.chunkhash)||includesHash(ae,$.modulehash)||includesHash(ae,$.fullhash))}const writeOut=$=>{if($)return L($);const xe=nt(this.outputFileSystem,P,ae);K.add(xe);const ve=this._assetEmittingWrittenFiles.get(xe);let Ce=this._assetEmittingSourceCache.get(R);if(Ce===undefined){Ce={sizeOnlySource:undefined,writtenTo:new Map};this._assetEmittingSourceCache.set(R,Ce)}let Ne;const checkSimilarFile=()=>{const v=xe.toLowerCase();Ne=q.get(v);if(Ne!==undefined){const{path:v,source:P}=Ne;if(it(P,R)){if(Ne.size!==undefined){updateWithReplacementSource(Ne.size)}else{if(!Ne.waiting)Ne.waiting=[];Ne.waiting.push({file:I,cacheEntry:Ce})}alreadyWritten()}else{const P=new et(`Prevent writing to file that only differs in casing or query string from already written file.\nThis will lead to a race-condition and corrupted files on case-insensitive file systems.\n${xe}\n${v}`);P.file=I;L(P)}return true}q.set(v,Ne={path:xe,source:R,size:undefined,waiting:undefined});return false};const getContent=()=>{if(typeof R.buffer==="function"){return R.buffer()}const v=R.source();if(Buffer.isBuffer(v)){return v}return Buffer.from(v,"utf8")};const alreadyWritten=()=>{if(ve===undefined){const v=1;this._assetEmittingWrittenFiles.set(xe,v);Ce.writtenTo.set(xe,v)}else{Ce.writtenTo.set(xe,ve)}L()};const doWrite=$=>{this.outputFileSystem.writeFile(xe,$,(q=>{if(q)return L(q);v.emittedAssets.add(I);const K=ve===undefined?1:ve+1;Ce.writtenTo.set(xe,K);this._assetEmittingWrittenFiles.set(xe,K);this.hooks.assetEmitted.callAsync(I,{content:$,source:R,outputPath:P,compilation:v,targetPath:xe},L)}))};const updateWithReplacementSource=v=>{updateFileWithReplacementSource(I,Ce,v);Ne.size=v;if(Ne.waiting!==undefined){for(const{file:I,cacheEntry:P}of Ne.waiting){updateFileWithReplacementSource(I,P,v)}}};const updateFileWithReplacementSource=(I,P,R)=>{if(!P.sizeOnlySource){P.sizeOnlySource=new ge(R)}v.updateAsset(I,P.sizeOnlySource,{size:R})};const processExistingFile=P=>{if(be){updateWithReplacementSource(P.size);return alreadyWritten()}const R=getContent();updateWithReplacementSource(R.length);if(R.length===P.size){v.comparedForEmitAssets.add(I);return this.outputFileSystem.readFile(xe,((v,I)=>{if(v||!R.equals(I)){return doWrite(R)}return alreadyWritten()}))}return doWrite(R)};const processMissingFile=()=>{const v=getContent();updateWithReplacementSource(v.length);return doWrite(v)};if(ve!==undefined){const P=Ce.writtenTo.get(xe);if(P===ve){if(this._assetEmittingPreviousFiles.has(xe)){const P=Ce.sizeOnlySource;v.updateAsset(I,P,{size:P.size()});return L()}be=true}else if(!be){if(checkSimilarFile())return;return processMissingFile()}}if(checkSimilarFile())return;if(this.options.output.compareBeforeEmit){this.outputFileSystem.stat(xe,((v,I)=>{const P=!v&&I.isFile();if(P){processExistingFile(I)}else{processMissingFile()}}))}else{processMissingFile()}};if(/\/|\\/.test(ae)){const v=this.outputFileSystem;const I=st(v,nt(v,P,ae));rt(v,I,writeOut)}else{writeOut()}}),(P=>{q.clear();if(P){this._assetEmittingPreviousFiles.clear();return I(P)}this._assetEmittingPreviousFiles=K;this.hooks.afterEmit.callAsync(v,(v=>{if(v)return I(v);return I()}))}))};this.hooks.emit.callAsync(v,(R=>{if(R)return I(R);P=v.getPath(this.outputPath,{});rt(this.outputFileSystem,P,emitFiles)}))}emitRecords(v){if(this.hooks.emitRecords.isUsed()){if(this.recordsOutputPath){$.parallel([v=>this.hooks.emitRecords.callAsync(v),this._emitRecords.bind(this)],(I=>v(I)))}else{this.hooks.emitRecords.callAsync(v)}}else if(this.recordsOutputPath){this._emitRecords(v)}else{v()}}_emitRecords(v){const writeFile=()=>{this.outputFileSystem.writeFile(this.recordsOutputPath,JSON.stringify(this.records,((v,I)=>{if(typeof I==="object"&&I!==null&&!Array.isArray(I)){const v=Object.keys(I);if(!isSorted(v)){return sortObject(I,v)}}return I}),2),v)};const I=st(this.outputFileSystem,this.recordsOutputPath);if(!I){return writeFile()}rt(this.outputFileSystem,I,(I=>{if(I)return v(I);writeFile()}))}readRecords(v){if(this.hooks.readRecords.isUsed()){if(this.recordsInputPath){$.parallel([v=>this.hooks.readRecords.callAsync(v),this._readRecords.bind(this)],(I=>v(I)))}else{this.records={};this.hooks.readRecords.callAsync(v)}}else if(this.recordsInputPath){this._readRecords(v)}else{this.records={};v()}}_readRecords(v){if(!this.recordsInputPath){this.records={};return v()}this.inputFileSystem.stat(this.recordsInputPath,(I=>{if(I)return v();this.inputFileSystem.readFile(this.recordsInputPath,((I,P)=>{if(I)return v(I);try{this.records=R(P.toString("utf-8"))}catch(I){return v(new Error(`Cannot parse records: ${I.message}`))}return v()}))}))}createChildCompiler(v,I,P,R,$){const L=new Compiler(this.context,{...this.options,output:{...this.options.output,...R}});L.name=I;L.outputPath=this.outputPath;L.inputFileSystem=this.inputFileSystem;L.outputFileSystem=null;L.resolverFactory=this.resolverFactory;L.modifiedFiles=this.modifiedFiles;L.removedFiles=this.removedFiles;L.fileTimestamps=this.fileTimestamps;L.contextTimestamps=this.contextTimestamps;L.fsStartTime=this.fsStartTime;L.cache=this.cache;L.compilerPath=`${this.compilerPath}${I}|${P}|`;L._backCompat=this._backCompat;const q=ot(this.context,I,this.root);if(!this.records[q]){this.records[q]=[]}if(this.records[q][P]){L.records=this.records[q][P]}else{this.records[q].push(L.records={})}L.parentCompilation=v;L.root=this.root;if(Array.isArray($)){for(const v of $){if(v){v.apply(L)}}}for(const v in this.hooks){if(!["make","compile","emit","afterEmit","invalid","done","thisCompilation"].includes(v)&&L.hooks[v]){L.hooks[v].taps=this.hooks[v].taps.slice()}}v.hooks.childCompiler.call(L,I,P);return L}isChild(){return Boolean(this.parentCompilation)}createCompilation(v){this._cleanupLastCompilation();return this._lastCompilation=new Ne(this,v)}newCompilation(v){const I=this.createCompilation(v);I.name=this.name;I.records=this.records;this.hooks.thisCompilation.call(I,v);this.hooks.compilation.call(I,v);return I}createNormalModuleFactory(){this._cleanupLastNormalModuleFactory();const v=new Ve({context:this.options.context,fs:this.inputFileSystem,resolverFactory:this.resolverFactory,options:this.options.module,associatedObjectForCache:this.root,layers:this.options.experiments.layers});this._lastNormalModuleFactory=v;this.hooks.normalModuleFactory.call(v);return v}createContextModuleFactory(){const v=new Qe(this.resolverFactory);this.hooks.contextModuleFactory.call(v);return v}newCompilationParams(){const v={normalModuleFactory:this.createNormalModuleFactory(),contextModuleFactory:this.createContextModuleFactory()};return v}compile(v){const I=this.newCompilationParams();this.hooks.beforeCompile.callAsync(I,(P=>{if(P)return v(P);this.hooks.compile.call(I);const R=this.newCompilation(I);const $=R.getLogger("webpack.Compiler");$.time("make hook");this.hooks.make.callAsync(R,(I=>{$.timeEnd("make hook");if(I)return v(I);$.time("finish make hook");this.hooks.finishMake.callAsync(R,(I=>{$.timeEnd("finish make hook");if(I)return v(I);process.nextTick((()=>{$.time("finish compilation");R.finish((I=>{$.timeEnd("finish compilation");if(I)return v(I);$.time("seal compilation");R.seal((I=>{$.timeEnd("seal compilation");if(I)return v(I);$.time("afterCompile hook");this.hooks.afterCompile.callAsync(R,(I=>{$.timeEnd("afterCompile hook");if(I)return v(I);return v(null,R)}))}))}))}))}))}))}))}close(v){if(this.watching){this.watching.close((I=>{this.close(v)}));return}this.hooks.shutdown.callAsync((I=>{if(I)return v(I);this._lastCompilation=undefined;this._lastNormalModuleFactory=undefined;this.cache.shutdown(v)}))}}v.exports=Compiler},40255:function(v,I,P){"use strict";const{DEFAULT_EXPORT:R,NAMESPACE_OBJECT_EXPORT:$}=P(27297);const L=/^__WEBPACK_MODULE_REFERENCE__(\d+)_([\da-f]+|ns)(_call)?(_directImport)?(?:_asiSafe(\d))?__$/;class ConcatenationScope{constructor(v,I){this._currentModule=I;if(Array.isArray(v)){const I=new Map;for(const P of v){I.set(P.module,P)}v=I}this._modulesMap=v}isModuleInScope(v){return this._modulesMap.has(v)}registerExport(v,I){if(!this._currentModule.exportMap){this._currentModule.exportMap=new Map}if(!this._currentModule.exportMap.has(v)){this._currentModule.exportMap.set(v,I)}}registerRawExport(v,I){if(!this._currentModule.rawExportMap){this._currentModule.rawExportMap=new Map}if(!this._currentModule.rawExportMap.has(v)){this._currentModule.rawExportMap.set(v,I)}}registerNamespaceExport(v){this._currentModule.namespaceExportSymbol=v}createModuleReference(v,{ids:I=undefined,call:P=false,directImport:R=false,asiSafe:$=false}){const L=this._modulesMap.get(v);const q=P?"_call":"";const K=R?"_directImport":"";const ae=$?"_asiSafe1":$===false?"_asiSafe0":"";const ge=I?Buffer.from(JSON.stringify(I),"utf-8").toString("hex"):"ns";return`__WEBPACK_MODULE_REFERENCE__${L.index}_${ge}${q}${K}${ae}__._`}static isModuleReference(v){return L.test(v)}static matchModuleReference(v){const I=L.exec(v);if(!I)return null;const P=Number(I[1]);const R=I[5];return{index:P,ids:I[2]==="ns"?[]:JSON.parse(Buffer.from(I[2],"hex").toString("utf-8")),call:Boolean(I[3]),directImport:Boolean(I[4]),asiSafe:R?R==="1":undefined}}}ConcatenationScope.DEFAULT_EXPORT=R;ConcatenationScope.NAMESPACE_OBJECT_EXPORT=$;v.exports=ConcatenationScope},57753:function(v,I,P){"use strict";const R=P(94252);v.exports=class ConcurrentCompilationError extends R{constructor(){super();this.name="ConcurrentCompilationError";this.message="You ran Webpack twice. Each instance only supports a single concurrent compilation at a time."}}},73129:function(v,I,P){"use strict";const{ConcatSource:R,PrefixSource:$}=P(51255);const L=P(89959);const q=P(57227);const{mergeRuntime:K}=P(86620);const wrapInCondition=(v,I)=>{if(typeof I==="string"){return q.asString([`if (${v}) {`,q.indent(I),"}",""])}return new R(`if (${v}) {\n`,new $("\t",I),"}\n")};class ConditionalInitFragment extends L{constructor(v,I,P,R,$=true,L=undefined){super(v,I,P,R,L);this.runtimeCondition=$}getContent(v){if(this.runtimeCondition===false||!this.content)return"";if(this.runtimeCondition===true)return this.content;const I=v.runtimeTemplate.runtimeConditionExpression({chunkGraph:v.chunkGraph,runtimeRequirements:v.runtimeRequirements,runtime:v.runtime,runtimeCondition:this.runtimeCondition});if(I==="true")return this.content;return wrapInCondition(I,this.content)}getEndContent(v){if(this.runtimeCondition===false||!this.endContent)return"";if(this.runtimeCondition===true)return this.endContent;const I=v.runtimeTemplate.runtimeConditionExpression({chunkGraph:v.chunkGraph,runtimeRequirements:v.runtimeRequirements,runtime:v.runtime,runtimeCondition:this.runtimeCondition});if(I==="true")return this.endContent;return wrapInCondition(I,this.endContent)}merge(v){if(this.runtimeCondition===true)return this;if(v.runtimeCondition===true)return v;if(this.runtimeCondition===false)return v;if(v.runtimeCondition===false)return this;const I=K(this.runtimeCondition,v.runtimeCondition);return new ConditionalInitFragment(this.content,this.stage,this.position,this.key,I,this.endContent)}}v.exports=ConditionalInitFragment},26086:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$,JAVASCRIPT_MODULE_TYPE_ESM:L}=P(6041);const q=P(45871);const K=P(34022);const{evaluateToString:ae}=P(59932);const{parseResource:ge}=P(46579);const collectDeclaration=(v,I)=>{const P=[I];while(P.length>0){const I=P.pop();switch(I.type){case"Identifier":v.add(I.name);break;case"ArrayPattern":for(const v of I.elements){if(v){P.push(v)}}break;case"AssignmentPattern":P.push(I.left);break;case"ObjectPattern":for(const v of I.properties){P.push(v.value)}break;case"RestElement":P.push(I.argument);break}}};const getHoistedDeclarations=(v,I)=>{const P=new Set;const R=[v];while(R.length>0){const v=R.pop();if(!v)continue;switch(v.type){case"BlockStatement":for(const I of v.body){R.push(I)}break;case"IfStatement":R.push(v.consequent);R.push(v.alternate);break;case"ForStatement":R.push(v.init);R.push(v.body);break;case"ForInStatement":case"ForOfStatement":R.push(v.left);R.push(v.body);break;case"DoWhileStatement":case"WhileStatement":case"LabeledStatement":R.push(v.body);break;case"SwitchStatement":for(const I of v.cases){for(const v of I.consequent){R.push(v)}}break;case"TryStatement":R.push(v.block);if(v.handler){R.push(v.handler.body)}R.push(v.finalizer);break;case"FunctionDeclaration":if(I){collectDeclaration(P,v.id)}break;case"VariableDeclaration":if(v.kind==="var"){for(const I of v.declarations){collectDeclaration(P,I.id)}}break}}return Array.from(P)};const be="ConstPlugin";class ConstPlugin{apply(v){const I=ge.bindCache(v.root);v.hooks.compilation.tap(be,((v,{normalModuleFactory:P})=>{v.dependencyTemplates.set(K,new K.Template);v.dependencyTemplates.set(q,new q.Template);const handler=v=>{v.hooks.statementIf.tap(be,(I=>{if(v.scope.isAsmJs)return;const P=v.evaluateExpression(I.test);const R=P.asBool();if(typeof R==="boolean"){if(!P.couldHaveSideEffects()){const $=new K(`${R}`,P.range);$.loc=I.loc;v.state.module.addPresentationalDependency($)}else{v.walkExpression(I.test)}const $=R?I.alternate:I.consequent;if($){const I=v.scope.isStrict?getHoistedDeclarations($,false):getHoistedDeclarations($,true);const P=I.length>0?`{ var ${I.join(", ")}; }`:"{}";const R=new K(P,$.range);R.loc=$.loc;v.state.module.addPresentationalDependency(R)}return R}}));v.hooks.expressionConditionalOperator.tap(be,(I=>{if(v.scope.isAsmJs)return;const P=v.evaluateExpression(I.test);const R=P.asBool();if(typeof R==="boolean"){if(!P.couldHaveSideEffects()){const $=new K(` ${R}`,P.range);$.loc=I.loc;v.state.module.addPresentationalDependency($)}else{v.walkExpression(I.test)}const $=R?I.alternate:I.consequent;const L=new K("0",$.range);L.loc=$.loc;v.state.module.addPresentationalDependency(L);return R}}));v.hooks.expressionLogicalOperator.tap(be,(I=>{if(v.scope.isAsmJs)return;if(I.operator==="&&"||I.operator==="||"){const P=v.evaluateExpression(I.left);const R=P.asBool();if(typeof R==="boolean"){const $=I.operator==="&&"&&R||I.operator==="||"&&!R;if(!P.couldHaveSideEffects()&&(P.isBoolean()||$)){const $=new K(` ${R}`,P.range);$.loc=I.loc;v.state.module.addPresentationalDependency($)}else{v.walkExpression(I.left)}if(!$){const P=new K("0",I.right.range);P.loc=I.loc;v.state.module.addPresentationalDependency(P)}return $}}else if(I.operator==="??"){const P=v.evaluateExpression(I.left);const R=P.asNullish();if(typeof R==="boolean"){if(!P.couldHaveSideEffects()&&R){const R=new K(" null",P.range);R.loc=I.loc;v.state.module.addPresentationalDependency(R)}else{const P=new K("0",I.right.range);P.loc=I.loc;v.state.module.addPresentationalDependency(P);v.walkExpression(I.left)}return R}}}));v.hooks.optionalChaining.tap(be,(I=>{const P=[];let R=I.expression;while(R.type==="MemberExpression"||R.type==="CallExpression"){if(R.type==="MemberExpression"){if(R.optional){P.push(R.object)}R=R.object}else{if(R.optional){P.push(R.callee)}R=R.callee}}while(P.length){const R=P.pop();const $=v.evaluateExpression(R);if($.asNullish()){const P=new K(" undefined",I.range);P.loc=I.loc;v.state.module.addPresentationalDependency(P);return true}}}));v.hooks.evaluateIdentifier.for("__resourceQuery").tap(be,(P=>{if(v.scope.isAsmJs)return;if(!v.state.module)return;return ae(I(v.state.module.resource).query)(P)}));v.hooks.expression.for("__resourceQuery").tap(be,(P=>{if(v.scope.isAsmJs)return;if(!v.state.module)return;const R=new q(JSON.stringify(I(v.state.module.resource).query),P.range,"__resourceQuery");R.loc=P.loc;v.state.module.addPresentationalDependency(R);return true}));v.hooks.evaluateIdentifier.for("__resourceFragment").tap(be,(P=>{if(v.scope.isAsmJs)return;if(!v.state.module)return;return ae(I(v.state.module.resource).fragment)(P)}));v.hooks.expression.for("__resourceFragment").tap(be,(P=>{if(v.scope.isAsmJs)return;if(!v.state.module)return;const R=new q(JSON.stringify(I(v.state.module.resource).fragment),P.range,"__resourceFragment");R.loc=P.loc;v.state.module.addPresentationalDependency(R);return true}))};P.hooks.parser.for(R).tap(be,handler);P.hooks.parser.for($).tap(be,handler);P.hooks.parser.for(L).tap(be,handler)}))}}v.exports=ConstPlugin},35105:function(v){"use strict";class ContextExclusionPlugin{constructor(v){this.negativeMatcher=v}apply(v){v.hooks.contextModuleFactory.tap("ContextExclusionPlugin",(v=>{v.hooks.contextModuleFiles.tap("ContextExclusionPlugin",(v=>v.filter((v=>!this.negativeMatcher.test(v)))))}))}}v.exports=ContextExclusionPlugin},12896:function(v,I,P){"use strict";const{OriginalSource:R,RawSource:$}=P(51255);const L=P(67927);const{makeWebpackError:q}=P(73404);const K=P(34803);const{JS_TYPES:ae}=P(30021);const{JAVASCRIPT_MODULE_TYPE_DYNAMIC:ge}=P(6041);const be=P(5205);const xe=P(57227);const ve=P(94252);const{compareLocations:Ce,concatComparators:Ne,compareSelect:He,keepOriginalOrder:Qe,compareModulesById:Je}=P(21398);const{contextify:Ve,parseResource:Ke,makePathsRelative:Ye}=P(46579);const Xe=P(65317);const Ze={timestamp:true};class ContextModule extends K{constructor(v,I){if(!I||typeof I.resource==="string"){const v=Ke(I?I.resource:"");const P=v.path;const R=I&&I.resourceQuery||v.query;const $=I&&I.resourceFragment||v.fragment;const L=I&&I.layer;super(ge,P,L);this.options={...I,resource:P,resourceQuery:R,resourceFragment:$}}else{super(ge,undefined,I.layer);this.options={...I,resource:I.resource,resourceQuery:I.resourceQuery||"",resourceFragment:I.resourceFragment||""}}this.resolveDependencies=v;if(I&&I.resolveOptions!==undefined){this.resolveOptions=I.resolveOptions}if(I&&typeof I.mode!=="string"){throw new Error("options.mode is a required option")}this._identifier=this._createIdentifier();this._forceBuild=true}getSourceTypes(){return ae}updateCacheModule(v){const I=v;this.resolveDependencies=I.resolveDependencies;this.options=I.options}cleanupForCache(){super.cleanupForCache();this.resolveDependencies=undefined}_prettyRegExp(v,I=true){const P=I?v.source+v.flags:`${v}`;return P.replace(/!/g,"%21").replace(/\|/g,"%7C")}_createIdentifier(){let v=this.context||(typeof this.options.resource==="string"||this.options.resource===false?`${this.options.resource}`:this.options.resource.join("|"));if(this.options.resourceQuery){v+=`|${this.options.resourceQuery}`}if(this.options.resourceFragment){v+=`|${this.options.resourceFragment}`}if(this.options.mode){v+=`|${this.options.mode}`}if(!this.options.recursive){v+="|nonrecursive"}if(this.options.addon){v+=`|${this.options.addon}`}if(this.options.regExp){v+=`|${this._prettyRegExp(this.options.regExp,false)}`}if(this.options.include){v+=`|include: ${this._prettyRegExp(this.options.include,false)}`}if(this.options.exclude){v+=`|exclude: ${this._prettyRegExp(this.options.exclude,false)}`}if(this.options.referencedExports){v+=`|referencedExports: ${JSON.stringify(this.options.referencedExports)}`}if(this.options.chunkName){v+=`|chunkName: ${this.options.chunkName}`}if(this.options.groupOptions){v+=`|groupOptions: ${JSON.stringify(this.options.groupOptions)}`}if(this.options.namespaceObject==="strict"){v+="|strict namespace object"}else if(this.options.namespaceObject){v+="|namespace object"}if(this.layer){v+=`|layer: ${this.layer}`}return v}identifier(){return this._identifier}readableIdentifier(v){let I;if(this.context){I=`${v.shorten(this.context)}/`}else if(typeof this.options.resource==="string"||this.options.resource===false){I=`${v.shorten(`${this.options.resource}`)}/`}else{I=this.options.resource.map((I=>`${v.shorten(I)}/`)).join(" ")}if(this.options.resourceQuery){I+=` ${this.options.resourceQuery}`}if(this.options.mode){I+=` ${this.options.mode}`}if(!this.options.recursive){I+=" nonrecursive"}if(this.options.addon){I+=` ${v.shorten(this.options.addon)}`}if(this.options.regExp){I+=` ${this._prettyRegExp(this.options.regExp)}`}if(this.options.include){I+=` include: ${this._prettyRegExp(this.options.include)}`}if(this.options.exclude){I+=` exclude: ${this._prettyRegExp(this.options.exclude)}`}if(this.options.referencedExports){I+=` referencedExports: ${this.options.referencedExports.map((v=>v.join("."))).join(", ")}`}if(this.options.chunkName){I+=` chunkName: ${this.options.chunkName}`}if(this.options.groupOptions){const v=this.options.groupOptions;for(const P of Object.keys(v)){I+=` ${P}: ${v[P]}`}}if(this.options.namespaceObject==="strict"){I+=" strict namespace object"}else if(this.options.namespaceObject){I+=" namespace object"}return I}libIdent(v){let I;if(this.context){I=Ve(v.context,this.context,v.associatedObjectForCache)}else if(typeof this.options.resource==="string"){I=Ve(v.context,this.options.resource,v.associatedObjectForCache)}else if(this.options.resource===false){I="false"}else{I=this.options.resource.map((I=>Ve(v.context,I,v.associatedObjectForCache))).join(" ")}if(this.layer)I=`(${this.layer})/${I}`;if(this.options.mode){I+=` ${this.options.mode}`}if(this.options.recursive){I+=" recursive"}if(this.options.addon){I+=` ${Ve(v.context,this.options.addon,v.associatedObjectForCache)}`}if(this.options.regExp){I+=` ${this._prettyRegExp(this.options.regExp)}`}if(this.options.include){I+=` include: ${this._prettyRegExp(this.options.include)}`}if(this.options.exclude){I+=` exclude: ${this._prettyRegExp(this.options.exclude)}`}if(this.options.referencedExports){I+=` referencedExports: ${this.options.referencedExports.map((v=>v.join("."))).join(", ")}`}return I}invalidateBuild(){this._forceBuild=true}needBuild({fileSystemInfo:v},I){if(this._forceBuild)return I(null,true);const P=this.buildInfo;if(!P.snapshot)return I(null,Boolean(this.context||this.options.resource));v.checkSnapshotValid(P.snapshot,((v,P)=>{I(v,!P)}))}build(v,I,P,R,$){this._forceBuild=false;this.buildMeta={exportsType:"default",defaultObject:"redirect-warn"};this.buildInfo={snapshot:undefined};this.dependencies.length=0;this.blocks.length=0;const K=Date.now();this.resolveDependencies(R,this.options,((v,P)=>{if(v){return $(q(v,"ContextModule.resolveDependencies"))}if(!P){$();return}for(const v of P){v.loc={name:v.userRequest};v.request=this.options.addon+v.request}P.sort(Ne(He((v=>v.loc),Ce),Qe(this.dependencies)));if(this.options.mode==="sync"||this.options.mode==="eager"){this.dependencies=P}else if(this.options.mode==="lazy-once"){if(P.length>0){const v=new L({...this.options.groupOptions,name:this.options.chunkName});for(const I of P){v.addDependency(I)}this.addBlock(v)}}else if(this.options.mode==="weak"||this.options.mode==="async-weak"){for(const v of P){v.weak=true}this.dependencies=P}else if(this.options.mode==="lazy"){let v=0;for(const I of P){let P=this.options.chunkName;if(P){if(!/\[(index|request)\]/.test(P)){P+="[index]"}P=P.replace(/\[index\]/g,`${v++}`);P=P.replace(/\[request\]/g,xe.toPath(I.userRequest))}const R=new L({...this.options.groupOptions,name:P},I.loc,I.userRequest);R.addDependency(I);this.addBlock(R)}}else{$(new ve(`Unsupported mode "${this.options.mode}" in context`));return}if(!this.context&&!this.options.resource)return $();I.fileSystemInfo.createSnapshot(K,null,this.context?[this.context]:typeof this.options.resource==="string"?[this.options.resource]:this.options.resource,null,Ze,((v,I)=>{if(v)return $(v);this.buildInfo.snapshot=I;$()}))}))}addCacheDependencies(v,I,P,R){if(this.context){I.add(this.context)}else if(typeof this.options.resource==="string"){I.add(this.options.resource)}else if(this.options.resource===false){}else{for(const v of this.options.resource)I.add(v)}}getUserRequestMap(v,I){const P=I.moduleGraph;const R=v.filter((v=>P.getModule(v))).sort(((v,I)=>{if(v.userRequest===I.userRequest){return 0}return v.userRequest<I.userRequest?-1:1}));const $=Object.create(null);for(const v of R){const R=P.getModule(v);$[v.userRequest]=I.getModuleId(R)}return $}getFakeMap(v,I){if(!this.options.namespaceObject){return 9}const P=I.moduleGraph;let R=0;const $=Je(I);const L=v.map((v=>P.getModule(v))).filter(Boolean).sort($);const q=Object.create(null);for(const v of L){const $=v.getExportsType(P,this.options.namespaceObject==="strict");const L=I.getModuleId(v);switch($){case"namespace":q[L]=9;R|=1;break;case"dynamic":q[L]=7;R|=2;break;case"default-only":q[L]=1;R|=4;break;case"default-with-named":q[L]=3;R|=8;break;default:throw new Error(`Unexpected exports type ${$}`)}}if(R===1){return 9}if(R===2){return 7}if(R===4){return 1}if(R===8){return 3}if(R===0){return 9}return q}getFakeMapInitStatement(v){return typeof v==="object"?`var fakeMap = ${JSON.stringify(v,null,"\t")};`:""}getReturn(v,I){if(v===9){return`${be.require}(id)`}return`${be.createFakeNamespaceObject}(id, ${v}${I?" | 16":""})`}getReturnModuleObjectSource(v,I,P="fakeMap[id]"){if(typeof v==="number"){return`return ${this.getReturn(v,I)};`}return`return ${be.createFakeNamespaceObject}(id, ${P}${I?" | 16":""})`}getSyncSource(v,I,P){const R=this.getUserRequestMap(v,P);const $=this.getFakeMap(v,P);const L=this.getReturnModuleObjectSource($);return`var map = ${JSON.stringify(R,null,"\t")};\n${this.getFakeMapInitStatement($)}\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\t${L}\n}\nfunction webpackContextResolve(req) {\n\tif(!${be.hasOwnProperty}(map, req)) {\n\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = ${JSON.stringify(I)};`}getWeakSyncSource(v,I,P){const R=this.getUserRequestMap(v,P);const $=this.getFakeMap(v,P);const L=this.getReturnModuleObjectSource($);return`var map = ${JSON.stringify(R,null,"\t")};\n${this.getFakeMapInitStatement($)}\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\tif(!${be.moduleFactories}[id]) {\n\t\tvar e = new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\t${L}\n}\nfunction webpackContextResolve(req) {\n\tif(!${be.hasOwnProperty}(map, req)) {\n\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nwebpackContext.id = ${JSON.stringify(I)};\nmodule.exports = webpackContext;`}getAsyncWeakSource(v,I,{chunkGraph:P,runtimeTemplate:R}){const $=R.supportsArrowFunction();const L=this.getUserRequestMap(v,P);const q=this.getFakeMap(v,P);const K=this.getReturnModuleObjectSource(q,true);return`var map = ${JSON.stringify(L,null,"\t")};\n${this.getFakeMapInitStatement(q)}\n\nfunction webpackAsyncContext(req) {\n\treturn webpackAsyncContextResolve(req).then(${$?"id =>":"function(id)"} {\n\t\tif(!${be.moduleFactories}[id]) {\n\t\t\tvar e = new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\t\t${K}\n\t});\n}\nfunction webpackAsyncContextResolve(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(${$?"() =>":"function()"} {\n\t\tif(!${be.hasOwnProperty}(map, req)) {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\t\treturn map[req];\n\t});\n}\nwebpackAsyncContext.keys = ${R.returningFunction("Object.keys(map)")};\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\nwebpackAsyncContext.id = ${JSON.stringify(I)};\nmodule.exports = webpackAsyncContext;`}getEagerSource(v,I,{chunkGraph:P,runtimeTemplate:R}){const $=R.supportsArrowFunction();const L=this.getUserRequestMap(v,P);const q=this.getFakeMap(v,P);const K=q!==9?`${$?"id =>":"function(id)"} {\n\t\t${this.getReturnModuleObjectSource(q,true)}\n\t}`:be.require;return`var map = ${JSON.stringify(L,null,"\t")};\n${this.getFakeMapInitStatement(q)}\n\nfunction webpackAsyncContext(req) {\n\treturn webpackAsyncContextResolve(req).then(${K});\n}\nfunction webpackAsyncContextResolve(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(${$?"() =>":"function()"} {\n\t\tif(!${be.hasOwnProperty}(map, req)) {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\t\treturn map[req];\n\t});\n}\nwebpackAsyncContext.keys = ${R.returningFunction("Object.keys(map)")};\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\nwebpackAsyncContext.id = ${JSON.stringify(I)};\nmodule.exports = webpackAsyncContext;`}getLazyOnceSource(v,I,P,{runtimeTemplate:R,chunkGraph:$}){const L=R.blockPromise({chunkGraph:$,block:v,message:"lazy-once context",runtimeRequirements:new Set});const q=R.supportsArrowFunction();const K=this.getUserRequestMap(I,$);const ae=this.getFakeMap(I,$);const ge=ae!==9?`${q?"id =>":"function(id)"} {\n\t\t${this.getReturnModuleObjectSource(ae,true)};\n\t}`:be.require;return`var map = ${JSON.stringify(K,null,"\t")};\n${this.getFakeMapInitStatement(ae)}\n\nfunction webpackAsyncContext(req) {\n\treturn webpackAsyncContextResolve(req).then(${ge});\n}\nfunction webpackAsyncContextResolve(req) {\n\treturn ${L}.then(${q?"() =>":"function()"} {\n\t\tif(!${be.hasOwnProperty}(map, req)) {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\t\treturn map[req];\n\t});\n}\nwebpackAsyncContext.keys = ${R.returningFunction("Object.keys(map)")};\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\nwebpackAsyncContext.id = ${JSON.stringify(P)};\nmodule.exports = webpackAsyncContext;`}getLazySource(v,I,{chunkGraph:P,runtimeTemplate:R}){const $=P.moduleGraph;const L=R.supportsArrowFunction();let q=false;let K=true;const ae=this.getFakeMap(v.map((v=>v.dependencies[0])),P);const ge=typeof ae==="object";const xe=v.map((v=>{const I=v.dependencies[0];return{dependency:I,module:$.getModule(I),block:v,userRequest:I.userRequest,chunks:undefined}})).filter((v=>v.module));for(const v of xe){const I=P.getBlockChunkGroup(v.block);const R=I&&I.chunks||[];v.chunks=R;if(R.length>0){K=false}if(R.length!==1){q=true}}const ve=K&&!ge;const Ce=xe.sort(((v,I)=>{if(v.userRequest===I.userRequest)return 0;return v.userRequest<I.userRequest?-1:1}));const Ne=Object.create(null);for(const v of Ce){const I=P.getModuleId(v.module);if(ve){Ne[v.userRequest]=I}else{const P=[I];if(ge){P.push(ae[I])}Ne[v.userRequest]=P.concat(v.chunks.map((v=>v.id)))}}const He=ge?2:1;const Qe=K?"Promise.resolve()":q?`Promise.all(ids.slice(${He}).map(${be.ensureChunk}))`:`${be.ensureChunk}(ids[${He}])`;const Je=this.getReturnModuleObjectSource(ae,true,ve?"invalid":"ids[1]");const Ve=Qe==="Promise.resolve()"?`\nfunction webpackAsyncContext(req) {\n\treturn Promise.resolve().then(${L?"() =>":"function()"} {\n\t\tif(!${be.hasOwnProperty}(map, req)) {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\n\t\t${ve?"var id = map[req];":"var ids = map[req], id = ids[0];"}\n\t\t${Je}\n\t});\n}`:`function webpackAsyncContext(req) {\n\tif(!${be.hasOwnProperty}(map, req)) {\n\t\treturn Promise.resolve().then(${L?"() =>":"function()"} {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn ${Qe}.then(${L?"() =>":"function()"} {\n\t\t${Je}\n\t});\n}`;return`var map = ${JSON.stringify(Ne,null,"\t")};\n${Ve}\nwebpackAsyncContext.keys = ${R.returningFunction("Object.keys(map)")};\nwebpackAsyncContext.id = ${JSON.stringify(I)};\nmodule.exports = webpackAsyncContext;`}getSourceForEmptyContext(v,I){return`function webpackEmptyContext(req) {\n\tvar e = new Error("Cannot find module '" + req + "'");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = ${I.returningFunction("[]")};\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = ${JSON.stringify(v)};\nmodule.exports = webpackEmptyContext;`}getSourceForEmptyAsyncContext(v,I){const P=I.supportsArrowFunction();return`function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(${P?"() =>":"function()"} {\n\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = ${I.returningFunction("[]")};\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = ${JSON.stringify(v)};\nmodule.exports = webpackEmptyAsyncContext;`}getSourceString(v,{runtimeTemplate:I,chunkGraph:P}){const R=P.getModuleId(this);if(v==="lazy"){if(this.blocks&&this.blocks.length>0){return this.getLazySource(this.blocks,R,{runtimeTemplate:I,chunkGraph:P})}return this.getSourceForEmptyAsyncContext(R,I)}if(v==="eager"){if(this.dependencies&&this.dependencies.length>0){return this.getEagerSource(this.dependencies,R,{chunkGraph:P,runtimeTemplate:I})}return this.getSourceForEmptyAsyncContext(R,I)}if(v==="lazy-once"){const v=this.blocks[0];if(v){return this.getLazyOnceSource(v,v.dependencies,R,{runtimeTemplate:I,chunkGraph:P})}return this.getSourceForEmptyAsyncContext(R,I)}if(v==="async-weak"){if(this.dependencies&&this.dependencies.length>0){return this.getAsyncWeakSource(this.dependencies,R,{chunkGraph:P,runtimeTemplate:I})}return this.getSourceForEmptyAsyncContext(R,I)}if(v==="weak"&&this.dependencies&&this.dependencies.length>0){return this.getWeakSyncSource(this.dependencies,R,P)}if(this.dependencies&&this.dependencies.length>0){return this.getSyncSource(this.dependencies,R,P)}return this.getSourceForEmptyContext(R,I)}getSource(v,I){if(this.useSourceMap||this.useSimpleSourceMap){return new R(v,`webpack://${Ye(I&&I.compiler.context||"",this.identifier(),I&&I.compiler.root)}`)}return new $(v)}codeGeneration(v){const{chunkGraph:I,compilation:P}=v;const R=new Map;R.set("javascript",this.getSource(this.getSourceString(this.options.mode,v),P));const $=new Set;const L=this.dependencies.length>0?this.dependencies.slice():[];for(const v of this.blocks)for(const I of v.dependencies)L.push(I);$.add(be.module);$.add(be.hasOwnProperty);if(L.length>0){const v=this.options.mode;$.add(be.require);if(v==="weak"){$.add(be.moduleFactories)}else if(v==="async-weak"){$.add(be.moduleFactories);$.add(be.ensureChunk)}else if(v==="lazy"||v==="lazy-once"){$.add(be.ensureChunk)}if(this.getFakeMap(L,I)!==9){$.add(be.createFakeNamespaceObject)}}return{sources:R,runtimeRequirements:$}}size(v){let I=160;for(const v of this.dependencies){const P=v;I+=5+P.userRequest.length}return I}serialize(v){const{write:I}=v;I(this._identifier);I(this._forceBuild);super.serialize(v)}deserialize(v){const{read:I}=v;this._identifier=I();this._forceBuild=I();super.deserialize(v)}}Xe(ContextModule,"webpack/lib/ContextModule");v.exports=ContextModule},9346:function(v,I,P){"use strict";const R=P(78175);const{AsyncSeriesWaterfallHook:$,SyncWaterfallHook:L}=P(84891);const q=P(12896);const K=P(8412);const ae=P(10573);const ge=P(11584);const{cachedSetProperty:be}=P(22298);const{createFakeHook:xe}=P(10416);const{join:ve}=P(80749);const Ce={};v.exports=class ContextModuleFactory extends K{constructor(v){super();const I=new $(["modules","options"]);this.hooks=Object.freeze({beforeResolve:new $(["data"]),afterResolve:new $(["data"]),contextModuleFiles:new L(["files"]),alternatives:xe({name:"alternatives",intercept:v=>{throw new Error("Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead")},tap:(v,P)=>{I.tap(v,P)},tapAsync:(v,P)=>{I.tapAsync(v,((v,I,R)=>P(v,R)))},tapPromise:(v,P)=>{I.tapPromise(v,P)}},"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.","DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES"),alternativeRequests:I});this.resolverFactory=v}create(v,I){const P=v.context;const $=v.dependencies;const L=v.resolveOptions;const K=$[0];const ae=new ge;const xe=new ge;const ve=new ge;this.hooks.beforeResolve.callAsync({context:P,dependencies:$,layer:v.contextInfo.issuerLayer,resolveOptions:L,fileDependencies:ae,missingDependencies:xe,contextDependencies:ve,...K.options},((v,P)=>{if(v){return I(v,{fileDependencies:ae,missingDependencies:xe,contextDependencies:ve})}if(!P){return I(null,{fileDependencies:ae,missingDependencies:xe,contextDependencies:ve})}const L=P.context;const K=P.request;const ge=P.resolveOptions;let Ne;let He;let Qe="";const Je=K.lastIndexOf("!");if(Je>=0){let v=K.slice(0,Je+1);let I;for(I=0;I<v.length&&v[I]==="!";I++){Qe+="!"}v=v.slice(I).replace(/!+$/,"").replace(/!!+/g,"!");Ne=v===""?[]:v.split("!");He=K.slice(Je+1)}else{Ne=[];He=K}const Ve=this.resolverFactory.get("context",$.length>0?be(ge||Ce,"dependencyType",$[0].category):ge);const Ke=this.resolverFactory.get("loader");R.parallel([v=>{const I=[];const yield_=v=>{I.push(v)};Ve.resolve({},L,He,{fileDependencies:ae,missingDependencies:xe,contextDependencies:ve,yield:yield_},(P=>{if(P)return v(P);v(null,I)}))},v=>{R.map(Ne,((v,I)=>{Ke.resolve({},L,v,{fileDependencies:ae,missingDependencies:xe,contextDependencies:ve},((v,P)=>{if(v)return I(v);I(null,P)}))}),v)}],((v,R)=>{if(v){return I(v,{fileDependencies:ae,missingDependencies:xe,contextDependencies:ve})}let[$,L]=R;if($.length>1){const v=$[0];$=$.filter((v=>v.path));if($.length===0)$.push(v)}this.hooks.afterResolve.callAsync({addon:Qe+L.join("!")+(L.length>0?"!":""),resource:$.length>1?$.map((v=>v.path)):$[0].path,resolveDependencies:this.resolveDependencies.bind(this),resourceQuery:$[0].query,resourceFragment:$[0].fragment,...P},((v,P)=>{if(v){return I(v,{fileDependencies:ae,missingDependencies:xe,contextDependencies:ve})}if(!P){return I(null,{fileDependencies:ae,missingDependencies:xe,contextDependencies:ve})}return I(null,{module:new q(P.resolveDependencies,P),fileDependencies:ae,missingDependencies:xe,contextDependencies:ve})}))}))}))}resolveDependencies(v,I,P){const $=this;const{resource:L,resourceQuery:q,resourceFragment:K,recursive:ge,regExp:be,include:xe,exclude:Ce,referencedExports:Ne,category:He,typePrefix:Qe,attributes:Je}=I;if(!be||!L)return P(null,[]);const addDirectoryChecked=(I,P,R,$)=>{v.realpath(P,((v,L)=>{if(v)return $(v);const q=L;if(R.has(q))return $(null,[]);let K;addDirectory(I,P,((v,P,$)=>{if(K===undefined){K=new Set(R);K.add(q)}addDirectoryChecked(I,P,K,$)}),$)}))};const addDirectory=(P,L,Ve,Ke)=>{v.readdir(L,((Ye,Xe)=>{if(Ye)return Ke(Ye);const Ze=$.hooks.contextModuleFiles.call(Xe.map((v=>v.normalize("NFC"))));if(!Ze||Ze.length===0)return Ke(null,[]);R.map(Ze.filter((v=>v.indexOf(".")!==0)),((R,$)=>{const Ke=ve(v,L,R);if(!Ce||!Ke.match(Ce)){v.stat(Ke,((v,R)=>{if(v){if(v.code==="ENOENT"){return $()}return $(v)}const L=R;if(L.isDirectory()){if(!ge)return $();Ve(P,Ke,$)}else if(L.isFile()&&(!xe||Ke.match(xe))){const v={context:P,request:`.${Ke.slice(P.length).replace(/\\/g,"/")}`};this.hooks.alternativeRequests.callAsync([v],I,((v,I)=>{if(v)return $(v);$(null,I.filter((v=>be.test(v.request))).map((v=>{const I=new ae(`${v.request}${q}${K}`,v.request,Qe,He,Ne,v.context,Je);I.optional=true;return I})))}))}else{$()}}))}else{$()}}),((v,I)=>{if(v)return Ke(v);if(!I)return Ke(null,[]);const P=[];for(const v of I){if(v)P.push(...v)}Ke(null,P)}))}))};const addSubDirectory=(v,I,P)=>addDirectory(v,I,addSubDirectory,P);const visitResource=(I,P)=>{if(typeof v.realpath==="function"){addDirectoryChecked(I,I,new Set,P)}else{addDirectory(I,I,addSubDirectory,P)}};if(typeof L==="string"){visitResource(L,P)}else{R.map(L,visitResource,((v,I)=>{if(v)return P(v);const R=I;const $=new Set;const L=[];for(let v=0;v<R.length;v++){const I=R[v];for(const v of I){if($.has(v.userRequest))continue;L.push(v);$.add(v.userRequest)}}P(null,L)}))}}}},91743:function(v,I,P){"use strict";const R=P(10573);const{join:$}=P(80749);class ContextReplacementPlugin{constructor(v,I,P,R){this.resourceRegExp=v;if(typeof I==="function"){this.newContentCallback=I}else if(typeof I==="string"&&typeof P==="object"){this.newContentResource=I;this.newContentCreateContextMap=(v,I)=>{I(null,P)}}else if(typeof I==="string"&&typeof P==="function"){this.newContentResource=I;this.newContentCreateContextMap=P}else{if(typeof I!=="string"){R=P;P=I;I=undefined}if(typeof P!=="boolean"){R=P;P=undefined}this.newContentResource=I;this.newContentRecursive=P;this.newContentRegExp=R}}apply(v){const I=this.resourceRegExp;const P=this.newContentCallback;const R=this.newContentResource;const L=this.newContentRecursive;const q=this.newContentRegExp;const K=this.newContentCreateContextMap;v.hooks.contextModuleFactory.tap("ContextReplacementPlugin",(ae=>{ae.hooks.beforeResolve.tap("ContextReplacementPlugin",(v=>{if(!v)return;if(I.test(v.request)){if(R!==undefined){v.request=R}if(L!==undefined){v.recursive=L}if(q!==undefined){v.regExp=q}if(typeof P==="function"){P(v)}else{for(const I of v.dependencies){if(I.critical)I.critical=false}}}return v}));ae.hooks.afterResolve.tap("ContextReplacementPlugin",(ae=>{if(!ae)return;if(I.test(ae.resource)){if(R!==undefined){if(R.startsWith("/")||R.length>1&&R[1]===":"){ae.resource=R}else{ae.resource=$(v.inputFileSystem,ae.resource,R)}}if(L!==undefined){ae.recursive=L}if(q!==undefined){ae.regExp=q}if(typeof K==="function"){ae.resolveDependencies=createResolveDependenciesFromContextMap(K)}if(typeof P==="function"){const I=ae.resource;P(ae);if(ae.resource!==I&&!ae.resource.startsWith("/")&&(ae.resource.length<=1||ae.resource[1]!==":")){ae.resource=$(v.inputFileSystem,I,ae.resource)}}else{for(const v of ae.dependencies){if(v.critical)v.critical=false}}}return ae}))}))}}const createResolveDependenciesFromContextMap=v=>{const resolveDependenciesFromContextMap=(I,P,$)=>{v(I,((v,I)=>{if(v)return $(v);const L=Object.keys(I).map((v=>new R(I[v]+P.resourceQuery+P.resourceFragment,v,P.category,P.referencedExports)));$(null,L)}))};return resolveDependenciesFromContextMap};v.exports=ContextReplacementPlugin},8176:function(v,I,P){"use strict";const R=P(32594);const $=P(65317);class CssModule extends R{constructor(v){super(v);this.cssLayer=v.cssLayer;this.supports=v.supports;this.media=v.media;this.inheritance=v.inheritance}identifier(){let v=super.identifier();if(this.cssLayer){v+=`|${this.cssLayer}`}if(this.supports){v+=`|${this.supports}`}if(this.media){v+=`|${this.media}`}if(this.inheritance){const I=this.inheritance.map(((v,I)=>`inheritance_${I}|${v[0]||""}|${v[1]||""}|${v[2]||""}`));v+=`|${I.join("|")}`}if(this.hot){v+=`|${this.hot}`}return v}readableIdentifier(v){const I=super.readableIdentifier(v);let P=`css ${I}`;if(this.cssLayer){P+=` (layer: ${this.cssLayer})`}if(this.supports){P+=` (supports: ${this.supports})`}if(this.media){P+=` (media: ${this.media})`}return P}updateCacheModule(v){super.updateCacheModule(v);const I=v;this.cssLayer=I.cssLayer;this.supports=I.supports;this.media=I.media;this.inheritance=I.inheritance}serialize(v){const{write:I}=v;I(this.cssLayer);I(this.supports);I(this.media);I(this.inheritance);super.serialize(v)}static deserialize(v){const I=new CssModule({layer:null,type:"",resource:"",context:"",request:null,userRequest:null,rawRequest:null,loaders:null,matchResource:null,parser:null,parserOptions:null,generator:null,generatorOptions:null,resolveOptions:null,cssLayer:null,supports:null,media:null,inheritance:null});I.deserialize(v);return I}deserialize(v){const{read:I}=v;this.cssLayer=I();this.supports=I();this.media=I();this.inheritance=I();super.deserialize(v)}}$(CssModule,"webpack/lib/CssModule");v.exports=CssModule},64448:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_ESM:$,JAVASCRIPT_MODULE_TYPE_DYNAMIC:L}=P(6041);const q=P(5205);const K=P(94252);const ae=P(34022);const ge=P(28665);const{VariableInfo:be}=P(31384);const{evaluateToString:xe,toConstantDependency:ve}=P(59932);const Ce=P(12471);class RuntimeValue{constructor(v,I){this.fn=v;if(Array.isArray(I)){I={fileDependencies:I}}this.options=I||{}}get fileDependencies(){return this.options===true?true:this.options.fileDependencies}exec(v,I,P){const R=v.state.module.buildInfo;if(this.options===true){R.cacheable=false}else{if(this.options.fileDependencies){for(const v of this.options.fileDependencies){R.fileDependencies.add(v)}}if(this.options.contextDependencies){for(const v of this.options.contextDependencies){R.contextDependencies.add(v)}}if(this.options.missingDependencies){for(const v of this.options.missingDependencies){R.missingDependencies.add(v)}}if(this.options.buildDependencies){for(const v of this.options.buildDependencies){R.buildDependencies.add(v)}}}return this.fn({module:v.state.module,key:P,get version(){return I.get(He+P)}})}getCacheVersion(){return this.options===true?undefined:(typeof this.options.version==="function"?this.options.version():this.options.version)||"unset"}}function getObjKeys(v){if(!v)return;return new Set([...v].map((v=>v.id)))}const stringifyObj=(v,I,P,R,$,L,q,K)=>{let ae;const ge=Array.isArray(v);if(ge){ae=`[${v.map((v=>toCode(v,I,P,R,$,L,null))).join(",")}]`}else{let R=Object.keys(v);if(K){R=K.size===0?[]:R.filter((v=>K.has(v)))}ae=`{${R.map((R=>{const q=v[R];return`${JSON.stringify(R)}:${toCode(q,I,P,R,$,L,null)}`})).join(",")}}`}switch(q){case null:return ae;case true:return ge?ae:`(${ae})`;case false:return ge?`;${ae}`:`;(${ae})`;default:return`/*#__PURE__*/Object(${ae})`}};const toCode=(v,I,P,R,$,L,q,K)=>{const transformToCode=()=>{if(v===null){return"null"}if(v===undefined){return"undefined"}if(Object.is(v,-0)){return"-0"}if(v instanceof RuntimeValue){return toCode(v.exec(I,P,R),I,P,R,$,L,q)}if(v instanceof RegExp&&v.toString){return v.toString()}if(typeof v==="function"&&v.toString){return`(${v.toString()})`}if(typeof v==="object"){return stringifyObj(v,I,P,R,$,L,q,K)}if(typeof v==="bigint"){return $.supportsBigIntLiteral()?`${v}n`:`BigInt("${v}")`}return`${v}`};const ae=transformToCode();L.debug(`Replaced "${R}" with "${ae}"`);return ae};const toCacheVersion=v=>{if(v===null){return"null"}if(v===undefined){return"undefined"}if(Object.is(v,-0)){return"-0"}if(v instanceof RuntimeValue){return v.getCacheVersion()}if(v instanceof RegExp&&v.toString){return v.toString()}if(typeof v==="function"&&v.toString){return`(${v.toString()})`}if(typeof v==="object"){const I=Object.keys(v).map((I=>({key:I,value:toCacheVersion(v[I])})));if(I.some((({value:v})=>v===undefined)))return;return`{${I.map((({key:v,value:I})=>`${v}: ${I}`)).join(", ")}}`}if(typeof v==="bigint"){return`${v}n`}return`${v}`};const Ne="DefinePlugin";const He=`webpack/${Ne} `;const Qe=`webpack/${Ne}_hash`;const Je=/^typeof\s+/;const Ve=new RegExp(`${q.require}\\s*(!?\\.)`);const Ke=new RegExp(q.require);class DefinePlugin{constructor(v){this.definitions=v}static runtimeValue(v,I){return new RuntimeValue(v,I)}apply(v){const I=this.definitions;v.hooks.compilation.tap(Ne,((v,{normalModuleFactory:P})=>{const Ye=v.getLogger("webpack.DefinePlugin");v.dependencyTemplates.set(ae,new ae.Template);const{runtimeTemplate:Xe}=v;const Ze=Ce(v.outputOptions.hashFunction);Ze.update(v.valueCacheVersions.get(Qe)||"");const handler=P=>{const R=v.valueCacheVersions.get(Qe);P.hooks.program.tap(Ne,(()=>{const v=P.state.module.buildInfo;if(!v.valueDependencies)v.valueDependencies=new Map;v.valueDependencies.set(Qe,R)}));const addValueDependency=I=>{const R=P.state.module.buildInfo;R.valueDependencies.set(He+I,v.valueCacheVersions.get(He+I))};const withValueDependency=(v,I)=>(...P)=>{addValueDependency(v);return I(...P)};const walkDefinitions=(v,I)=>{for(const P of Object.keys(v)){const R=v[P];if(R&&typeof R==="object"&&!(R instanceof RuntimeValue)&&!(R instanceof RegExp)){walkDefinitions(R,`${I+P}.`);applyObjectDefine(I+P,R);continue}applyDefineKey(I,P);applyDefine(I+P,R)}};const applyDefineKey=(v,I)=>{const R=I.split(".");const $=R[0];for(const[L,q]of R.slice(1).entries()){const q=v+R.slice(0,L+1).join(".");P.hooks.canRename.for(q).tap(Ne,(()=>{addValueDependency(I);if(P.scope.definitions.get($)instanceof be){return false}return true}))}};const applyDefine=(I,R)=>{const $=I;const L=Je.test(I);if(L)I=I.replace(Je,"");let K=false;let ae=false;if(!L){P.hooks.canRename.for(I).tap(Ne,(()=>{addValueDependency($);return true}));P.hooks.evaluateIdentifier.for(I).tap(Ne,(L=>{if(K)return;addValueDependency($);K=true;const q=P.evaluate(toCode(R,P,v.valueCacheVersions,I,Xe,Ye,null));K=false;q.setRange(L.range);return q}));P.hooks.expression.for(I).tap(Ne,(I=>{addValueDependency($);let L=toCode(R,P,v.valueCacheVersions,$,Xe,Ye,!P.isAsiPosition(I.range[0]),null);if(P.scope.inShorthand){L=`${P.scope.inShorthand}:${L}`}if(Ve.test(L)){return ve(P,L,[q.require])(I)}else if(Ke.test(L)){return ve(P,L,[q.requireScope])(I)}return ve(P,L)(I)}))}P.hooks.evaluateTypeof.for(I).tap(Ne,(I=>{if(ae)return;ae=true;addValueDependency($);const q=toCode(R,P,v.valueCacheVersions,$,Xe,Ye,null);const K=L?q:`typeof (${q})`;const ge=P.evaluate(K);ae=false;ge.setRange(I.range);return ge}));P.hooks.typeof.for(I).tap(Ne,(I=>{addValueDependency($);const q=toCode(R,P,v.valueCacheVersions,$,Xe,Ye,null);const K=L?q:`typeof (${q})`;const ae=P.evaluate(K);if(!ae.isString())return;return ve(P,JSON.stringify(ae.string)).bind(P)(I)}))};const applyObjectDefine=(I,R)=>{P.hooks.canRename.for(I).tap(Ne,(()=>{addValueDependency(I);return true}));P.hooks.evaluateIdentifier.for(I).tap(Ne,(v=>{addValueDependency(I);return(new ge).setTruthy().setSideEffects(false).setRange(v.range)}));P.hooks.evaluateTypeof.for(I).tap(Ne,withValueDependency(I,xe("object")));P.hooks.expression.for(I).tap(Ne,($=>{addValueDependency(I);let L=stringifyObj(R,P,v.valueCacheVersions,I,Xe,Ye,!P.isAsiPosition($.range[0]),getObjKeys(P.destructuringAssignmentPropertiesFor($)));if(P.scope.inShorthand){L=`${P.scope.inShorthand}:${L}`}if(Ve.test(L)){return ve(P,L,[q.require])($)}else if(Ke.test(L)){return ve(P,L,[q.requireScope])($)}return ve(P,L)($)}));P.hooks.typeof.for(I).tap(Ne,withValueDependency(I,ve(P,JSON.stringify("object"))))};walkDefinitions(I,"")};P.hooks.parser.for(R).tap(Ne,handler);P.hooks.parser.for(L).tap(Ne,handler);P.hooks.parser.for($).tap(Ne,handler);const walkDefinitionsForValues=(I,P)=>{for(const R of Object.keys(I)){const $=I[R];const L=toCacheVersion($);const q=He+P+R;Ze.update(`|${P}${R}`);const ae=v.valueCacheVersions.get(q);if(ae===undefined){v.valueCacheVersions.set(q,L)}else if(ae!==L){const I=new K(`${Ne}\nConflicting values for '${P+R}'`);I.details=`'${ae}' !== '${L}'`;I.hideStack=true;v.warnings.push(I)}if($&&typeof $==="object"&&!($ instanceof RuntimeValue)&&!($ instanceof RegExp)){walkDefinitionsForValues($,`${P+R}.`)}}};walkDefinitionsForValues(I,"");v.valueCacheVersions.set(Qe,Ze.digest("hex").slice(0,8))}))}}v.exports=DefinePlugin},79775:function(v,I,P){"use strict";const{OriginalSource:R,RawSource:$}=P(51255);const L=P(34803);const{JS_TYPES:q}=P(30021);const{JAVASCRIPT_MODULE_TYPE_DYNAMIC:K}=P(6041);const ae=P(5205);const ge=P(79443);const be=P(92296);const xe=P(65317);const ve=new Set([ae.module,ae.require]);class DelegatedModule extends L{constructor(v,I,P,R,$){super(K,null);this.sourceRequest=v;this.request=I.id;this.delegationType=P;this.userRequest=R;this.originalRequest=$;this.delegateData=I;this.delegatedSourceDependency=undefined}getSourceTypes(){return q}libIdent(v){return typeof this.originalRequest==="string"?this.originalRequest:this.originalRequest.libIdent(v)}identifier(){return`delegated ${JSON.stringify(this.request)} from ${this.sourceRequest}`}readableIdentifier(v){return`delegated ${this.userRequest} from ${this.sourceRequest}`}needBuild(v,I){return I(null,!this.buildMeta)}build(v,I,P,R,$){const L=this.delegateData;this.buildMeta={...L.buildMeta};this.buildInfo={};this.dependencies.length=0;this.delegatedSourceDependency=new ge(this.sourceRequest);this.addDependency(this.delegatedSourceDependency);this.addDependency(new be(L.exports||true,false));$()}codeGeneration({runtimeTemplate:v,moduleGraph:I,chunkGraph:P}){const L=this.dependencies[0];const q=I.getModule(L);let K;if(!q){K=v.throwMissingModuleErrorBlock({request:this.sourceRequest})}else{K=`module.exports = (${v.moduleExports({module:q,chunkGraph:P,request:L.request,runtimeRequirements:new Set})})`;switch(this.delegationType){case"require":K+=`(${JSON.stringify(this.request)})`;break;case"object":K+=`[${JSON.stringify(this.request)}]`;break}K+=";"}const ae=new Map;if(this.useSourceMap||this.useSimpleSourceMap){ae.set("javascript",new R(K,this.identifier()))}else{ae.set("javascript",new $(K))}return{sources:ae,runtimeRequirements:ve}}size(v){return 42}updateHash(v,I){v.update(this.delegationType);v.update(JSON.stringify(this.request));super.updateHash(v,I)}serialize(v){const{write:I}=v;I(this.sourceRequest);I(this.delegateData);I(this.delegationType);I(this.userRequest);I(this.originalRequest);super.serialize(v)}static deserialize(v){const{read:I}=v;const P=new DelegatedModule(I(),I(),I(),I(),I());P.deserialize(v);return P}updateCacheModule(v){super.updateCacheModule(v);const I=v;this.delegationType=I.delegationType;this.userRequest=I.userRequest;this.originalRequest=I.originalRequest;this.delegateData=I.delegateData}cleanupForCache(){super.cleanupForCache();this.delegateData=undefined}}xe(DelegatedModule,"webpack/lib/DelegatedModule");v.exports=DelegatedModule},80763:function(v,I,P){"use strict";const R=P(79775);class DelegatedModuleFactoryPlugin{constructor(v){this.options=v;v.type=v.type||"require";v.extensions=v.extensions||["",".js",".json",".wasm"]}apply(v){const I=this.options.scope;if(I){v.hooks.factorize.tapAsync("DelegatedModuleFactoryPlugin",((v,P)=>{const[$]=v.dependencies;const{request:L}=$;if(L&&L.startsWith(`${I}/`)){const v=`.${L.slice(I.length)}`;let $;if(v in this.options.content){$=this.options.content[v];return P(null,new R(this.options.source,$,this.options.type,v,L))}const q=this.options.extensions;for(let I=0;I<q.length;I++){const K=q[I];const ae=v+K;if(ae in this.options.content){$=this.options.content[ae];return P(null,new R(this.options.source,$,this.options.type,ae,L+K))}}}return P()}))}else{v.hooks.module.tap("DelegatedModuleFactoryPlugin",(v=>{const I=v.libIdent(this.options);if(I&&I in this.options.content){const P=this.options.content[I];return new R(this.options.source,P,this.options.type,I,v)}return v}))}}}v.exports=DelegatedModuleFactoryPlugin},71207:function(v,I,P){"use strict";const R=P(80763);const $=P(79443);class DelegatedPlugin{constructor(v){this.options=v}apply(v){v.hooks.compilation.tap("DelegatedPlugin",((v,{normalModuleFactory:I})=>{v.dependencyFactories.set($,I)}));v.hooks.compile.tap("DelegatedPlugin",(({normalModuleFactory:I})=>{new R({associatedObjectForCache:v.root,...this.options}).apply(I)}))}}v.exports=DelegatedPlugin},98733:function(v,I,P){"use strict";const R=P(65317);class DependenciesBlock{constructor(){this.dependencies=[];this.blocks=[];this.parent=undefined}getRootBlock(){let v=this;while(v.parent)v=v.parent;return v}addBlock(v){this.blocks.push(v);v.parent=this}addDependency(v){this.dependencies.push(v)}removeDependency(v){const I=this.dependencies.indexOf(v);if(I>=0){this.dependencies.splice(I,1)}}clearDependenciesAndBlocks(){this.dependencies.length=0;this.blocks.length=0}updateHash(v,I){for(const P of this.dependencies){P.updateHash(v,I)}for(const P of this.blocks){P.updateHash(v,I)}}serialize({write:v}){v(this.dependencies);v(this.blocks)}deserialize({read:v}){this.dependencies=v();this.blocks=v();for(const v of this.blocks){v.parent=this}}}R(DependenciesBlock,"webpack/lib/DependenciesBlock");v.exports=DependenciesBlock},49790:function(v,I,P){"use strict";const R=P(88490);const $=P(13594);const L=Symbol("transitive");const q=$((()=>new R("/* (ignored) */","ignored","(ignored)")));class Dependency{constructor(){this._parentModule=undefined;this._parentDependenciesBlock=undefined;this._parentDependenciesBlockIndex=-1;this.weak=false;this.optional=false;this._locSL=0;this._locSC=0;this._locEL=0;this._locEC=0;this._locI=undefined;this._locN=undefined;this._loc=undefined}get type(){return"unknown"}get category(){return"unknown"}get loc(){if(this._loc!==undefined)return this._loc;const v={};if(this._locSL>0){v.start={line:this._locSL,column:this._locSC}}if(this._locEL>0){v.end={line:this._locEL,column:this._locEC}}if(this._locN!==undefined){v.name=this._locN}if(this._locI!==undefined){v.index=this._locI}return this._loc=v}set loc(v){if("start"in v&&typeof v.start==="object"){this._locSL=v.start.line||0;this._locSC=v.start.column||0}else{this._locSL=0;this._locSC=0}if("end"in v&&typeof v.end==="object"){this._locEL=v.end.line||0;this._locEC=v.end.column||0}else{this._locEL=0;this._locEC=0}this._locI="index"in v?v.index:undefined;this._locN="name"in v?v.name:undefined;this._loc=v}setLoc(v,I,P,R){this._locSL=v;this._locSC=I;this._locEL=P;this._locEC=R;this._locI=undefined;this._locN=undefined;this._loc=undefined}getContext(){return undefined}getResourceIdentifier(){return null}couldAffectReferencingModule(){return L}getReference(v){throw new Error("Dependency.getReference was removed in favor of Dependency.getReferencedExports, ModuleGraph.getModule and ModuleGraph.getConnection().active")}getReferencedExports(v,I){return Dependency.EXPORTS_OBJECT_REFERENCED}getCondition(v){return null}getExports(v){return undefined}getWarnings(v){return null}getErrors(v){return null}updateHash(v,I){}getNumberOfIdOccurrences(){return 1}getModuleEvaluationSideEffectsState(v){return true}createIgnoredModule(v){return q()}serialize({write:v}){v(this.weak);v(this.optional);v(this._locSL);v(this._locSC);v(this._locEL);v(this._locEC);v(this._locI);v(this._locN)}deserialize({read:v}){this.weak=v();this.optional=v();this._locSL=v();this._locSC=v();this._locEL=v();this._locEC=v();this._locI=v();this._locN=v()}}Dependency.NO_EXPORTS_REFERENCED=[];Dependency.EXPORTS_OBJECT_REFERENCED=[[]];Object.defineProperty(Dependency.prototype,"module",{get(){throw new Error("module property was removed from Dependency (use compilation.moduleGraph.getModule(dependency) instead)")},set(){throw new Error("module property was removed from Dependency (use compilation.moduleGraph.updateModule(dependency, module) instead)")}});Object.defineProperty(Dependency.prototype,"disconnect",{get(){throw new Error("disconnect was removed from Dependency (Dependency no longer carries graph specific information)")}});Dependency.TRANSITIVE=L;v.exports=Dependency},82034:function(v,I,P){"use strict";class DependencyTemplate{apply(v,I,R){const $=P(50655);throw new $}}v.exports=DependencyTemplate},51589:function(v,I,P){"use strict";const R=P(12471);class DependencyTemplates{constructor(v="md4"){this._map=new Map;this._hash="31d6cfe0d16ae931b73c59d7e0c089c0";this._hashFunction=v}get(v){return this._map.get(v)}set(v,I){this._map.set(v,I)}updateHash(v){const I=R(this._hashFunction);I.update(`${this._hash}${v}`);this._hash=I.digest("hex")}getHash(){return this._hash}clone(){const v=new DependencyTemplates(this._hashFunction);v._map=new Map(this._map);v._hash=this._hash;return v}}v.exports=DependencyTemplates},13217:function(v,I,P){"use strict";const R=P(3710);const $=P(27142);const L=P(2932);class DllEntryPlugin{constructor(v,I,P){this.context=v;this.entries=I;this.options=P}apply(v){v.hooks.compilation.tap("DllEntryPlugin",((v,{normalModuleFactory:I})=>{const P=new R;v.dependencyFactories.set($,P);v.dependencyFactories.set(L,I)}));v.hooks.make.tapAsync("DllEntryPlugin",((v,I)=>{v.addEntry(this.context,new $(this.entries.map(((v,I)=>{const P=new L(v);P.loc={name:this.options.name,index:I};return P})),this.options.name),this.options,(v=>{if(v)return I(v);I()}))}))}}v.exports=DllEntryPlugin},39055:function(v,I,P){"use strict";const{RawSource:R}=P(51255);const $=P(34803);const{JS_TYPES:L}=P(30021);const{JAVASCRIPT_MODULE_TYPE_DYNAMIC:q}=P(6041);const K=P(5205);const ae=P(65317);const ge=new Set([K.require,K.module]);class DllModule extends ${constructor(v,I,P){super(q,v);this.dependencies=I;this.name=P}getSourceTypes(){return L}identifier(){return`dll ${this.name}`}readableIdentifier(v){return`dll ${this.name}`}build(v,I,P,R,$){this.buildMeta={};this.buildInfo={};return $()}codeGeneration(v){const I=new Map;I.set("javascript",new R(`module.exports = ${K.require};`));return{sources:I,runtimeRequirements:ge}}needBuild(v,I){return I(null,!this.buildMeta)}size(v){return 12}updateHash(v,I){v.update(`dll module${this.name||""}`);super.updateHash(v,I)}serialize(v){v.write(this.name);super.serialize(v)}deserialize(v){this.name=v.read();super.deserialize(v)}updateCacheModule(v){super.updateCacheModule(v);this.dependencies=v.dependencies}cleanupForCache(){super.cleanupForCache();this.dependencies=undefined}}ae(DllModule,"webpack/lib/DllModule");v.exports=DllModule},3710:function(v,I,P){"use strict";const R=P(39055);const $=P(8412);class DllModuleFactory extends ${constructor(){super();this.hooks=Object.freeze({})}create(v,I){const P=v.dependencies[0];I(null,{module:new R(v.context,P.dependencies,P.name)})}}v.exports=DllModuleFactory},72785:function(v,I,P){"use strict";const R=P(13217);const $=P(42568);const L=P(72853);const q=P(86750);const K=q(P(82305),(()=>P(79959)),{name:"Dll Plugin",baseDataPath:"options"});class DllPlugin{constructor(v){K(v);this.options={...v,entryOnly:v.entryOnly!==false}}apply(v){v.hooks.entryOption.tap("DllPlugin",((I,P)=>{if(typeof P!=="function"){for(const $ of Object.keys(P)){const L={name:$,filename:P.filename};new R(I,P[$].import,L).apply(v)}}else{throw new Error("DllPlugin doesn't support dynamic entry (function) yet")}return true}));new L(this.options).apply(v);if(!this.options.entryOnly){new $("DllPlugin").apply(v)}}}v.exports=DllPlugin},45662:function(v,I,P){"use strict";const R=P(54650);const $=P(80763);const L=P(80017);const q=P(94252);const K=P(79443);const ae=P(86750);const ge=P(46579).makePathsRelative;const be=ae(P(32399),(()=>P(90624)),{name:"Dll Reference Plugin",baseDataPath:"options"});class DllReferencePlugin{constructor(v){be(v);this.options=v;this._compilationData=new WeakMap}apply(v){v.hooks.compilation.tap("DllReferencePlugin",((v,{normalModuleFactory:I})=>{v.dependencyFactories.set(K,I)}));v.hooks.beforeCompile.tapAsync("DllReferencePlugin",((I,P)=>{if("manifest"in this.options){const $=this.options.manifest;if(typeof $==="string"){v.inputFileSystem.readFile($,((L,q)=>{if(L)return P(L);const K={path:$,data:undefined,error:undefined};try{K.data=R(q.toString("utf-8"))}catch(I){const P=ge(v.options.context,$,v.root);K.error=new DllManifestError(P,I.message)}this._compilationData.set(I,K);return P()}));return}}return P()}));v.hooks.compile.tap("DllReferencePlugin",(I=>{let P=this.options.name;let R=this.options.sourceType;let q="content"in this.options?this.options.content:undefined;if("manifest"in this.options){const v=this.options.manifest;let $;if(typeof v==="string"){const v=this._compilationData.get(I);if(v.error){return}$=v.data}else{$=v}if($){if(!P)P=$.name;if(!R)R=$.type;if(!q)q=$.content}}const K={};const ae=`dll-reference ${P}`;K[ae]=P;const ge=I.normalModuleFactory;new L(R||"var",K).apply(ge);new $({source:ae,type:this.options.type,scope:this.options.scope,context:this.options.context||v.options.context,content:q,extensions:this.options.extensions,associatedObjectForCache:v.root}).apply(ge)}));v.hooks.compilation.tap("DllReferencePlugin",((v,I)=>{if("manifest"in this.options){const P=this.options.manifest;if(typeof P==="string"){const R=this._compilationData.get(I);if(R.error){v.errors.push(R.error)}v.fileDependencies.add(P)}}}))}}class DllManifestError extends q{constructor(v,I){super();this.name="DllManifestError";this.message=`Dll manifest ${v}\n${I}`}}v.exports=DllReferencePlugin},14973:function(v,I,P){"use strict";const R=P(77529);const $=P(80142);const L=P(2932);class DynamicEntryPlugin{constructor(v,I){this.context=v;this.entry=I}apply(v){v.hooks.compilation.tap("DynamicEntryPlugin",((v,{normalModuleFactory:I})=>{v.dependencyFactories.set(L,I)}));v.hooks.make.tapPromise("DynamicEntryPlugin",(I=>Promise.resolve(this.entry()).then((P=>{const L=[];for(const q of Object.keys(P)){const K=P[q];const ae=R.entryDescriptionToOptions(v,q,K);for(const v of K.import){L.push(new Promise(((P,R)=>{I.addEntry(this.context,$.createDependency(v,ae),ae,(v=>{if(v)return R(v);P()}))})))}}return Promise.all(L)})).then((v=>{}))))}}v.exports=DynamicEntryPlugin},77529:function(v,I,P){"use strict";class EntryOptionPlugin{apply(v){v.hooks.entryOption.tap("EntryOptionPlugin",((I,P)=>{EntryOptionPlugin.applyEntryOption(v,I,P);return true}))}static applyEntryOption(v,I,R){if(typeof R==="function"){const $=P(14973);new $(I,R).apply(v)}else{const $=P(80142);for(const P of Object.keys(R)){const L=R[P];const q=EntryOptionPlugin.entryDescriptionToOptions(v,P,L);const K=L.import;for(const P of K){new $(I,P,q).apply(v)}}}}static entryDescriptionToOptions(v,I,R){const $={name:I,filename:R.filename,runtime:R.runtime,layer:R.layer,dependOn:R.dependOn,baseUri:R.baseUri,publicPath:R.publicPath,chunkLoading:R.chunkLoading,asyncChunks:R.asyncChunks,wasmLoading:R.wasmLoading,library:R.library};if(R.layer!==undefined&&!v.options.experiments.layers){throw new Error("'entryOptions.layer' is only allowed when 'experiments.layers' is enabled")}if(R.chunkLoading){const I=P(19353);I.checkEnabled(v,R.chunkLoading)}if(R.wasmLoading){const I=P(13872);I.checkEnabled(v,R.wasmLoading)}if(R.library){const I=P(48296);I.checkEnabled(v,R.library.type)}return $}}v.exports=EntryOptionPlugin},80142:function(v,I,P){"use strict";const R=P(2932);class EntryPlugin{constructor(v,I,P){this.context=v;this.entry=I;this.options=P||""}apply(v){v.hooks.compilation.tap("EntryPlugin",((v,{normalModuleFactory:I})=>{v.dependencyFactories.set(R,I)}));const{entry:I,options:P,context:$}=this;const L=EntryPlugin.createDependency(I,P);v.hooks.make.tapAsync("EntryPlugin",((v,I)=>{v.addEntry($,L,P,(v=>{I(v)}))}))}static createDependency(v,I){const P=new R(v);P.loc={name:typeof I==="object"?I.name:I};return P}}v.exports=EntryPlugin},59818:function(v,I,P){"use strict";const R=P(12068);class Entrypoint extends R{constructor(v,I=true){if(typeof v==="string"){v={name:v}}super({name:v.name});this.options=v;this._runtimeChunk=undefined;this._entrypointChunk=undefined;this._initial=I}isInitial(){return this._initial}setRuntimeChunk(v){this._runtimeChunk=v}getRuntimeChunk(){if(this._runtimeChunk)return this._runtimeChunk;for(const v of this.parentsIterable){if(v instanceof Entrypoint)return v.getRuntimeChunk()}return null}setEntrypointChunk(v){this._entrypointChunk=v}getEntrypointChunk(){return this._entrypointChunk}replaceChunk(v,I){if(this._runtimeChunk===v)this._runtimeChunk=I;if(this._entrypointChunk===v)this._entrypointChunk=I;return super.replaceChunk(v,I)}}v.exports=Entrypoint},32227:function(v,I,P){"use strict";const R=P(94252);const $=P(65317);class EnvironmentNotSupportAsyncWarning extends R{constructor(v,I){const P=`The generated code contains 'async/await' because this module is using "${I}".\nHowever, your target environment does not appear to support 'async/await'.\nAs a result, the code may not run as expected or may cause runtime errors.`;super(P);this.name="EnvironmentNotSupportAsyncWarning";this.module=v}static check(v,I,P){if(!I.supportsAsyncFunction()){v.addWarning(new EnvironmentNotSupportAsyncWarning(v,P))}}}$(EnvironmentNotSupportAsyncWarning,"webpack/lib/EnvironmentNotSupportAsyncWarning");v.exports=EnvironmentNotSupportAsyncWarning},32925:function(v,I,P){"use strict";const R=P(64448);const $=P(94252);class EnvironmentPlugin{constructor(...v){if(v.length===1&&Array.isArray(v[0])){this.keys=v[0];this.defaultValues={}}else if(v.length===1&&v[0]&&typeof v[0]==="object"){this.keys=Object.keys(v[0]);this.defaultValues=v[0]}else{this.keys=v;this.defaultValues={}}}apply(v){const I={};for(const P of this.keys){const R=process.env[P]!==undefined?process.env[P]:this.defaultValues[P];if(R===undefined){v.hooks.thisCompilation.tap("EnvironmentPlugin",(v=>{const I=new $(`EnvironmentPlugin - ${P} environment variable is undefined.\n\n`+"You can pass an object with default values to suppress this warning.\n"+"See https://webpack.js.org/plugins/environment-plugin for example.");I.name="EnvVariableNotDefinedError";v.errors.push(I)}))}I[`process.env.${P}`]=R===undefined?"undefined":JSON.stringify(R)}new R(I).apply(v)}}v.exports=EnvironmentPlugin},35199:function(v){"use strict";const I="LOADER_EXECUTION";const P="WEBPACK_OPTIONS";const cutOffByFlag=(v,I)=>{const P=v.split("\n");for(let v=0;v<P.length;v++){if(P[v].includes(I)){P.length=v}}return P.join("\n")};const cutOffLoaderExecution=v=>cutOffByFlag(v,I);const cutOffWebpackOptions=v=>cutOffByFlag(v,P);const cutOffMultilineMessage=(v,I)=>{const P=v.split("\n");const R=I.split("\n");const $=[];for(const[v,I]of P.entries()){if(!I.includes(R[v]))$.push(I)}return $.join("\n")};const cutOffMessage=(v,I)=>{const P=v.indexOf("\n");if(P===-1){return v===I?"":v}const R=v.slice(0,P);return R===I?v.slice(P+1):v};const cleanUp=(v,I)=>{v=cutOffLoaderExecution(v);v=cutOffMessage(v,I);return v};const cleanUpWebpackOptions=(v,I)=>{v=cutOffWebpackOptions(v);v=cutOffMultilineMessage(v,I);return v};v.exports.cutOffByFlag=cutOffByFlag;v.exports.cutOffLoaderExecution=cutOffLoaderExecution;v.exports.cutOffWebpackOptions=cutOffWebpackOptions;v.exports.cutOffMultilineMessage=cutOffMultilineMessage;v.exports.cutOffMessage=cutOffMessage;v.exports.cleanUp=cleanUp;v.exports.cleanUpWebpackOptions=cleanUpWebpackOptions},56625:function(v,I,P){"use strict";const{ConcatSource:R,RawSource:$}=P(51255);const L=P(98138);const q=P(20610);const K=P(5205);const ae=P(36926);const ge=new WeakMap;const be=new $(`/*\n * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").\n * This devtool is neither made for production nor for readable output files.\n * It uses "eval()" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with "devtool: false".\n * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).\n */\n`);class EvalDevToolModulePlugin{constructor(v={}){this.namespace=v.namespace||"";this.sourceUrlComment=v.sourceUrlComment||"\n//# sourceURL=[url]";this.moduleFilenameTemplate=v.moduleFilenameTemplate||"webpack://[namespace]/[resourcePath]?[loaders]"}apply(v){v.hooks.compilation.tap("EvalDevToolModulePlugin",(v=>{const I=ae.getCompilationHooks(v);I.renderModuleContent.tap("EvalDevToolModulePlugin",((I,P,{chunk:R,runtimeTemplate:ae,chunkGraph:be})=>{const xe=ge.get(I);if(xe!==undefined)return xe;if(P instanceof L){ge.set(I,I);return I}const ve=I.source();const Ce=v.getPath(this.namespace,{chunk:R});const Ne=q.createFilename(P,{moduleFilenameTemplate:this.moduleFilenameTemplate,namespace:Ce},{requestShortener:ae.requestShortener,chunkGraph:be,hashFunction:v.outputOptions.hashFunction});const He=`\n${this.sourceUrlComment.replace(/\[url\]/g,encodeURI(Ne).replace(/%2F/g,"/").replace(/%20/g,"_").replace(/%5E/g,"^").replace(/%5C/g,"\\").replace(/^\//,""))}`;const Qe=new $(`eval(${v.outputOptions.trustedTypes?`${K.createScript}(${JSON.stringify(ve+He)})`:JSON.stringify(ve+He)});`);ge.set(I,Qe);return Qe}));I.inlineInRuntimeBailout.tap("EvalDevToolModulePlugin",(()=>"the eval devtool is used."));I.render.tap("EvalDevToolModulePlugin",(v=>new R(be,v)));I.chunkHash.tap("EvalDevToolModulePlugin",((v,I)=>{I.update("EvalDevToolModulePlugin");I.update("2")}));if(v.outputOptions.trustedTypes){v.hooks.additionalModuleRuntimeRequirements.tap("EvalDevToolModulePlugin",((v,I,P)=>{I.add(K.createScript)}))}}))}}v.exports=EvalDevToolModulePlugin},22202:function(v,I,P){"use strict";const{ConcatSource:R,RawSource:$}=P(51255);const L=P(20610);const q=P(32594);const K=P(5205);const ae=P(99379);const ge=P(36926);const be=P(31698);const xe=P(84634);const{makePathsAbsolute:ve}=P(46579);const Ce=new WeakMap;const Ne=new $(`/*\n * ATTENTION: An "eval-source-map" devtool has been used.\n * This devtool is neither made for production nor for readable output files.\n * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with "devtool: false".\n * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).\n */\n`);class EvalSourceMapDevToolPlugin{constructor(v){let I;if(typeof v==="string"){I={append:v}}else{I=v}this.sourceMapComment=I.append&&typeof I.append!=="function"?I.append:"//# sourceURL=[module]\n//# sourceMappingURL=[url]";this.moduleFilenameTemplate=I.moduleFilenameTemplate||"webpack://[namespace]/[resource-path]?[hash]";this.namespace=I.namespace||"";this.options=I}apply(v){const I=this.options;v.hooks.compilation.tap("EvalSourceMapDevToolPlugin",(P=>{const He=ge.getCompilationHooks(P);new ae(I).apply(P);const Qe=L.matchObject.bind(L,I);He.renderModuleContent.tap("EvalSourceMapDevToolPlugin",((R,ae,{chunk:ge,runtimeTemplate:Ne,chunkGraph:He})=>{const Je=Ce.get(R);if(Je!==undefined){return Je}const result=v=>{Ce.set(R,v);return v};if(ae instanceof q){const v=ae;if(!Qe(v.resource)){return result(R)}}else if(ae instanceof be){const v=ae;if(v.rootModule instanceof q){const I=v.rootModule;if(!Qe(I.resource)){return result(R)}}else{return result(R)}}else{return result(R)}const Ve=P.getPath(this.namespace,{chunk:ge});let Ke;let Ye;if(R.sourceAndMap){const v=R.sourceAndMap(I);Ke=v.map;Ye=v.source}else{Ke=R.map(I);Ye=R.source()}if(!Ke){return result(R)}Ke={...Ke};const Xe=v.options.context;const Ze=v.root;const et=Ke.sources.map((v=>{if(!v.startsWith("webpack://"))return v;v=ve(Xe,v.slice(10),Ze);const I=P.findModule(v);return I||v}));let tt=et.map((v=>L.createFilename(v,{moduleFilenameTemplate:this.moduleFilenameTemplate,namespace:Ve},{requestShortener:Ne.requestShortener,chunkGraph:He,hashFunction:P.outputOptions.hashFunction})));tt=L.replaceDuplicates(tt,((v,I,P)=>{for(let I=0;I<P;I++)v+="*";return v}));Ke.sources=tt;if(I.noSources){Ke.sourcesContent=undefined}Ke.sourceRoot=I.sourceRoot||"";const nt=He.getModuleId(ae);Ke.file=typeof nt==="number"?`${nt}.js`:nt;if(I.debugIds){Ke.debugId=xe(Ye,Ke.file)}const st=`${this.sourceMapComment.replace(/\[url\]/g,`data:application/json;charset=utf-8;base64,${Buffer.from(JSON.stringify(Ke),"utf8").toString("base64")}`)}\n//# sourceURL=webpack-internal:///${nt}\n`;return result(new $(`eval(${P.outputOptions.trustedTypes?`${K.createScript}(${JSON.stringify(Ye+st)})`:JSON.stringify(Ye+st)});`))}));He.inlineInRuntimeBailout.tap("EvalDevToolModulePlugin",(()=>"the eval-source-map devtool is used."));He.render.tap("EvalSourceMapDevToolPlugin",(v=>new R(Ne,v)));He.chunkHash.tap("EvalSourceMapDevToolPlugin",((v,I)=>{I.update("EvalSourceMapDevToolPlugin");I.update("2")}));if(P.outputOptions.trustedTypes){P.hooks.additionalModuleRuntimeRequirements.tap("EvalSourceMapDevToolPlugin",((v,I,P)=>{I.add(K.createScript)}))}}))}}v.exports=EvalSourceMapDevToolPlugin},21311:function(v,I,P){"use strict";const{equals:R}=P(29179);const $=P(6022);const L=P(65317);const{forEachRuntime:q}=P(86620);const K=Object.freeze({Unused:0,OnlyPropertiesUsed:1,NoInfo:2,Unknown:3,Used:4});const RETURNS_TRUE=()=>true;const ae=Symbol("circular target");class RestoreProvidedData{constructor(v,I,P,R){this.exports=v;this.otherProvided=I;this.otherCanMangleProvide=P;this.otherTerminalBinding=R}serialize({write:v}){v(this.exports);v(this.otherProvided);v(this.otherCanMangleProvide);v(this.otherTerminalBinding)}static deserialize({read:v}){return new RestoreProvidedData(v(),v(),v(),v())}}L(RestoreProvidedData,"webpack/lib/ModuleGraph","RestoreProvidedData");class ExportsInfo{constructor(){this._exports=new Map;this._otherExportsInfo=new ExportInfo(null);this._sideEffectsOnlyInfo=new ExportInfo("*side effects only*");this._exportsAreOrdered=false;this._redirectTo=undefined}get ownedExports(){return this._exports.values()}get orderedOwnedExports(){if(!this._exportsAreOrdered){this._sortExports()}return this._exports.values()}get exports(){if(this._redirectTo!==undefined){const v=new Map(this._redirectTo._exports);for(const[I,P]of this._exports){v.set(I,P)}return v.values()}return this._exports.values()}get orderedExports(){if(!this._exportsAreOrdered){this._sortExports()}if(this._redirectTo!==undefined){const v=new Map(Array.from(this._redirectTo.orderedExports,(v=>[v.name,v])));for(const[I,P]of this._exports){v.set(I,P)}this._sortExportsMap(v);return v.values()}return this._exports.values()}get otherExportsInfo(){if(this._redirectTo!==undefined)return this._redirectTo.otherExportsInfo;return this._otherExportsInfo}_sortExportsMap(v){if(v.size>1){const I=[];for(const P of v.values()){I.push(P.name)}I.sort();let P=0;for(const R of v.values()){const v=I[P];if(R.name!==v)break;P++}for(;P<I.length;P++){const R=I[P];const $=v.get(R);v.delete(R);v.set(R,$)}}}_sortExports(){this._sortExportsMap(this._exports);this._exportsAreOrdered=true}setRedirectNamedTo(v){if(this._redirectTo===v)return false;this._redirectTo=v;return true}setHasProvideInfo(){for(const v of this._exports.values()){if(v.provided===undefined){v.provided=false}if(v.canMangleProvide===undefined){v.canMangleProvide=true}}if(this._redirectTo!==undefined){this._redirectTo.setHasProvideInfo()}else{if(this._otherExportsInfo.provided===undefined){this._otherExportsInfo.provided=false}if(this._otherExportsInfo.canMangleProvide===undefined){this._otherExportsInfo.canMangleProvide=true}}}setHasUseInfo(){for(const v of this._exports.values()){v.setHasUseInfo()}this._sideEffectsOnlyInfo.setHasUseInfo();if(this._redirectTo!==undefined){this._redirectTo.setHasUseInfo()}else{this._otherExportsInfo.setHasUseInfo()}}getOwnExportInfo(v){const I=this._exports.get(v);if(I!==undefined)return I;const P=new ExportInfo(v,this._otherExportsInfo);this._exports.set(v,P);this._exportsAreOrdered=false;return P}getExportInfo(v){const I=this._exports.get(v);if(I!==undefined)return I;if(this._redirectTo!==undefined)return this._redirectTo.getExportInfo(v);const P=new ExportInfo(v,this._otherExportsInfo);this._exports.set(v,P);this._exportsAreOrdered=false;return P}getReadOnlyExportInfo(v){const I=this._exports.get(v);if(I!==undefined)return I;if(this._redirectTo!==undefined)return this._redirectTo.getReadOnlyExportInfo(v);return this._otherExportsInfo}getReadOnlyExportInfoRecursive(v){const I=this.getReadOnlyExportInfo(v[0]);if(v.length===1)return I;if(!I.exportsInfo)return;return I.exportsInfo.getReadOnlyExportInfoRecursive(v.slice(1))}getNestedExportsInfo(v){if(Array.isArray(v)&&v.length>0){const I=this.getReadOnlyExportInfo(v[0]);if(!I.exportsInfo)return;return I.exportsInfo.getNestedExportsInfo(v.slice(1))}return this}setUnknownExportsProvided(v,I,P,R,$){let L=false;if(I){for(const v of I){this.getExportInfo(v)}}for(const $ of this._exports.values()){if(!v&&$.canMangleProvide!==false){$.canMangleProvide=false;L=true}if(I&&I.has($.name))continue;if($.provided!==true&&$.provided!==null){$.provided=null;L=true}if(P){$.setTarget(P,R,[$.name],-1)}}if(this._redirectTo!==undefined){if(this._redirectTo.setUnknownExportsProvided(v,I,P,R,$)){L=true}}else{if(this._otherExportsInfo.provided!==true&&this._otherExportsInfo.provided!==null){this._otherExportsInfo.provided=null;L=true}if(!v&&this._otherExportsInfo.canMangleProvide!==false){this._otherExportsInfo.canMangleProvide=false;L=true}if(P){this._otherExportsInfo.setTarget(P,R,undefined,$)}}return L}setUsedInUnknownWay(v){let I=false;for(const P of this._exports.values()){if(P.setUsedInUnknownWay(v)){I=true}}if(this._redirectTo!==undefined){if(this._redirectTo.setUsedInUnknownWay(v)){I=true}}else{if(this._otherExportsInfo.setUsedConditionally((v=>v<K.Unknown),K.Unknown,v)){I=true}if(this._otherExportsInfo.canMangleUse!==false){this._otherExportsInfo.canMangleUse=false;I=true}}return I}setUsedWithoutInfo(v){let I=false;for(const P of this._exports.values()){if(P.setUsedWithoutInfo(v)){I=true}}if(this._redirectTo!==undefined){if(this._redirectTo.setUsedWithoutInfo(v)){I=true}}else{if(this._otherExportsInfo.setUsed(K.NoInfo,v)){I=true}if(this._otherExportsInfo.canMangleUse!==false){this._otherExportsInfo.canMangleUse=false;I=true}}return I}setAllKnownExportsUsed(v){let I=false;for(const P of this._exports.values()){if(!P.provided)continue;if(P.setUsed(K.Used,v)){I=true}}return I}setUsedForSideEffectsOnly(v){return this._sideEffectsOnlyInfo.setUsedConditionally((v=>v===K.Unused),K.Used,v)}isUsed(v){if(this._redirectTo!==undefined){if(this._redirectTo.isUsed(v)){return true}}else if(this._otherExportsInfo.getUsed(v)!==K.Unused){return true}for(const I of this._exports.values()){if(I.getUsed(v)!==K.Unused){return true}}return false}isModuleUsed(v){if(this.isUsed(v))return true;if(this._sideEffectsOnlyInfo.getUsed(v)!==K.Unused)return true;return false}getUsedExports(v){if(!this._redirectTo!==undefined){switch(this._otherExportsInfo.getUsed(v)){case K.NoInfo:return null;case K.Unknown:case K.OnlyPropertiesUsed:case K.Used:return true}}const I=[];if(!this._exportsAreOrdered)this._sortExports();for(const P of this._exports.values()){switch(P.getUsed(v)){case K.NoInfo:return null;case K.Unknown:return true;case K.OnlyPropertiesUsed:case K.Used:I.push(P.name)}}if(this._redirectTo!==undefined){const P=this._redirectTo.getUsedExports(v);if(P===null)return null;if(P===true)return true;if(P!==false){for(const v of P){I.push(v)}}}if(I.length===0){switch(this._sideEffectsOnlyInfo.getUsed(v)){case K.NoInfo:return null;case K.Unused:return false}}return new $(I)}getProvidedExports(){if(!this._redirectTo!==undefined){switch(this._otherExportsInfo.provided){case undefined:return null;case null:return true;case true:return true}}const v=[];if(!this._exportsAreOrdered)this._sortExports();for(const I of this._exports.values()){switch(I.provided){case undefined:return null;case null:return true;case true:v.push(I.name)}}if(this._redirectTo!==undefined){const I=this._redirectTo.getProvidedExports();if(I===null)return null;if(I===true)return true;for(const P of I){if(!v.includes(P)){v.push(P)}}}return v}getRelevantExports(v){const I=[];for(const P of this._exports.values()){const R=P.getUsed(v);if(R===K.Unused)continue;if(P.provided===false)continue;I.push(P)}if(this._redirectTo!==undefined){for(const P of this._redirectTo.getRelevantExports(v)){if(!this._exports.has(P.name))I.push(P)}}if(this._otherExportsInfo.provided!==false&&this._otherExportsInfo.getUsed(v)!==K.Unused){I.push(this._otherExportsInfo)}return I}isExportProvided(v){if(Array.isArray(v)){const I=this.getReadOnlyExportInfo(v[0]);if(I.exportsInfo&&v.length>1){return I.exportsInfo.isExportProvided(v.slice(1))}return I.provided?v.length===1||undefined:I.provided}const I=this.getReadOnlyExportInfo(v);return I.provided}getUsageKey(v){const I=[];if(this._redirectTo!==undefined){I.push(this._redirectTo.getUsageKey(v))}else{I.push(this._otherExportsInfo.getUsed(v))}I.push(this._sideEffectsOnlyInfo.getUsed(v));for(const P of this.orderedOwnedExports){I.push(P.getUsed(v))}return I.join("|")}isEquallyUsed(v,I){if(this._redirectTo!==undefined){if(!this._redirectTo.isEquallyUsed(v,I))return false}else if(this._otherExportsInfo.getUsed(v)!==this._otherExportsInfo.getUsed(I)){return false}if(this._sideEffectsOnlyInfo.getUsed(v)!==this._sideEffectsOnlyInfo.getUsed(I)){return false}for(const P of this.ownedExports){if(P.getUsed(v)!==P.getUsed(I))return false}return true}getUsed(v,I){if(Array.isArray(v)){if(v.length===0)return this.otherExportsInfo.getUsed(I);const P=this.getReadOnlyExportInfo(v[0]);if(P.exportsInfo&&v.length>1){return P.exportsInfo.getUsed(v.slice(1),I)}return P.getUsed(I)}const P=this.getReadOnlyExportInfo(v);return P.getUsed(I)}getUsedName(v,I){if(Array.isArray(v)){if(v.length===0){if(!this.isUsed(I))return false;return v}const P=this.getReadOnlyExportInfo(v[0]);const R=P.getUsedName(v[0],I);if(R===false)return false;const $=R===v[0]&&v.length===1?v:[R];if(v.length===1){return $}if(P.exportsInfo&&P.getUsed(I)===K.OnlyPropertiesUsed){const R=P.exportsInfo.getUsedName(v.slice(1),I);if(!R)return false;return $.concat(R)}return $.concat(v.slice(1))}const P=this.getReadOnlyExportInfo(v);const R=P.getUsedName(v,I);return R}updateHash(v,I){this._updateHash(v,I,new Set)}_updateHash(v,I,P){const R=new Set(P);R.add(this);for(const P of this.orderedExports){if(P.hasInfo(this._otherExportsInfo,I)){P._updateHash(v,I,R)}}this._sideEffectsOnlyInfo._updateHash(v,I,R);this._otherExportsInfo._updateHash(v,I,R);if(this._redirectTo!==undefined){this._redirectTo._updateHash(v,I,R)}}getRestoreProvidedData(){const v=this._otherExportsInfo.provided;const I=this._otherExportsInfo.canMangleProvide;const P=this._otherExportsInfo.terminalBinding;const R=[];for(const $ of this.orderedExports){if($.provided!==v||$.canMangleProvide!==I||$.terminalBinding!==P||$.exportsInfoOwned){R.push({name:$.name,provided:$.provided,canMangleProvide:$.canMangleProvide,terminalBinding:$.terminalBinding,exportsInfo:$.exportsInfoOwned?$.exportsInfo.getRestoreProvidedData():undefined})}}return new RestoreProvidedData(R,v,I,P)}restoreProvided({otherProvided:v,otherCanMangleProvide:I,otherTerminalBinding:P,exports:R}){let $=true;for(const R of this._exports.values()){$=false;R.provided=v;R.canMangleProvide=I;R.terminalBinding=P}this._otherExportsInfo.provided=v;this._otherExportsInfo.canMangleProvide=I;this._otherExportsInfo.terminalBinding=P;for(const v of R){const I=this.getExportInfo(v.name);I.provided=v.provided;I.canMangleProvide=v.canMangleProvide;I.terminalBinding=v.terminalBinding;if(v.exportsInfo){const P=I.createNestedExportsInfo();P.restoreProvided(v.exportsInfo)}}if($)this._exportsAreOrdered=true}}class ExportInfo{constructor(v,I){this.name=v;this._usedName=I?I._usedName:null;this._globalUsed=I?I._globalUsed:undefined;this._usedInRuntime=I&&I._usedInRuntime?new Map(I._usedInRuntime):undefined;this._hasUseInRuntimeInfo=I?I._hasUseInRuntimeInfo:false;this.provided=I?I.provided:undefined;this.terminalBinding=I?I.terminalBinding:false;this.canMangleProvide=I?I.canMangleProvide:undefined;this.canMangleUse=I?I.canMangleUse:undefined;this.exportsInfoOwned=false;this.exportsInfo=undefined;this._target=undefined;if(I&&I._target){this._target=new Map;for(const[P,R]of I._target){this._target.set(P,{connection:R.connection,export:R.export||[v],priority:R.priority})}}this._maxTarget=undefined}set used(v){throw new Error("REMOVED")}get used(){throw new Error("REMOVED")}set usedName(v){throw new Error("REMOVED")}get usedName(){throw new Error("REMOVED")}get canMangle(){switch(this.canMangleProvide){case undefined:return this.canMangleUse===false?false:undefined;case false:return false;case true:switch(this.canMangleUse){case undefined:return undefined;case false:return false;case true:return true}}throw new Error(`Unexpected flags for canMangle ${this.canMangleProvide} ${this.canMangleUse}`)}setUsedInUnknownWay(v){let I=false;if(this.setUsedConditionally((v=>v<K.Unknown),K.Unknown,v)){I=true}if(this.canMangleUse!==false){this.canMangleUse=false;I=true}return I}setUsedWithoutInfo(v){let I=false;if(this.setUsed(K.NoInfo,v)){I=true}if(this.canMangleUse!==false){this.canMangleUse=false;I=true}return I}setHasUseInfo(){if(!this._hasUseInRuntimeInfo){this._hasUseInRuntimeInfo=true}if(this.canMangleUse===undefined){this.canMangleUse=true}if(this.exportsInfoOwned){this.exportsInfo.setHasUseInfo()}}setUsedConditionally(v,I,P){if(P===undefined){if(this._globalUsed===undefined){this._globalUsed=I;return true}if(this._globalUsed!==I&&v(this._globalUsed)){this._globalUsed=I;return true}}else if(this._usedInRuntime===undefined){if(I!==K.Unused&&v(K.Unused)){this._usedInRuntime=new Map;q(P,(v=>this._usedInRuntime.set(v,I)));return true}}else{let R=false;q(P,(P=>{const $=P;let L=this._usedInRuntime.get($);if(L===undefined)L=K.Unused;if(I!==L&&v(L)){if(I===K.Unused){this._usedInRuntime.delete($)}else{this._usedInRuntime.set($,I)}R=true}}));if(R){if(this._usedInRuntime.size===0)this._usedInRuntime=undefined;return true}}return false}setUsed(v,I){if(I===undefined){if(this._globalUsed!==v){this._globalUsed=v;return true}}else if(this._usedInRuntime===undefined){if(v!==K.Unused){this._usedInRuntime=new Map;q(I,(I=>this._usedInRuntime.set(I,v)));return true}}else{let P=false;q(I,(I=>{const R=I;let $=this._usedInRuntime.get(R);if($===undefined)$=K.Unused;if(v!==$){if(v===K.Unused){this._usedInRuntime.delete(R)}else{this._usedInRuntime.set(R,v)}P=true}}));if(P){if(this._usedInRuntime.size===0)this._usedInRuntime=undefined;return true}}return false}unsetTarget(v){if(!this._target)return false;if(this._target.delete(v)){this._maxTarget=undefined;return true}return false}setTarget(v,I,P,$=0){if(P)P=[...P];if(!this._target){this._target=new Map;this._target.set(v,{connection:I,export:P,priority:$});return true}const L=this._target.get(v);if(!L){if(L===null&&!I)return false;this._target.set(v,{connection:I,export:P,priority:$});this._maxTarget=undefined;return true}if(L.connection!==I||L.priority!==$||(P?!L.export||!R(L.export,P):L.export)){L.connection=I;L.export=P;L.priority=$;this._maxTarget=undefined;return true}return false}getUsed(v){if(!this._hasUseInRuntimeInfo)return K.NoInfo;if(this._globalUsed!==undefined)return this._globalUsed;if(this._usedInRuntime===undefined){return K.Unused}else if(typeof v==="string"){const I=this._usedInRuntime.get(v);return I===undefined?K.Unused:I}else if(v===undefined){let v=K.Unused;for(const I of this._usedInRuntime.values()){if(I===K.Used){return K.Used}if(v<I)v=I}return v}let I=K.Unused;for(const P of v){const v=this._usedInRuntime.get(P);if(v!==undefined){if(v===K.Used){return K.Used}if(I<v)I=v}}return I}getUsedName(v,I){if(this._hasUseInRuntimeInfo){if(this._globalUsed!==undefined){if(this._globalUsed===K.Unused)return false}else{if(this._usedInRuntime===undefined)return false;if(typeof I==="string"){if(!this._usedInRuntime.has(I)){return false}}else if(I!==undefined&&Array.from(I).every((v=>!this._usedInRuntime.has(v)))){return false}}}if(this._usedName!==null)return this._usedName;return this.name||v}hasUsedName(){return this._usedName!==null}setUsedName(v){this._usedName=v}getTerminalBinding(v,I=RETURNS_TRUE){if(this.terminalBinding)return this;const P=this.getTarget(v,I);if(!P)return;const R=v.getExportsInfo(P.module);if(!P.export)return R;return R.getReadOnlyExportInfoRecursive(P.export)}isReexport(){return!this.terminalBinding&&this._target&&this._target.size>0}_getMaxTarget(){if(this._maxTarget!==undefined)return this._maxTarget;if(this._target.size<=1)return this._maxTarget=this._target;let v=-Infinity;let I=Infinity;for(const{priority:P}of this._target.values()){if(v<P)v=P;if(I>P)I=P}if(v===I)return this._maxTarget=this._target;const P=new Map;for(const[I,R]of this._target){if(v===R.priority){P.set(I,R)}}this._maxTarget=P;return P}findTarget(v,I){return this._findTarget(v,I,new Set)}_findTarget(v,I,P){if(!this._target||this._target.size===0)return;const R=this._getMaxTarget().values().next().value;if(!R)return;let $={module:R.connection.module,export:R.export};for(;;){if(I($.module))return $;const R=v.getExportsInfo($.module);const L=R.getExportInfo($.export[0]);if(P.has(L))return null;const q=L._findTarget(v,I,P);if(!q)return false;if($.export.length===1){$=q}else{$={module:q.module,export:q.export?q.export.concat($.export.slice(1)):$.export.slice(1)}}}}getTarget(v,I=RETURNS_TRUE){const P=this._getTarget(v,I,undefined);if(P===ae)return;return P}_getTarget(v,I,P){const resolveTarget=(P,R)=>{if(!P)return null;if(!P.export){return{module:P.connection.module,connection:P.connection,export:undefined}}let $={module:P.connection.module,connection:P.connection,export:P.export};if(!I($))return $;let L=false;for(;;){const P=v.getExportsInfo($.module);const q=P.getExportInfo($.export[0]);if(!q)return $;if(R.has(q))return ae;const K=q._getTarget(v,I,R);if(K===ae)return ae;if(!K)return $;if($.export.length===1){$=K;if(!$.export)return $}else{$={module:K.module,connection:K.connection,export:K.export?K.export.concat($.export.slice(1)):$.export.slice(1)}}if(!I($))return $;if(!L){R=new Set(R);L=true}R.add(q)}};if(!this._target||this._target.size===0)return;if(P&&P.has(this))return ae;const $=new Set(P);$.add(this);const L=this._getMaxTarget().values();const q=resolveTarget(L.next().value,$);if(q===ae)return ae;if(q===null)return;let K=L.next();while(!K.done){const v=resolveTarget(K.value,$);if(v===ae)return ae;if(v===null)return;if(v.module!==q.module)return;if(!v.export!==!q.export)return;if(q.export&&!R(v.export,q.export))return;K=L.next()}return q}moveTarget(v,I,P){const R=this._getTarget(v,I,undefined);if(R===ae)return;if(!R)return;const $=this._getMaxTarget().values().next().value;if($.connection===R.connection&&$.export===R.export){return}this._target.clear();this._target.set(undefined,{connection:P?P(R):R.connection,export:R.export,priority:0});return R}createNestedExportsInfo(){if(this.exportsInfoOwned)return this.exportsInfo;this.exportsInfoOwned=true;const v=this.exportsInfo;this.exportsInfo=new ExportsInfo;this.exportsInfo.setHasProvideInfo();if(v){this.exportsInfo.setRedirectNamedTo(v)}return this.exportsInfo}getNestedExportsInfo(){return this.exportsInfo}hasInfo(v,I){return this._usedName&&this._usedName!==this.name||this.provided||this.terminalBinding||this.getUsed(I)!==v.getUsed(I)}updateHash(v,I){this._updateHash(v,I,new Set)}_updateHash(v,I,P){v.update(`${this._usedName||this.name}${this.getUsed(I)}${this.provided}${this.terminalBinding}`);if(this.exportsInfo&&!P.has(this.exportsInfo)){this.exportsInfo._updateHash(v,I,P)}}getUsedInfo(){if(this._globalUsed!==undefined){switch(this._globalUsed){case K.Unused:return"unused";case K.NoInfo:return"no usage info";case K.Unknown:return"maybe used (runtime-defined)";case K.Used:return"used";case K.OnlyPropertiesUsed:return"only properties used"}}else if(this._usedInRuntime!==undefined){const v=new Map;for(const[I,P]of this._usedInRuntime){const R=v.get(P);if(R!==undefined)R.push(I);else v.set(P,[I])}const I=Array.from(v,(([v,I])=>{switch(v){case K.NoInfo:return`no usage info in ${I.join(", ")}`;case K.Unknown:return`maybe used in ${I.join(", ")} (runtime-defined)`;case K.Used:return`used in ${I.join(", ")}`;case K.OnlyPropertiesUsed:return`only properties used in ${I.join(", ")}`}}));if(I.length>0){return I.join("; ")}}return this._hasUseInRuntimeInfo?"unused":"no usage info"}getProvidedInfo(){switch(this.provided){case undefined:return"no provided info";case null:return"maybe provided (runtime-defined)";case true:return"provided";case false:return"not provided"}}getRenameInfo(){if(this._usedName!==null&&this._usedName!==this.name){return`renamed to ${JSON.stringify(this._usedName).slice(1,-1)}`}switch(this.canMangleProvide){case undefined:switch(this.canMangleUse){case undefined:return"missing provision and use info prevents renaming";case false:return"usage prevents renaming (no provision info)";case true:return"missing provision info prevents renaming"}break;case true:switch(this.canMangleUse){case undefined:return"missing usage info prevents renaming";case false:return"usage prevents renaming";case true:return"could be renamed"}break;case false:switch(this.canMangleUse){case undefined:return"provision prevents renaming (no use info)";case false:return"usage and provision prevents renaming";case true:return"provision prevents renaming"}break}throw new Error(`Unexpected flags for getRenameInfo ${this.canMangleProvide} ${this.canMangleUse}`)}}v.exports=ExportsInfo;v.exports.ExportInfo=ExportInfo;v.exports.UsageState=K},98791:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$,JAVASCRIPT_MODULE_TYPE_ESM:L}=P(6041);const q=P(34022);const K=P(7001);const ae="ExportsInfoApiPlugin";class ExportsInfoApiPlugin{apply(v){v.hooks.compilation.tap(ae,((v,{normalModuleFactory:I})=>{v.dependencyTemplates.set(K,new K.Template);const handler=v=>{v.hooks.expressionMemberChain.for("__webpack_exports_info__").tap(ae,((I,P)=>{const R=P.length>=2?new K(I.range,P.slice(0,-1),P[P.length-1]):new K(I.range,null,P[0]);R.loc=I.loc;v.state.module.addDependency(R);return true}));v.hooks.expression.for("__webpack_exports_info__").tap(ae,(I=>{const P=new q("true",I.range);P.loc=I.loc;v.state.module.addPresentationalDependency(P);return true}))};I.hooks.parser.for(R).tap(ae,handler);I.hooks.parser.for($).tap(ae,handler);I.hooks.parser.for(L).tap(ae,handler)}))}}v.exports=ExportsInfoApiPlugin},98138:function(v,I,P){"use strict";const{OriginalSource:R,RawSource:$}=P(51255);const L=P(40255);const q=P(32227);const{UsageState:K}=P(21311);const ae=P(89959);const ge=P(34803);const{JS_TYPES:be,CSS_URL_TYPES:xe,CSS_IMPORT_TYPES:ve}=P(30021);const{JAVASCRIPT_MODULE_TYPE_DYNAMIC:Ce}=P(6041);const Ne=P(5205);const He=P(57227);const Qe=P(92296);const Je=P(12471);const Ve=P(96856);const Ke=P(65317);const Ye=P(30158);const{register:Xe}=P(32589);const Ze=new Set([Ne.module]);const et=new Set([Ne.loadScript]);const tt=new Set([Ne.definePropertyGetters]);const nt=new Set([]);const getSourceForGlobalVariableExternal=(v,I)=>{if(!Array.isArray(v)){v=[v]}const P=v.map((v=>`[${JSON.stringify(v)}]`)).join("");return{iife:I==="this",expression:`${I}${P}`}};const getSourceForCommonJsExternal=v=>{if(!Array.isArray(v)){return{expression:`require(${JSON.stringify(v)})`}}const I=v[0];return{expression:`require(${JSON.stringify(I)})${Ye(v,1)}`}};const getSourceForCommonJsExternalInNodeModule=(v,I,P)=>{const R=[new ae(`import { createRequire as __WEBPACK_EXTERNAL_createRequire } from "${P?"node:":""}module";\n`,ae.STAGE_HARMONY_IMPORTS,0,"external module node-commonjs")];if(!Array.isArray(v)){return{chunkInitFragments:R,expression:`__WEBPACK_EXTERNAL_createRequire(${I}.url)(${JSON.stringify(v)})`}}const $=v[0];return{chunkInitFragments:R,expression:`__WEBPACK_EXTERNAL_createRequire(${I}.url)(${JSON.stringify($)})${Ye(v,1)}`}};const getSourceForImportExternal=(v,I,P)=>{const R=I.outputOptions.importFunctionName;if(!I.supportsDynamicImport()&&(R==="import"||R==="module-import")){throw new Error("The target environment doesn't support 'import()' so it's not possible to use external type 'import'")}const $=P&&P.attributes?P.attributes._isLegacyAssert?`, { assert: ${JSON.stringify(P.attributes,importAssertionReplacer)} }`:`, { with: ${JSON.stringify(P.attributes)} }`:"";if(!Array.isArray(v)){return{expression:`${R}(${JSON.stringify(v)}${$});`}}if(v.length===1){return{expression:`${R}(${JSON.stringify(v[0])}${$});`}}const L=v[0];return{expression:`${R}(${JSON.stringify(L)}${$}).then(${I.returningFunction(`module${Ye(v,1)}`,"module")});`}};const importAssertionReplacer=(v,I)=>{if(v==="_isLegacyAssert"){return}return I};class ModuleExternalInitFragment extends ae{constructor(v,I,P,R="md4"){if(I===undefined){I=He.toIdentifier(v);if(I!==v){I+=`_${Je(R).update(v).digest("hex").slice(0,8)}`}}const $=`__WEBPACK_EXTERNAL_MODULE_${I}__`;super(`import * as ${$} from ${JSON.stringify(v)}${P&&P.attributes?P.attributes._isLegacyAssert?` assert ${JSON.stringify(P.attributes,importAssertionReplacer)}`:` with ${JSON.stringify(P.attributes)}`:""};\n`,ae.STAGE_HARMONY_IMPORTS,0,`external module import ${I}`);this._ident=I;this._request=v;this._dependencyMeta=v;this._identifier=$}getNamespaceIdentifier(){return this._identifier}}Xe(ModuleExternalInitFragment,"webpack/lib/ExternalModule","ModuleExternalInitFragment",{serialize(v,{write:I}){I(v._request);I(v._ident);I(v._dependencyMeta)},deserialize({read:v}){return new ModuleExternalInitFragment(v(),v(),v())}});const generateModuleRemapping=(v,I,P,R)=>{if(I.otherExportsInfo.getUsed(P)===K.Unused){const $=[];for(const L of I.orderedExports){const I=L.getUsedName(L.name,P);if(!I)continue;const q=L.getNestedExportsInfo();if(q){const P=generateModuleRemapping(`${v}${Ye([L.name])}`,q);if(P){$.push(`[${JSON.stringify(I)}]: y(${P})`);continue}}$.push(`[${JSON.stringify(I)}]: ${R.returningFunction(`${v}${Ye([L.name])}`)}`)}return`x({ ${$.join(", ")} })`}};const getSourceForModuleExternal=(v,I,P,R,$)=>{if(!Array.isArray(v))v=[v];const L=new ModuleExternalInitFragment(v[0],undefined,$,R.outputOptions.hashFunction);const q=`${L.getNamespaceIdentifier()}${Ye(v,1)}`;const K=generateModuleRemapping(q,I,P,R);const ae=K||q;return{expression:ae,init:K?`var x = ${R.basicFunction("y",`var x = {}; ${Ne.definePropertyGetters}(x, y); return x`)} \nvar y = ${R.returningFunction(R.returningFunction("x"),"x")}`:undefined,runtimeRequirements:K?tt:undefined,chunkInitFragments:[L]}};const getSourceForScriptExternal=(v,I)=>{if(typeof v==="string"){v=Ve(v)}const P=v[0];const R=v[1];return{init:"var __webpack_error__ = new Error();",expression:`new Promise(${I.basicFunction("resolve, reject",[`if(typeof ${R} !== "undefined") return resolve();`,`${Ne.loadScript}(${JSON.stringify(P)}, ${I.basicFunction("event",[`if(typeof ${R} !== "undefined") return resolve();`,"var errorType = event && (event.type === 'load' ? 'missing' : event.type);","var realSrc = event && event.target && event.target.src;","__webpack_error__.message = 'Loading script failed.\\n(' + errorType + ': ' + realSrc + ')';","__webpack_error__.name = 'ScriptExternalLoadError';","__webpack_error__.type = errorType;","__webpack_error__.request = realSrc;","reject(__webpack_error__);"])}, ${JSON.stringify(R)});`])}).then(${I.returningFunction(`${R}${Ye(v,2)}`)})`,runtimeRequirements:et}};const checkExternalVariable=(v,I,P)=>`if(typeof ${v} === 'undefined') { ${P.throwMissingModuleErrorBlock({request:I})} }\n`;const getSourceForAmdOrUmdExternal=(v,I,P,R)=>{const $=`__WEBPACK_EXTERNAL_MODULE_${He.toIdentifier(`${v}`)}__`;return{init:I?checkExternalVariable($,Array.isArray(P)?P.join("."):P,R):undefined,expression:$}};const getSourceForDefaultCase=(v,I,P)=>{if(!Array.isArray(I)){I=[I]}const R=I[0];const $=Ye(I,1);return{init:v?checkExternalVariable(R,I.join("."),P):undefined,expression:`${R}${$}`}};class ExternalModule extends ge{constructor(v,I,P,R){super(Ce,null);this.request=v;this.externalType=I;this.userRequest=P;this.dependencyMeta=R}getSourceTypes(){if(this.externalType==="asset"&&this.dependencyMeta&&this.dependencyMeta.sourceType==="css-url"){return xe}else if(this.externalType==="css-import"){return ve}return be}libIdent(v){return this.userRequest}chunkCondition(v,{chunkGraph:I}){return this.externalType==="css-import"?true:I.getNumberOfEntryModules(v)>0}identifier(){return`external ${this._resolveExternalType(this.externalType)} ${JSON.stringify(this.request)}`}readableIdentifier(v){return`external ${JSON.stringify(this.request)}`}needBuild(v,I){return I(null,!this.buildMeta)}build(v,I,P,R,$){this.buildMeta={async:false,exportsType:undefined};this.buildInfo={strict:true,topLevelDeclarations:new Set,module:I.outputOptions.module};const{request:L,externalType:K}=this._getRequestAndExternalType();this.buildMeta.exportsType="dynamic";let ae=false;this.clearDependenciesAndBlocks();switch(K){case"this":this.buildInfo.strict=false;break;case"system":if(!Array.isArray(L)||L.length===1){this.buildMeta.exportsType="namespace";ae=true}break;case"module":if(this.buildInfo.module){if(!Array.isArray(L)||L.length===1){this.buildMeta.exportsType="namespace";ae=true}}else{this.buildMeta.async=true;q.check(this,I.runtimeTemplate,"external module");if(!Array.isArray(L)||L.length===1){this.buildMeta.exportsType="namespace";ae=false}}break;case"script":this.buildMeta.async=true;q.check(this,I.runtimeTemplate,"external script");break;case"promise":this.buildMeta.async=true;q.check(this,I.runtimeTemplate,"external promise");break;case"import":this.buildMeta.async=true;q.check(this,I.runtimeTemplate,"external import");if(!Array.isArray(L)||L.length===1){this.buildMeta.exportsType="namespace";ae=false}break}this.addDependency(new Qe(true,ae));$()}restoreFromUnsafeCache(v,I){this._restoreFromUnsafeCache(v,I)}getConcatenationBailoutReason({moduleGraph:v}){switch(this.externalType){case"amd":case"amd-require":case"umd":case"umd2":case"system":case"jsonp":return`${this.externalType} externals can't be concatenated`}return undefined}_getRequestAndExternalType(){let{request:v,externalType:I}=this;if(typeof v==="object"&&!Array.isArray(v))v=v[I];I=this._resolveExternalType(I);return{request:v,externalType:I}}_resolveExternalType(v){if(v==="module-import"){if(this.dependencyMeta&&this.dependencyMeta.externalType){return this.dependencyMeta.externalType}return"module"}else if(v==="asset"){if(this.dependencyMeta&&this.dependencyMeta.sourceType){return this.dependencyMeta.sourceType}return"asset"}return v}_getSourceData(v,I,P,R,$,L,q){switch(I){case"this":case"window":case"self":return getSourceForGlobalVariableExternal(v,this.externalType);case"global":return getSourceForGlobalVariableExternal(v,P.globalObject);case"commonjs":case"commonjs2":case"commonjs-module":case"commonjs-static":return getSourceForCommonJsExternal(v);case"node-commonjs":return this.buildInfo.module?getSourceForCommonJsExternalInNodeModule(v,P.outputOptions.importMetaName,P.supportNodePrefixForCoreModules()):getSourceForCommonJsExternal(v);case"amd":case"amd-require":case"umd":case"umd2":case"system":case"jsonp":{const I=$.getModuleId(this);return getSourceForAmdOrUmdExternal(I!==null?I:this.identifier(),this.isOptional(R),v,P)}case"import":return getSourceForImportExternal(v,P,q);case"script":return getSourceForScriptExternal(v,P);case"module":{if(!this.buildInfo.module){if(!P.supportsDynamicImport()){throw new Error(`The target environment doesn't support dynamic import() syntax so it's not possible to use external type 'module' within a script${P.supportsEcmaScriptModuleSyntax()?"\nDid you mean to build a EcmaScript Module ('output.module: true')?":""}`)}return getSourceForImportExternal(v,P,q)}if(!P.supportsEcmaScriptModuleSyntax()){throw new Error("The target environment doesn't support EcmaScriptModule syntax so it's not possible to use external type 'module'")}return getSourceForModuleExternal(v,R.getExportsInfo(this),L,P,q)}case"var":case"promise":case"const":case"let":case"assign":default:return getSourceForDefaultCase(this.isOptional(R),v,P)}}codeGeneration({runtimeTemplate:v,moduleGraph:I,chunkGraph:P,runtime:q,concatenationScope:K}){const{request:ae,externalType:ge}=this._getRequestAndExternalType();switch(ge){case"asset":{const v=new Map;v.set("javascript",new $(`module.exports = ${JSON.stringify(ae)};`));const I=new Map;I.set("url",{javascript:ae});return{sources:v,runtimeRequirements:Ze,data:I}}case"css-url":{const v=new Map;const I=new Map;I.set("url",{"css-url":ae});return{sources:v,runtimeRequirements:Ze,data:I}}case"css-import":{const v=new Map;const I=this.dependencyMeta;const P=I.layer!==undefined?` layer(${I.layer})`:"";const R=I.supports?` supports(${I.supports})`:"";const L=I.media?` ${I.media}`:"";v.set("css-import",new $(`@import url(${JSON.stringify(ae)})${P}${R}${L};`));return{sources:v,runtimeRequirements:nt}}default:{const be=this._getSourceData(ae,ge,v,I,P,q,this.dependencyMeta);let xe=be.expression;if(be.iife)xe=`(function() { return ${xe}; }())`;if(K){xe=`${v.supportsConst()?"const":"var"} ${L.NAMESPACE_OBJECT_EXPORT} = ${xe};`;K.registerNamespaceExport(L.NAMESPACE_OBJECT_EXPORT)}else{xe=`module.exports = ${xe};`}if(be.init)xe=`${be.init}\n${xe}`;let ve;if(be.chunkInitFragments){ve=new Map;ve.set("chunkInitFragments",be.chunkInitFragments)}const Ce=new Map;if(this.useSourceMap||this.useSimpleSourceMap){Ce.set("javascript",new R(xe,this.identifier()))}else{Ce.set("javascript",new $(xe))}let He=be.runtimeRequirements;if(!K){if(!He){He=Ze}else{const v=new Set(He);v.add(Ne.module);He=v}}return{sources:Ce,runtimeRequirements:He||nt,data:ve}}}}size(v){return 42}updateHash(v,I){const{chunkGraph:P}=I;v.update(`${this._resolveExternalType(this.externalType)}${JSON.stringify(this.request)}${this.isOptional(P.moduleGraph)}`);super.updateHash(v,I)}serialize(v){const{write:I}=v;I(this.request);I(this.externalType);I(this.userRequest);I(this.dependencyMeta);super.serialize(v)}deserialize(v){const{read:I}=v;this.request=I();this.externalType=I();this.userRequest=I();this.dependencyMeta=I();super.deserialize(v)}}Ke(ExternalModule,"webpack/lib/ExternalModule");v.exports=ExternalModule},80017:function(v,I,P){"use strict";const R=P(73837);const $=P(98138);const L=P(10573);const q=P(35640);const K=P(79026);const ae=P(33643);const ge=P(91879);const{resolveByProperty:be,cachedSetProperty:xe}=P(22298);const ve=/^[a-z0-9-]+ /;const Ce={};const Ne=R.deprecate(((v,I,P,R)=>{v.call(null,I,P,R)}),"The externals-function should be defined like ({context, request}, cb) => { ... }","DEP_WEBPACK_EXTERNALS_FUNCTION_PARAMETERS");const He=new WeakMap;const resolveLayer=(v,I)=>{let P=He.get(v);if(P===undefined){P=new Map;He.set(v,P)}else{const v=P.get(I);if(v!==undefined)return v}const R=be(v,"byLayer",I);P.set(I,R);return R};class ExternalModuleFactoryPlugin{constructor(v,I){this.type=v;this.externals=I}apply(v){const I=this.type;v.hooks.factorize.tapAsync("ExternalModuleFactoryPlugin",((P,R)=>{const be=P.context;const He=P.contextInfo;const Qe=P.dependencies[0];const Je=P.dependencyType;const handleExternal=(v,P,R)=>{if(v===false){return R()}let be=v===true?Qe.request:v;if(P===undefined){if(typeof be==="string"&&ve.test(be)){const v=be.indexOf(" ");P=be.slice(0,v);be=be.slice(v+1)}else if(Array.isArray(be)&&be.length>0&&ve.test(be[0])){const v=be[0];const I=v.indexOf(" ");P=v.slice(0,I);be=[v.slice(I+1),...be.slice(1)]}}const xe=P||I;let Ce;if(Qe instanceof ae||Qe instanceof ge||Qe instanceof L){const v=Qe instanceof ae?"module":Qe instanceof ge?"import":undefined;Ce={attributes:Qe.assertions,externalType:v}}else if(Qe instanceof q){Ce={layer:Qe.layer,supports:Qe.supports,media:Qe.media}}if(xe==="asset"&&Qe instanceof K){Ce={sourceType:"css-url"}}R(null,new $(be,xe,Qe.request,Ce))};const handleExternals=(I,R)=>{if(typeof I==="string"){if(I===Qe.request){return handleExternal(Qe.request,undefined,R)}}else if(Array.isArray(I)){let v=0;const next=()=>{let P;const handleExternalsAndCallback=(v,I)=>{if(v)return R(v);if(!I){if(P){P=false;return}return next()}R(null,I)};do{P=true;if(v>=I.length)return R();handleExternals(I[v++],handleExternalsAndCallback)}while(!P);P=false};next();return}else if(I instanceof RegExp){if(I.test(Qe.request)){return handleExternal(Qe.request,undefined,R)}}else if(typeof I==="function"){const cb=(v,I,P)=>{if(v)return R(v);if(I!==undefined){handleExternal(I,P,R)}else{R()}};if(I.length===3){Ne(I,be,Qe.request,cb)}else{const R=I({context:be,request:Qe.request,dependencyType:Je,contextInfo:He,getResolve:I=>(R,$,L)=>{const q={fileDependencies:P.fileDependencies,missingDependencies:P.missingDependencies,contextDependencies:P.contextDependencies};let K=v.getResolver("normal",Je?xe(P.resolveOptions||Ce,"dependencyType",Je):P.resolveOptions);if(I)K=K.withOptions(I);if(L){K.resolve({},R,$,q,L)}else{return new Promise(((v,I)=>{K.resolve({},R,$,q,((P,R)=>{if(P)I(P);else v(R)}))}))}}},cb);if(R&&R.then)R.then((v=>cb(null,v)),cb)}return}else if(typeof I==="object"){const v=resolveLayer(I,He.issuerLayer);if(Object.prototype.hasOwnProperty.call(v,Qe.request)){return handleExternal(v[Qe.request],undefined,R)}}R()};handleExternals(this.externals,R)}))}}v.exports=ExternalModuleFactoryPlugin},52925:function(v,I,P){"use strict";const R=P(80017);class ExternalsPlugin{constructor(v,I){this.type=v;this.externals=I}apply(v){v.hooks.compile.tap("ExternalsPlugin",(({normalModuleFactory:v})=>{new R(this.type,this.externals).apply(v)}))}}v.exports=ExternalsPlugin},2908:function(v,I,P){"use strict";const R=P(94252);class FalseIIFEUmdWarning extends R{constructor(){super();this.name="FalseIIFEUmdWarning";this.message="Configuration:\nSetting 'output.iife' to 'false' is incompatible with 'output.library.type' set to 'umd'. This configuration may cause unexpected behavior, as UMD libraries are expected to use an IIFE (Immediately Invoked Function Expression) to support various module formats. Consider setting 'output.iife' to 'true' or choosing a different 'library.type' to ensure compatibility.\nLearn more: https://webpack.js.org/configuration/output/"}}v.exports=FalseIIFEUmdWarning},67222:function(v,I,P){"use strict";const{create:R}=P(90878);const $=P(98188);const L=P(78175);const{isAbsolute:q}=P(71017);const K=P(18663);const ae=P(57549);const ge=P(12471);const{join:be,dirname:xe,relative:ve,lstatReadlinkAbsolute:Ce}=P(80749);const Ne=P(65317);const He=P(22527);const Qe=Number(process.versions.modules)>=83;const Je=new Set($.builtinModules);let Ve=2e3;const Ke=new Set;const Ye=0;const Xe=1;const Ze=2;const et=3;const tt=4;const nt=5;const st=6;const rt=7;const ot=8;const it=9;const at=Symbol("invalid");const ct=(new Set).keys().next();class SnapshotIterator{constructor(v){this.next=v}}class SnapshotIterable{constructor(v,I){this.snapshot=v;this.getMaps=I}[Symbol.iterator](){let v=0;let I;let P;let R;let $;let L;return new SnapshotIterator((()=>{for(;;){switch(v){case 0:$=this.snapshot;P=this.getMaps;R=P($);v=1;case 1:if(R.length>0){const P=R.pop();if(P!==undefined){I=P.keys();v=2}else{break}}else{v=3;break}case 2:{const P=I.next();if(!P.done)return P;v=1;break}case 3:{const I=$.children;if(I!==undefined){if(I.size===1){for(const v of I)$=v;R=P($);v=1;break}if(L===undefined)L=[];for(const v of I){L.push(v)}}if(L!==undefined&&L.length>0){$=L.pop();R=P($);v=1;break}else{v=4}}case 4:return ct}}}))}}class Snapshot{constructor(){this._flags=0;this._cachedFileIterable=undefined;this._cachedContextIterable=undefined;this._cachedMissingIterable=undefined;this.startTime=undefined;this.fileTimestamps=undefined;this.fileHashes=undefined;this.fileTshs=undefined;this.contextTimestamps=undefined;this.contextHashes=undefined;this.contextTshs=undefined;this.missingExistence=undefined;this.managedItemInfo=undefined;this.managedFiles=undefined;this.managedContexts=undefined;this.managedMissing=undefined;this.children=undefined}hasStartTime(){return(this._flags&1)!==0}setStartTime(v){this._flags=this._flags|1;this.startTime=v}setMergedStartTime(v,I){if(v){if(I.hasStartTime()){this.setStartTime(Math.min(v,I.startTime))}else{this.setStartTime(v)}}else if(I.hasStartTime()){this.setStartTime(I.startTime)}}hasFileTimestamps(){return(this._flags&2)!==0}setFileTimestamps(v){this._flags=this._flags|2;this.fileTimestamps=v}hasFileHashes(){return(this._flags&4)!==0}setFileHashes(v){this._flags=this._flags|4;this.fileHashes=v}hasFileTshs(){return(this._flags&8)!==0}setFileTshs(v){this._flags=this._flags|8;this.fileTshs=v}hasContextTimestamps(){return(this._flags&16)!==0}setContextTimestamps(v){this._flags=this._flags|16;this.contextTimestamps=v}hasContextHashes(){return(this._flags&32)!==0}setContextHashes(v){this._flags=this._flags|32;this.contextHashes=v}hasContextTshs(){return(this._flags&64)!==0}setContextTshs(v){this._flags=this._flags|64;this.contextTshs=v}hasMissingExistence(){return(this._flags&128)!==0}setMissingExistence(v){this._flags=this._flags|128;this.missingExistence=v}hasManagedItemInfo(){return(this._flags&256)!==0}setManagedItemInfo(v){this._flags=this._flags|256;this.managedItemInfo=v}hasManagedFiles(){return(this._flags&512)!==0}setManagedFiles(v){this._flags=this._flags|512;this.managedFiles=v}hasManagedContexts(){return(this._flags&1024)!==0}setManagedContexts(v){this._flags=this._flags|1024;this.managedContexts=v}hasManagedMissing(){return(this._flags&2048)!==0}setManagedMissing(v){this._flags=this._flags|2048;this.managedMissing=v}hasChildren(){return(this._flags&4096)!==0}setChildren(v){this._flags=this._flags|4096;this.children=v}addChild(v){if(!this.hasChildren()){this.setChildren(new Set)}this.children.add(v)}serialize({write:v}){v(this._flags);if(this.hasStartTime())v(this.startTime);if(this.hasFileTimestamps())v(this.fileTimestamps);if(this.hasFileHashes())v(this.fileHashes);if(this.hasFileTshs())v(this.fileTshs);if(this.hasContextTimestamps())v(this.contextTimestamps);if(this.hasContextHashes())v(this.contextHashes);if(this.hasContextTshs())v(this.contextTshs);if(this.hasMissingExistence())v(this.missingExistence);if(this.hasManagedItemInfo())v(this.managedItemInfo);if(this.hasManagedFiles())v(this.managedFiles);if(this.hasManagedContexts())v(this.managedContexts);if(this.hasManagedMissing())v(this.managedMissing);if(this.hasChildren())v(this.children)}deserialize({read:v}){this._flags=v();if(this.hasStartTime())this.startTime=v();if(this.hasFileTimestamps())this.fileTimestamps=v();if(this.hasFileHashes())this.fileHashes=v();if(this.hasFileTshs())this.fileTshs=v();if(this.hasContextTimestamps())this.contextTimestamps=v();if(this.hasContextHashes())this.contextHashes=v();if(this.hasContextTshs())this.contextTshs=v();if(this.hasMissingExistence())this.missingExistence=v();if(this.hasManagedItemInfo())this.managedItemInfo=v();if(this.hasManagedFiles())this.managedFiles=v();if(this.hasManagedContexts())this.managedContexts=v();if(this.hasManagedMissing())this.managedMissing=v();if(this.hasChildren())this.children=v()}_createIterable(v){return new SnapshotIterable(this,v)}getFileIterable(){if(this._cachedFileIterable===undefined){this._cachedFileIterable=this._createIterable((v=>[v.fileTimestamps,v.fileHashes,v.fileTshs,v.managedFiles]))}return this._cachedFileIterable}getContextIterable(){if(this._cachedContextIterable===undefined){this._cachedContextIterable=this._createIterable((v=>[v.contextTimestamps,v.contextHashes,v.contextTshs,v.managedContexts]))}return this._cachedContextIterable}getMissingIterable(){if(this._cachedMissingIterable===undefined){this._cachedMissingIterable=this._createIterable((v=>[v.missingExistence,v.managedMissing]))}return this._cachedMissingIterable}}Ne(Snapshot,"webpack/lib/FileSystemInfo","Snapshot");const lt=3;class SnapshotOptimization{constructor(v,I,P,R=true,$=false){this._has=v;this._get=I;this._set=P;this._useStartTime=R;this._isSet=$;this._map=new Map;this._statItemsShared=0;this._statItemsUnshared=0;this._statSharedSnapshots=0;this._statReusedSharedSnapshots=0}getStatisticMessage(){const v=this._statItemsShared+this._statItemsUnshared;if(v===0)return;return`${this._statItemsShared&&Math.round(this._statItemsShared*100/v)}% (${this._statItemsShared}/${v}) entries shared via ${this._statSharedSnapshots} shared snapshots (${this._statReusedSharedSnapshots+this._statSharedSnapshots} times referenced)`}clear(){this._map.clear();this._statItemsShared=0;this._statItemsUnshared=0;this._statSharedSnapshots=0;this._statReusedSharedSnapshots=0}optimize(v,I){const increaseSharedAndStoreOptimizationEntry=v=>{if(v.children!==undefined){for(const I of v.children){increaseSharedAndStoreOptimizationEntry(I)}}v.shared++;storeOptimizationEntry(v)};const storeOptimizationEntry=v=>{for(const P of v.snapshotContent){const R=this._map.get(P);if(R.shared<v.shared){this._map.set(P,v)}I.delete(P)}};let P;const R=I.size;const $=new Set;for(const R of I){const I=this._map.get(R);if(I===undefined){if(P===undefined){P={snapshot:v,shared:0,snapshotContent:undefined,children:undefined}}this._map.set(R,P);continue}else{$.add(I)}}e:for(const P of $){const R=P.snapshot;if(P.shared>0){if(this._useStartTime&&v.startTime&&(!R.startTime||R.startTime>v.startTime)){continue}const $=new Set;const L=P.snapshotContent;const q=this._get(R);for(const v of L){if(!I.has(v)){if(!q.has(v)){continue e}$.add(v);continue}}if($.size===0){v.addChild(R);increaseSharedAndStoreOptimizationEntry(P);this._statReusedSharedSnapshots++}else{const I=L.size-$.size;if(I<lt){continue}let K;if(this._isSet){K=new Set;for(const v of q){if($.has(v))continue;K.add(v);q.delete(v)}}else{K=new Map;const v=q;for(const[I,P]of v){if($.has(I))continue;K.set(I,P);q.delete(I)}}const ae=new Snapshot;if(this._useStartTime){ae.setMergedStartTime(v.startTime,R)}this._set(ae,K);v.addChild(ae);R.addChild(ae);const ge={snapshot:ae,shared:P.shared+1,snapshotContent:new Set(K.keys()),children:undefined};if(P.children===undefined)P.children=new Set;P.children.add(ge);storeOptimizationEntry(ge);this._statSharedSnapshots++}}else{const P=this._get(R);if(P===undefined){continue}let $;if(this._isSet){$=new Set;const v=P;if(I.size<v.size){for(const P of I){if(v.has(P))$.add(P)}}else{for(const P of v){if(I.has(P))$.add(P)}}}else{$=new Map;const v=P;for(const P of I){const I=v.get(P);if(I===undefined)continue;$.set(P,I)}}if($.size<lt){continue}const L=new Snapshot;if(this._useStartTime){L.setMergedStartTime(v.startTime,R)}this._set(L,$);v.addChild(L);R.addChild(L);for(const v of $.keys())P.delete(v);const q=$.size;this._statItemsUnshared-=q;this._statItemsShared+=q;storeOptimizationEntry({snapshot:L,shared:2,snapshotContent:new Set($.keys()),children:undefined});this._statSharedSnapshots++}}const L=I.size;this._statItemsUnshared+=L;this._statItemsShared+=R-L}}const parseString=v=>{if(v[0]==="'"||v[0]==="`")v=`"${v.slice(1,-1).replace(/"/g,'\\"')}"`;return JSON.parse(v)};const applyMtime=v=>{if(Ve>1&&v%2!==0)Ve=1;else if(Ve>10&&v%20!==0)Ve=10;else if(Ve>100&&v%200!==0)Ve=100;else if(Ve>1e3&&v%2e3!==0)Ve=1e3};const mergeMaps=(v,I)=>{if(!I||I.size===0)return v;if(!v||v.size===0)return I;const P=new Map(v);for(const[v,R]of I){P.set(v,R)}return P};const mergeSets=(v,I)=>{if(!I||I.size===0)return v;if(!v||v.size===0)return I;const P=new Set(v);for(const v of I){P.add(v)}return P};const getManagedItem=(v,I)=>{let P=v.length;let R=1;let $=true;e:while(P<I.length){switch(I.charCodeAt(P)){case 47:case 92:if(--R===0)break e;$=true;break;case 46:if($)return null;break;case 64:if(!$)return null;R++;break;default:$=false;break}P++}if(P===I.length)R--;if(R!==0)return null;if(I.length>=P+13&&I.charCodeAt(P+1)===110&&I.charCodeAt(P+2)===111&&I.charCodeAt(P+3)===100&&I.charCodeAt(P+4)===101&&I.charCodeAt(P+5)===95&&I.charCodeAt(P+6)===109&&I.charCodeAt(P+7)===111&&I.charCodeAt(P+8)===100&&I.charCodeAt(P+9)===117&&I.charCodeAt(P+10)===108&&I.charCodeAt(P+11)===101&&I.charCodeAt(P+12)===115){if(I.length===P+13){return I}const v=I.charCodeAt(P+13);if(v===47||v===92){return getManagedItem(I.slice(0,P+14),I)}}return I.slice(0,P)};const getResolvedTimestamp=v=>{if(v===null)return null;if(v.resolved!==undefined)return v.resolved;return v.symlinks===undefined?v:undefined};const getResolvedHash=v=>{if(v===null)return null;if(v.resolved!==undefined)return v.resolved;return v.symlinks===undefined?v.hash:undefined};const addAll=(v,I)=>{for(const P of v)I.add(P)};class FileSystemInfo{constructor(v,{unmanagedPaths:I=[],managedPaths:P=[],immutablePaths:R=[],logger:$,hashFunction:L="md4"}={}){this.fs=v;this.logger=$;this._remainingLogs=$?40:0;this._loggedPaths=$?new Set:undefined;this._hashFunction=L;this._snapshotCache=new WeakMap;this._fileTimestampsOptimization=new SnapshotOptimization((v=>v.hasFileTimestamps()),(v=>v.fileTimestamps),((v,I)=>v.setFileTimestamps(I)));this._fileHashesOptimization=new SnapshotOptimization((v=>v.hasFileHashes()),(v=>v.fileHashes),((v,I)=>v.setFileHashes(I)),false);this._fileTshsOptimization=new SnapshotOptimization((v=>v.hasFileTshs()),(v=>v.fileTshs),((v,I)=>v.setFileTshs(I)));this._contextTimestampsOptimization=new SnapshotOptimization((v=>v.hasContextTimestamps()),(v=>v.contextTimestamps),((v,I)=>v.setContextTimestamps(I)));this._contextHashesOptimization=new SnapshotOptimization((v=>v.hasContextHashes()),(v=>v.contextHashes),((v,I)=>v.setContextHashes(I)),false);this._contextTshsOptimization=new SnapshotOptimization((v=>v.hasContextTshs()),(v=>v.contextTshs),((v,I)=>v.setContextTshs(I)));this._missingExistenceOptimization=new SnapshotOptimization((v=>v.hasMissingExistence()),(v=>v.missingExistence),((v,I)=>v.setMissingExistence(I)),false);this._managedItemInfoOptimization=new SnapshotOptimization((v=>v.hasManagedItemInfo()),(v=>v.managedItemInfo),((v,I)=>v.setManagedItemInfo(I)),false);this._managedFilesOptimization=new SnapshotOptimization((v=>v.hasManagedFiles()),(v=>v.managedFiles),((v,I)=>v.setManagedFiles(I)),false,true);this._managedContextsOptimization=new SnapshotOptimization((v=>v.hasManagedContexts()),(v=>v.managedContexts),((v,I)=>v.setManagedContexts(I)),false,true);this._managedMissingOptimization=new SnapshotOptimization((v=>v.hasManagedMissing()),(v=>v.managedMissing),((v,I)=>v.setManagedMissing(I)),false,true);this._fileTimestamps=new ae;this._fileHashes=new Map;this._fileTshs=new Map;this._contextTimestamps=new ae;this._contextHashes=new Map;this._contextTshs=new Map;this._managedItems=new Map;this.fileTimestampQueue=new K({name:"file timestamp",parallelism:30,processor:this._readFileTimestamp.bind(this)});this.fileHashQueue=new K({name:"file hash",parallelism:10,processor:this._readFileHash.bind(this)});this.contextTimestampQueue=new K({name:"context timestamp",parallelism:2,processor:this._readContextTimestamp.bind(this)});this.contextHashQueue=new K({name:"context hash",parallelism:2,processor:this._readContextHash.bind(this)});this.contextTshQueue=new K({name:"context hash and timestamp",parallelism:2,processor:this._readContextTimestampAndHash.bind(this)});this.managedItemQueue=new K({name:"managed item info",parallelism:10,processor:this._getManagedItemInfo.bind(this)});this.managedItemDirectoryQueue=new K({name:"managed item directory info",parallelism:10,processor:this._getManagedItemDirectoryInfo.bind(this)});const q=Array.from(I);this.unmanagedPathsWithSlash=q.filter((v=>typeof v==="string")).map((I=>be(v,I,"_").slice(0,-1)));this.unmanagedPathsRegExps=q.filter((v=>typeof v!=="string"));this.managedPaths=Array.from(P);this.managedPathsWithSlash=this.managedPaths.filter((v=>typeof v==="string")).map((I=>be(v,I,"_").slice(0,-1)));this.managedPathsRegExps=this.managedPaths.filter((v=>typeof v!=="string"));this.immutablePaths=Array.from(R);this.immutablePathsWithSlash=this.immutablePaths.filter((v=>typeof v==="string")).map((I=>be(v,I,"_").slice(0,-1)));this.immutablePathsRegExps=this.immutablePaths.filter((v=>typeof v!=="string"));this._cachedDeprecatedFileTimestamps=undefined;this._cachedDeprecatedContextTimestamps=undefined;this._warnAboutExperimentalEsmTracking=false;this._statCreatedSnapshots=0;this._statTestedSnapshotsCached=0;this._statTestedSnapshotsNotCached=0;this._statTestedChildrenCached=0;this._statTestedChildrenNotCached=0;this._statTestedEntries=0}logStatistics(){const v=this.logger;const logWhenMessage=(I,P)=>{if(P){v.log(`${I}: ${P}`)}};v.log(`${this._statCreatedSnapshots} new snapshots created`);v.log(`${this._statTestedSnapshotsNotCached&&Math.round(this._statTestedSnapshotsNotCached*100/(this._statTestedSnapshotsCached+this._statTestedSnapshotsNotCached))}% root snapshot uncached (${this._statTestedSnapshotsNotCached} / ${this._statTestedSnapshotsCached+this._statTestedSnapshotsNotCached})`);v.log(`${this._statTestedChildrenNotCached&&Math.round(this._statTestedChildrenNotCached*100/(this._statTestedChildrenCached+this._statTestedChildrenNotCached))}% children snapshot uncached (${this._statTestedChildrenNotCached} / ${this._statTestedChildrenCached+this._statTestedChildrenNotCached})`);v.log(`${this._statTestedEntries} entries tested`);v.log(`File info in cache: ${this._fileTimestamps.size} timestamps ${this._fileHashes.size} hashes ${this._fileTshs.size} timestamp hash combinations`);logWhenMessage("File timestamp snapshot optimization",this._fileTimestampsOptimization.getStatisticMessage());logWhenMessage("File hash snapshot optimization",this._fileHashesOptimization.getStatisticMessage());logWhenMessage("File timestamp hash combination snapshot optimization",this._fileTshsOptimization.getStatisticMessage());v.log(`Directory info in cache: ${this._contextTimestamps.size} timestamps ${this._contextHashes.size} hashes ${this._contextTshs.size} timestamp hash combinations`);logWhenMessage("Directory timestamp snapshot optimization",this._contextTimestampsOptimization.getStatisticMessage());logWhenMessage("Directory hash snapshot optimization",this._contextHashesOptimization.getStatisticMessage());logWhenMessage("Directory timestamp hash combination snapshot optimization",this._contextTshsOptimization.getStatisticMessage());logWhenMessage("Missing items snapshot optimization",this._missingExistenceOptimization.getStatisticMessage());v.log(`Managed items info in cache: ${this._managedItems.size} items`);logWhenMessage("Managed items snapshot optimization",this._managedItemInfoOptimization.getStatisticMessage());logWhenMessage("Managed files snapshot optimization",this._managedFilesOptimization.getStatisticMessage());logWhenMessage("Managed contexts snapshot optimization",this._managedContextsOptimization.getStatisticMessage());logWhenMessage("Managed missing snapshot optimization",this._managedMissingOptimization.getStatisticMessage())}_log(v,I,...P){const R=v+I;const $=this._loggedPaths;if($.has(R))return;$.add(R);this.logger.debug(`${v} invalidated because ${I}`,...P);if(--this._remainingLogs===0){this.logger.debug("Logging limit has been reached and no further logging will be emitted by FileSystemInfo")}}clear(){this._remainingLogs=this.logger?40:0;if(this._loggedPaths!==undefined)this._loggedPaths.clear();this._snapshotCache=new WeakMap;this._fileTimestampsOptimization.clear();this._fileHashesOptimization.clear();this._fileTshsOptimization.clear();this._contextTimestampsOptimization.clear();this._contextHashesOptimization.clear();this._contextTshsOptimization.clear();this._missingExistenceOptimization.clear();this._managedItemInfoOptimization.clear();this._managedFilesOptimization.clear();this._managedContextsOptimization.clear();this._managedMissingOptimization.clear();this._fileTimestamps.clear();this._fileHashes.clear();this._fileTshs.clear();this._contextTimestamps.clear();this._contextHashes.clear();this._contextTshs.clear();this._managedItems.clear();this._managedItems.clear();this._cachedDeprecatedFileTimestamps=undefined;this._cachedDeprecatedContextTimestamps=undefined;this._statCreatedSnapshots=0;this._statTestedSnapshotsCached=0;this._statTestedSnapshotsNotCached=0;this._statTestedChildrenCached=0;this._statTestedChildrenNotCached=0;this._statTestedEntries=0}addFileTimestamps(v,I){this._fileTimestamps.addAll(v,I);this._cachedDeprecatedFileTimestamps=undefined}addContextTimestamps(v,I){this._contextTimestamps.addAll(v,I);this._cachedDeprecatedContextTimestamps=undefined}getFileTimestamp(v,I){const P=this._fileTimestamps.get(v);if(P!==undefined)return I(null,P);this.fileTimestampQueue.add(v,I)}getContextTimestamp(v,I){const P=this._contextTimestamps.get(v);if(P!==undefined){if(P==="ignore")return I(null,"ignore");const v=getResolvedTimestamp(P);if(v!==undefined)return I(null,v);return this._resolveContextTimestamp(P,I)}this.contextTimestampQueue.add(v,((v,P)=>{if(v)return I(v);const R=P;const $=getResolvedTimestamp(R);if($!==undefined)return I(null,$);this._resolveContextTimestamp(R,I)}))}_getUnresolvedContextTimestamp(v,I){const P=this._contextTimestamps.get(v);if(P!==undefined)return I(null,P);this.contextTimestampQueue.add(v,I)}getFileHash(v,I){const P=this._fileHashes.get(v);if(P!==undefined)return I(null,P);this.fileHashQueue.add(v,I)}getContextHash(v,I){const P=this._contextHashes.get(v);if(P!==undefined){const v=getResolvedHash(P);if(v!==undefined)return I(null,v);return this._resolveContextHash(P,I)}this.contextHashQueue.add(v,((v,P)=>{if(v)return I(v);const R=P;const $=getResolvedHash(R);if($!==undefined)return I(null,$);this._resolveContextHash(R,I)}))}_getUnresolvedContextHash(v,I){const P=this._contextHashes.get(v);if(P!==undefined)return I(null,P);this.contextHashQueue.add(v,I)}getContextTsh(v,I){const P=this._contextTshs.get(v);if(P!==undefined){const v=getResolvedTimestamp(P);if(v!==undefined)return I(null,v);return this._resolveContextTsh(P,I)}this.contextTshQueue.add(v,((v,P)=>{if(v)return I(v);const R=P;const $=getResolvedTimestamp(R);if($!==undefined)return I(null,$);this._resolveContextTsh(R,I)}))}_getUnresolvedContextTsh(v,I){const P=this._contextTshs.get(v);if(P!==undefined)return I(null,P);this.contextTshQueue.add(v,I)}_createBuildDependenciesResolvers(){const v=R({resolveToContext:true,exportsFields:[],fileSystem:this.fs});const I=R({extensions:[".js",".json",".node"],conditionNames:["require","node"],exportsFields:["exports"],fileSystem:this.fs});const P=R({extensions:[".js",".json",".node"],conditionNames:["require","node"],exportsFields:[],fileSystem:this.fs});const $=R({extensions:[".js",".json",".node"],fullySpecified:true,conditionNames:["import","node"],exportsFields:["exports"],fileSystem:this.fs});return{resolveContext:v,resolveEsm:$,resolveCjs:I,resolveCjsAsChild:P}}resolveBuildDependencies(v,I,R){const{resolveContext:$,resolveEsm:L,resolveCjs:K,resolveCjsAsChild:ae}=this._createBuildDependenciesResolvers();const ge=new Set;const Ce=new Set;const Ne=new Set;const Ve=new Set;const Ke=new Set;const at=new Set;const ct=new Set;const lt=new Set;const ut=new Map;const pt=new Set;const dt={fileDependencies:at,contextDependencies:ct,missingDependencies:lt};const expectedToString=v=>v?` (expected ${v})`:"";const jobToString=v=>{switch(v.type){case Ye:return`resolve commonjs ${v.path}${expectedToString(v.expected)}`;case Xe:return`resolve esm ${v.path}${expectedToString(v.expected)}`;case Ze:return`resolve directory ${v.path}`;case et:return`resolve commonjs file ${v.path}${expectedToString(v.expected)}`;case nt:return`resolve esm file ${v.path}${expectedToString(v.expected)}`;case st:return`directory ${v.path}`;case rt:return`file ${v.path}`;case ot:return`directory dependencies ${v.path}`;case it:return`file dependencies ${v.path}`}return`unknown ${v.type} ${v.path}`};const pathToString=v=>{let I=` at ${jobToString(v)}`;v=v.issuer;while(v!==undefined){I+=`\n at ${jobToString(v)}`;v=v.issuer}return I};const ft=this.logger;He(Array.from(I,(I=>({type:Ye,context:v,path:I,expected:undefined,issuer:undefined}))),20,((v,I,R)=>{const{type:He,context:Ke,path:ct,expected:ht}=v;const resolveDirectory=P=>{const L=`d\n${Ke}\n${P}`;if(ut.has(L)){return R()}ut.set(L,undefined);$(Ke,P,dt,(($,q,K)=>{if($){if(ht===false){ut.set(L,false);return R()}pt.add(L);$.message+=`\nwhile resolving '${P}' in ${Ke} to a directory`;return R($)}const ae=K.path;ut.set(L,ae);I({type:st,context:undefined,path:ae,expected:undefined,issuer:v});R()}))};const resolveFile=(P,$,L)=>{const q=`${$}\n${Ke}\n${P}`;if(ut.has(q)){return R()}ut.set(q,undefined);L(Ke,P,dt,(($,L,K)=>{if(typeof ht==="string"){if(!$&&K&&K.path===ht){ut.set(q,K.path)}else{pt.add(q);ft.warn(`Resolving '${P}' in ${Ke} for build dependencies doesn't lead to expected result '${ht}', but to '${$||K&&K.path}' instead. Resolving dependencies are ignored for this path.\n${pathToString(v)}`)}}else{if($){if(ht===false){ut.set(q,false);return R()}pt.add(q);$.message+=`\nwhile resolving '${P}' in ${Ke} as file\n${pathToString(v)}`;return R($)}const L=K.path;ut.set(q,L);I({type:rt,context:undefined,path:L,expected:undefined,issuer:v})}R()}))};switch(He){case Ye:{const v=/[\\/]$/.test(ct);if(v){resolveDirectory(ct.slice(0,-1))}else{resolveFile(ct,"f",K)}break}case Xe:{const v=/[\\/]$/.test(ct);if(v){resolveDirectory(ct.slice(0,-1))}else{resolveFile(ct)}break}case Ze:{resolveDirectory(ct);break}case et:{resolveFile(ct,"f",K);break}case tt:{resolveFile(ct,"c",ae);break}case nt:{resolveFile(ct,"e",L);break}case rt:{if(ge.has(ct)){R();break}ge.add(ct);this.fs.realpath(ct,((P,$)=>{if(P)return R(P);const L=$;if(L!==ct){Ce.add(ct);at.add(ct);if(ge.has(L))return R();ge.add(L)}I({type:it,context:undefined,path:L,expected:undefined,issuer:v});R()}));break}case st:{if(Ne.has(ct)){R();break}Ne.add(ct);this.fs.realpath(ct,((P,$)=>{if(P)return R(P);const L=$;if(L!==ct){Ve.add(ct);at.add(ct);if(Ne.has(L))return R();Ne.add(L)}I({type:ot,context:undefined,path:L,expected:undefined,issuer:v});R()}));break}case it:{if(/\.json5?$|\.yarn-integrity$|yarn\.lock$|\.ya?ml/.test(ct)){process.nextTick(R);break}const $=require.cache[ct];if($&&Array.isArray($.children)){e:for(const P of $.children){const R=P.filename;if(R){I({type:rt,context:undefined,path:R,expected:undefined,issuer:v});const L=xe(this.fs,ct);for(const q of $.paths){if(R.startsWith(q)){const $=R.slice(q.length+1);const K=/^(@[^\\/]+[\\/])[^\\/]+/.exec($);if(K){I({type:rt,context:undefined,path:`${q+R[q.length]+K[0]+R[q.length]}package.json`,expected:false,issuer:v})}let ae=$.replace(/\\/g,"/");if(ae.endsWith(".js"))ae=ae.slice(0,-3);I({type:tt,context:L,path:ae,expected:P.filename,issuer:v});continue e}}let K=ve(this.fs,L,R);if(K.endsWith(".js"))K=K.slice(0,-3);K=K.replace(/\\/g,"/");if(!K.startsWith("../")&&!q(K)){K=`./${K}`}I({type:et,context:L,path:K,expected:P.filename,issuer:v})}}}else if(Qe&&/\.m?js$/.test(ct)){if(!this._warnAboutExperimentalEsmTracking){ft.log("Node.js doesn't offer a (nice) way to introspect the ESM dependency graph yet.\n"+"Until a full solution is available webpack uses an experimental ESM tracking based on parsing.\n"+"As best effort webpack parses the ESM files to guess dependencies. But this can lead to expensive and incorrect tracking.");this._warnAboutExperimentalEsmTracking=true}const $=P(6498);$.init.then((()=>{this.fs.readFile(ct,((P,L)=>{if(P)return R(P);try{const P=xe(this.fs,ct);const R=L.toString();const[q]=$.parse(R);for(const $ of q){try{let L;if($.d===-1){L=parseString(R.substring($.s-1,$.e+1))}else if($.d>-1){const v=R.substring($.s,$.e).trim();L=parseString(v)}else{continue}if(L.startsWith("node:"))continue;if(Je.has(L))continue;I({type:nt,context:P,path:L,expected:$.d>-1?false:undefined,issuer:v})}catch(I){ft.warn(`Parsing of ${ct} for build dependencies failed at 'import(${R.substring($.s,$.e)})'.\n`+"Build dependencies behind this expression are ignored and might cause incorrect cache invalidation.");ft.debug(pathToString(v));ft.debug(I.stack)}}}catch(I){ft.warn(`Parsing of ${ct} for build dependencies failed and all dependencies of this file are ignored, which might cause incorrect cache invalidation..`);ft.debug(pathToString(v));ft.debug(I.stack)}process.nextTick(R)}))}),R);break}else{ft.log(`Assuming ${ct} has no dependencies as we were unable to assign it to any module system.`);ft.debug(pathToString(v))}process.nextTick(R);break}case ot:{const P=/(^.+[\\/]node_modules[\\/](?:@[^\\/]+[\\/])?[^\\/]+)/.exec(ct);const $=P?P[1]:ct;const L=be(this.fs,$,"package.json");this.fs.readFile(L,((P,q)=>{if(P){if(P.code==="ENOENT"){lt.add(L);const P=xe(this.fs,$);if(P!==$){I({type:ot,context:undefined,path:P,expected:undefined,issuer:v})}R();return}return R(P)}at.add(L);let K;try{K=JSON.parse(q.toString("utf-8"))}catch(v){return R(v)}const ae=K.dependencies;const ge=K.optionalDependencies;const be=new Set;const ve=new Set;if(typeof ae==="object"&&ae){for(const v of Object.keys(ae)){be.add(v)}}if(typeof ge==="object"&&ge){for(const v of Object.keys(ge)){be.add(v);ve.add(v)}}for(const P of be){I({type:Ze,context:$,path:P,expected:!ve.has(P),issuer:v})}R()}));break}}}),(v=>{if(v)return R(v);for(const v of Ce)ge.delete(v);for(const v of Ve)Ne.delete(v);for(const v of pt)ut.delete(v);R(null,{files:ge,directories:Ne,missing:Ke,resolveResults:ut,resolveDependencies:{files:at,directories:ct,missing:lt}})}))}checkResolveResultsValid(v,I){const{resolveCjs:P,resolveCjsAsChild:R,resolveEsm:$,resolveContext:q}=this._createBuildDependenciesResolvers();L.eachLimit(v,20,(([v,I],L)=>{const[K,ae,ge]=v.split("\n");switch(K){case"d":q(ae,ge,{},((v,P,R)=>{if(I===false)return L(v?undefined:at);if(v)return L(v);const $=R.path;if($!==I)return L(at);L()}));break;case"f":P(ae,ge,{},((v,P,R)=>{if(I===false)return L(v?undefined:at);if(v)return L(v);const $=R.path;if($!==I)return L(at);L()}));break;case"c":R(ae,ge,{},((v,P,R)=>{if(I===false)return L(v?undefined:at);if(v)return L(v);const $=R.path;if($!==I)return L(at);L()}));break;case"e":$(ae,ge,{},((v,P,R)=>{if(I===false)return L(v?undefined:at);if(v)return L(v);const $=R.path;if($!==I)return L(at);L()}));break;default:L(new Error("Unexpected type in resolve result key"));break}}),(v=>{if(v===at){return I(null,false)}if(v){return I(v)}return I(null,true)}))}createSnapshot(v,I,P,R,$,L){const q=new Map;const K=new Map;const ae=new Map;const ge=new Map;const xe=new Map;const ve=new Map;const Ce=new Map;const Ne=new Map;const He=new Set;const Qe=new Set;const Je=new Set;const Ve=new Set;const Ke=new Snapshot;if(v)Ke.setStartTime(v);const Ye=new Set;const Xe=$&&$.hash?$.timestamp?3:2:1;let Ze=1;const jobDone=()=>{if(--Ze===0){if(q.size!==0){Ke.setFileTimestamps(q)}if(K.size!==0){Ke.setFileHashes(K)}if(ae.size!==0){Ke.setFileTshs(ae)}if(ge.size!==0){Ke.setContextTimestamps(ge)}if(xe.size!==0){Ke.setContextHashes(xe)}if(ve.size!==0){Ke.setContextTshs(ve)}if(Ce.size!==0){Ke.setMissingExistence(Ce)}if(Ne.size!==0){Ke.setManagedItemInfo(Ne)}this._managedFilesOptimization.optimize(Ke,He);if(He.size!==0){Ke.setManagedFiles(He)}this._managedContextsOptimization.optimize(Ke,Qe);if(Qe.size!==0){Ke.setManagedContexts(Qe)}this._managedMissingOptimization.optimize(Ke,Je);if(Je.size!==0){Ke.setManagedMissing(Je)}if(Ve.size!==0){Ke.setChildren(Ve)}this._snapshotCache.set(Ke,true);this._statCreatedSnapshots++;L(null,Ke)}};const jobError=()=>{if(Ze>0){Ze=-1e8;L(null,null)}};const checkManaged=(v,I)=>{for(const I of this.unmanagedPathsRegExps){if(I.test(v))return false}for(const I of this.unmanagedPathsWithSlash){if(v.startsWith(I))return false}for(const P of this.immutablePathsRegExps){if(P.test(v)){I.add(v);return true}}for(const P of this.immutablePathsWithSlash){if(v.startsWith(P)){I.add(v);return true}}for(const P of this.managedPathsRegExps){const R=P.exec(v);if(R){const P=getManagedItem(R[1],v);if(P){Ye.add(P);I.add(v);return true}}}for(const P of this.managedPathsWithSlash){if(v.startsWith(P)){const R=getManagedItem(P,v);if(R){Ye.add(R);I.add(v);return true}}}return false};const captureNonManaged=(v,I)=>{const P=new Set;for(const R of v){if(!checkManaged(R,I))P.add(R)}return P};const processCapturedFiles=v=>{switch(Xe){case 3:this._fileTshsOptimization.optimize(Ke,v);for(const I of v){const v=this._fileTshs.get(I);if(v!==undefined){ae.set(I,v)}else{Ze++;this._getFileTimestampAndHash(I,((v,P)=>{if(v){if(this.logger){this.logger.debug(`Error snapshotting file timestamp hash combination of ${I}: ${v.stack}`)}jobError()}else{ae.set(I,P);jobDone()}}))}}break;case 2:this._fileHashesOptimization.optimize(Ke,v);for(const I of v){const v=this._fileHashes.get(I);if(v!==undefined){K.set(I,v)}else{Ze++;this.fileHashQueue.add(I,((v,P)=>{if(v){if(this.logger){this.logger.debug(`Error snapshotting file hash of ${I}: ${v.stack}`)}jobError()}else{K.set(I,P);jobDone()}}))}}break;case 1:this._fileTimestampsOptimization.optimize(Ke,v);for(const I of v){const v=this._fileTimestamps.get(I);if(v!==undefined){if(v!=="ignore"){q.set(I,v)}}else{Ze++;this.fileTimestampQueue.add(I,((v,P)=>{if(v){if(this.logger){this.logger.debug(`Error snapshotting file timestamp of ${I}: ${v.stack}`)}jobError()}else{q.set(I,P);jobDone()}}))}}break}};if(I){processCapturedFiles(captureNonManaged(I,He))}const processCapturedDirectories=v=>{switch(Xe){case 3:this._contextTshsOptimization.optimize(Ke,v);for(const I of v){const v=this._contextTshs.get(I);let P;if(v!==undefined&&(P=getResolvedTimestamp(v))!==undefined){ve.set(I,P)}else{Ze++;const callback=(v,P)=>{if(v){if(this.logger){this.logger.debug(`Error snapshotting context timestamp hash combination of ${I}: ${v.stack}`)}jobError()}else{ve.set(I,P);jobDone()}};if(v!==undefined){this._resolveContextTsh(v,callback)}else{this.getContextTsh(I,callback)}}}break;case 2:this._contextHashesOptimization.optimize(Ke,v);for(const I of v){const v=this._contextHashes.get(I);let P;if(v!==undefined&&(P=getResolvedHash(v))!==undefined){xe.set(I,P)}else{Ze++;const callback=(v,P)=>{if(v){if(this.logger){this.logger.debug(`Error snapshotting context hash of ${I}: ${v.stack}`)}jobError()}else{xe.set(I,P);jobDone()}};if(v!==undefined){this._resolveContextHash(v,callback)}else{this.getContextHash(I,callback)}}}break;case 1:this._contextTimestampsOptimization.optimize(Ke,v);for(const I of v){const v=this._contextTimestamps.get(I);if(v==="ignore")continue;let P;if(v!==undefined&&(P=getResolvedTimestamp(v))!==undefined){ge.set(I,P)}else{Ze++;const callback=(v,P)=>{if(v){if(this.logger){this.logger.debug(`Error snapshotting context timestamp of ${I}: ${v.stack}`)}jobError()}else{ge.set(I,P);jobDone()}};if(v!==undefined){this._resolveContextTimestamp(v,callback)}else{this.getContextTimestamp(I,callback)}}}break}};if(P){processCapturedDirectories(captureNonManaged(P,Qe))}const processCapturedMissing=v=>{this._missingExistenceOptimization.optimize(Ke,v);for(const I of v){const v=this._fileTimestamps.get(I);if(v!==undefined){if(v!=="ignore"){Ce.set(I,Boolean(v))}}else{Ze++;this.fileTimestampQueue.add(I,((v,P)=>{if(v){if(this.logger){this.logger.debug(`Error snapshotting missing timestamp of ${I}: ${v.stack}`)}jobError()}else{Ce.set(I,Boolean(P));jobDone()}}))}}};if(R){processCapturedMissing(captureNonManaged(R,Je))}this._managedItemInfoOptimization.optimize(Ke,Ye);for(const v of Ye){const I=this._managedItems.get(v);if(I!==undefined){if(!I.startsWith("*")){He.add(be(this.fs,v,"package.json"))}else if(I==="*nested"){Je.add(be(this.fs,v,"package.json"))}Ne.set(v,I)}else{Ze++;this.managedItemQueue.add(v,((P,R)=>{if(P){if(this.logger){this.logger.debug(`Error snapshotting managed item ${v}: ${P.stack}`)}jobError()}else if(R){if(!R.startsWith("*")){He.add(be(this.fs,v,"package.json"))}else if(I==="*nested"){Je.add(be(this.fs,v,"package.json"))}Ne.set(v,R);jobDone()}else{const process=(I,P)=>{if(I.size===0)return;const R=new Set;for(const P of I){if(P.startsWith(v))R.add(P)}if(R.size>0)P(R)};process(He,processCapturedFiles);process(Qe,processCapturedDirectories);process(Je,processCapturedMissing);jobDone()}}))}}jobDone()}mergeSnapshots(v,I){const P=new Snapshot;if(v.hasStartTime()&&I.hasStartTime()){P.setStartTime(Math.min(v.startTime,I.startTime))}else if(I.hasStartTime()){P.startTime=I.startTime}else if(v.hasStartTime()){P.startTime=v.startTime}if(v.hasFileTimestamps()||I.hasFileTimestamps()){P.setFileTimestamps(mergeMaps(v.fileTimestamps,I.fileTimestamps))}if(v.hasFileHashes()||I.hasFileHashes()){P.setFileHashes(mergeMaps(v.fileHashes,I.fileHashes))}if(v.hasFileTshs()||I.hasFileTshs()){P.setFileTshs(mergeMaps(v.fileTshs,I.fileTshs))}if(v.hasContextTimestamps()||I.hasContextTimestamps()){P.setContextTimestamps(mergeMaps(v.contextTimestamps,I.contextTimestamps))}if(v.hasContextHashes()||I.hasContextHashes()){P.setContextHashes(mergeMaps(v.contextHashes,I.contextHashes))}if(v.hasContextTshs()||I.hasContextTshs()){P.setContextTshs(mergeMaps(v.contextTshs,I.contextTshs))}if(v.hasMissingExistence()||I.hasMissingExistence()){P.setMissingExistence(mergeMaps(v.missingExistence,I.missingExistence))}if(v.hasManagedItemInfo()||I.hasManagedItemInfo()){P.setManagedItemInfo(mergeMaps(v.managedItemInfo,I.managedItemInfo))}if(v.hasManagedFiles()||I.hasManagedFiles()){P.setManagedFiles(mergeSets(v.managedFiles,I.managedFiles))}if(v.hasManagedContexts()||I.hasManagedContexts()){P.setManagedContexts(mergeSets(v.managedContexts,I.managedContexts))}if(v.hasManagedMissing()||I.hasManagedMissing()){P.setManagedMissing(mergeSets(v.managedMissing,I.managedMissing))}if(v.hasChildren()||I.hasChildren()){P.setChildren(mergeSets(v.children,I.children))}if(this._snapshotCache.get(v)===true&&this._snapshotCache.get(I)===true){this._snapshotCache.set(P,true)}return P}checkSnapshotValid(v,I){const P=this._snapshotCache.get(v);if(P!==undefined){this._statTestedSnapshotsCached++;if(typeof P==="boolean"){I(null,P)}else{P.push(I)}return}this._statTestedSnapshotsNotCached++;this._checkSnapshotValidNoCache(v,I)}_checkSnapshotValidNoCache(v,I){let P;if(v.hasStartTime()){P=v.startTime}let R=1;const jobDone=()=>{if(--R===0){this._snapshotCache.set(v,true);I(null,true)}};const invalid=()=>{if(R>0){R=-1e8;this._snapshotCache.set(v,false);I(null,false)}};const invalidWithError=(v,I)=>{if(this._remainingLogs>0){this._log(v,"error occurred: %s",I)}invalid()};const checkHash=(v,I,P)=>{if(I!==P){if(this._remainingLogs>0){this._log(v,"hashes differ (%s != %s)",I,P)}return false}return true};const checkExistence=(v,I,P)=>{if(!I!==!P){if(this._remainingLogs>0){this._log(v,I?"it didn't exist before":"it does no longer exist")}return false}return true};const checkFile=(v,I,R,$=true)=>{if(I===R)return true;if(!checkExistence(v,Boolean(I),Boolean(R)))return false;if(I){if(typeof P==="number"&&I.safeTime>P){if($&&this._remainingLogs>0){this._log(v,"it may have changed (%d) after the start time of the snapshot (%d)",I.safeTime,P)}return false}const L=R;if(L.timestamp!==undefined&&I.timestamp!==L.timestamp){if($&&this._remainingLogs>0){this._log(v,"timestamps differ (%d != %d)",I.timestamp,L.timestamp)}return false}}return true};const checkContext=(v,I,R,$=true)=>{if(I===R)return true;if(!checkExistence(v,Boolean(I),Boolean(R)))return false;if(I){if(typeof P==="number"&&I.safeTime>P){if($&&this._remainingLogs>0){this._log(v,"it may have changed (%d) after the start time of the snapshot (%d)",I.safeTime,P)}return false}const L=R;if(L.timestampHash!==undefined&&I.timestampHash!==L.timestampHash){if($&&this._remainingLogs>0){this._log(v,"timestamps hashes differ (%s != %s)",I.timestampHash,L.timestampHash)}return false}}return true};if(v.hasChildren()){const childCallback=(v,I)=>{if(v||!I)return invalid();jobDone()};for(const I of v.children){const v=this._snapshotCache.get(I);if(v!==undefined){this._statTestedChildrenCached++;if(typeof v==="boolean"){if(v===false){invalid();return}}else{R++;v.push(childCallback)}}else{this._statTestedChildrenNotCached++;R++;this._checkSnapshotValidNoCache(I,childCallback)}}}if(v.hasFileTimestamps()){const I=v.fileTimestamps;this._statTestedEntries+=I.size;for(const[v,P]of I){const I=this._fileTimestamps.get(v);if(I!==undefined){if(I!=="ignore"&&!checkFile(v,I,P)){invalid();return}}else{R++;this.fileTimestampQueue.add(v,((I,R)=>{if(I)return invalidWithError(v,I);if(!checkFile(v,R,P)){invalid()}else{jobDone()}}))}}}const processFileHashSnapshot=(v,I)=>{const P=this._fileHashes.get(v);if(P!==undefined){if(P!=="ignore"&&!checkHash(v,P,I)){invalid()}}else{R++;this.fileHashQueue.add(v,((P,R)=>{if(P)return invalidWithError(v,P);if(!checkHash(v,R,I)){invalid()}else{jobDone()}}))}};if(v.hasFileHashes()){const I=v.fileHashes;this._statTestedEntries+=I.size;for(const[v,P]of I){processFileHashSnapshot(v,P)}}if(v.hasFileTshs()){const I=v.fileTshs;this._statTestedEntries+=I.size;for(const[v,P]of I){if(typeof P==="string"){processFileHashSnapshot(v,P)}else{const I=this._fileTimestamps.get(v);if(I!==undefined){if(I==="ignore"||!checkFile(v,I,P,false)){processFileHashSnapshot(v,P&&P.hash)}}else{R++;this.fileTimestampQueue.add(v,((I,R)=>{if(I)return invalidWithError(v,I);if(!checkFile(v,R,P,false)){processFileHashSnapshot(v,P&&P.hash)}jobDone()}))}}}}if(v.hasContextTimestamps()){const I=v.contextTimestamps;this._statTestedEntries+=I.size;for(const[v,P]of I){const I=this._contextTimestamps.get(v);if(I==="ignore")continue;let $;if(I!==undefined&&($=getResolvedTimestamp(I))!==undefined){if(!checkContext(v,$,P)){invalid();return}}else{R++;const callback=(I,R)=>{if(I)return invalidWithError(v,I);if(!checkContext(v,R,P)){invalid()}else{jobDone()}};if(I!==undefined){this._resolveContextTimestamp(I,callback)}else{this.getContextTimestamp(v,callback)}}}}const processContextHashSnapshot=(v,I)=>{const P=this._contextHashes.get(v);let $;if(P!==undefined&&($=getResolvedHash(P))!==undefined){if(!checkHash(v,$,I)){invalid()}}else{R++;const callback=(P,R)=>{if(P)return invalidWithError(v,P);if(!checkHash(v,R,I)){invalid()}else{jobDone()}};if(P!==undefined){this._resolveContextHash(P,callback)}else{this.getContextHash(v,callback)}}};if(v.hasContextHashes()){const I=v.contextHashes;this._statTestedEntries+=I.size;for(const[v,P]of I){processContextHashSnapshot(v,P)}}if(v.hasContextTshs()){const I=v.contextTshs;this._statTestedEntries+=I.size;for(const[v,P]of I){if(typeof P==="string"){processContextHashSnapshot(v,P)}else{const I=this._contextTimestamps.get(v);if(I==="ignore")continue;let $;if(I!==undefined&&($=getResolvedTimestamp(I))!==undefined){if(!checkContext(v,$,P,false)){processContextHashSnapshot(v,P&&P.hash)}}else{R++;const callback=(I,R)=>{if(I)return invalidWithError(v,I);if(!checkContext(v,R,P,false)){processContextHashSnapshot(v,P&&P.hash)}jobDone()};if(I!==undefined){this._resolveContextTimestamp(I,callback)}else{this.getContextTimestamp(v,callback)}}}}}if(v.hasMissingExistence()){const I=v.missingExistence;this._statTestedEntries+=I.size;for(const[v,P]of I){const I=this._fileTimestamps.get(v);if(I!==undefined){if(I!=="ignore"&&!checkExistence(v,Boolean(I),Boolean(P))){invalid();return}}else{R++;this.fileTimestampQueue.add(v,((I,R)=>{if(I)return invalidWithError(v,I);if(!checkExistence(v,Boolean(R),Boolean(P))){invalid()}else{jobDone()}}))}}}if(v.hasManagedItemInfo()){const I=v.managedItemInfo;this._statTestedEntries+=I.size;for(const[v,P]of I){const I=this._managedItems.get(v);if(I!==undefined){if(!checkHash(v,I,P)){invalid();return}}else{R++;this.managedItemQueue.add(v,((I,R)=>{if(I)return invalidWithError(v,I);if(!checkHash(v,R,P)){invalid()}else{jobDone()}}))}}}jobDone();if(R>0){const P=[I];I=(v,I)=>{for(const R of P)R(v,I)};this._snapshotCache.set(v,P)}}_readFileTimestamp(v,I){this.fs.stat(v,((P,R)=>{if(P){if(P.code==="ENOENT"){this._fileTimestamps.set(v,null);this._cachedDeprecatedFileTimestamps=undefined;return I(null,null)}return I(P)}const $=R;let L;if($.isDirectory()){L={safeTime:0,timestamp:undefined}}else{const v=Number($.mtime);if(v)applyMtime(v);L={safeTime:v?v+Ve:Infinity,timestamp:v}}this._fileTimestamps.set(v,L);this._cachedDeprecatedFileTimestamps=undefined;I(null,L)}))}_readFileHash(v,I){this.fs.readFile(v,((P,R)=>{if(P){if(P.code==="EISDIR"){this._fileHashes.set(v,"directory");return I(null,"directory")}if(P.code==="ENOENT"){this._fileHashes.set(v,null);return I(null,null)}if(P.code==="ERR_FS_FILE_TOO_LARGE"){this.logger.warn(`Ignoring ${v} for hashing as it's very large`);this._fileHashes.set(v,"too large");return I(null,"too large")}return I(P)}const $=ge(this._hashFunction);$.update(R);const L=$.digest("hex");this._fileHashes.set(v,L);I(null,L)}))}_getFileTimestampAndHash(v,I){const continueWithHash=P=>{const R=this._fileTimestamps.get(v);if(R!==undefined){if(R!=="ignore"){const $={...R,hash:P};this._fileTshs.set(v,$);return I(null,$)}this._fileTshs.set(v,P);return I(null,P)}this.fileTimestampQueue.add(v,((R,$)=>{if(R){return I(R)}const L={...$,hash:P};this._fileTshs.set(v,L);return I(null,L)}))};const P=this._fileHashes.get(v);if(P!==undefined){continueWithHash(P)}else{this.fileHashQueue.add(v,((v,P)=>{if(v){return I(v)}continueWithHash(P)}))}}_readContext({path:v,fromImmutablePath:I,fromManagedItem:P,fromSymlink:R,fromFile:$,fromDirectory:q,reduce:K},ae){this.fs.readdir(v,((ge,xe)=>{if(ge){if(ge.code==="ENOENT"){return ae(null,null)}return ae(ge)}const ve=xe.map((v=>v.normalize("NFC"))).filter((v=>!/^\./.test(v))).sort();L.map(ve,((L,K)=>{const ae=be(this.fs,v,L);for(const P of this.immutablePathsRegExps){if(P.test(v)){return K(null,I(v))}}for(const P of this.immutablePathsWithSlash){if(v.startsWith(P)){return K(null,I(v))}}for(const I of this.managedPathsRegExps){const R=I.exec(v);if(R){const I=getManagedItem(R[1],v);if(I){return this.managedItemQueue.add(I,((v,I)=>{if(v)return K(v);return K(null,P(I))}))}}}for(const I of this.managedPathsWithSlash){if(v.startsWith(I)){const v=getManagedItem(I,ae);if(v){return this.managedItemQueue.add(v,((v,I)=>{if(v)return K(v);return K(null,P(I))}))}}}Ce(this.fs,ae,((v,I)=>{if(v)return K(v);const P=I;if(typeof P==="string"){return R(ae,P,K)}if(P.isFile()){return $(ae,P,K)}if(P.isDirectory()){return q(ae,P,K)}K(null,null)}))}),((v,I)=>{if(v)return ae(v);const P=K(ve,I);ae(null,P)}))}))}_readContextTimestamp(v,I){this._readContext({path:v,fromImmutablePath:()=>null,fromManagedItem:v=>({safeTime:0,timestampHash:v}),fromSymlink:(v,I,P)=>{P(null,{timestampHash:I,symlinks:new Set([I])})},fromFile:(v,I,P)=>{const R=this._fileTimestamps.get(v);if(R!==undefined)return P(null,R==="ignore"?null:R);const $=Number(I.mtime);if($)applyMtime($);const L={safeTime:$?$+Ve:Infinity,timestamp:$};this._fileTimestamps.set(v,L);this._cachedDeprecatedFileTimestamps=undefined;P(null,L)},fromDirectory:(v,I,P)=>{this.contextTimestampQueue.increaseParallelism();this._getUnresolvedContextTimestamp(v,((v,I)=>{this.contextTimestampQueue.decreaseParallelism();P(v,I)}))},reduce:(v,I)=>{let P;const R=ge(this._hashFunction);for(const I of v)R.update(I);let $=0;for(const v of I){if(!v){R.update("n");continue}const I=v;if(I.timestamp){R.update("f");R.update(`${I.timestamp}`)}else if(I.timestampHash){R.update("d");R.update(`${I.timestampHash}`)}if(I.symlinks!==undefined){if(P===undefined)P=new Set;addAll(I.symlinks,P)}if(I.safeTime){$=Math.max($,I.safeTime)}}const L=R.digest("hex");const q={safeTime:$,timestampHash:L};if(P)q.symlinks=P;return q}},((P,R)=>{if(P)return I(P);this._contextTimestamps.set(v,R);this._cachedDeprecatedContextTimestamps=undefined;I(null,R)}))}_resolveContextTimestamp(v,I){const P=[];let R=0;He(v.symlinks,10,((v,I,$)=>{this._getUnresolvedContextTimestamp(v,((v,L)=>{if(v)return $(v);if(L&&L!=="ignore"){P.push(L.timestampHash);if(L.safeTime){R=Math.max(R,L.safeTime)}if(L.symlinks!==undefined){for(const v of L.symlinks)I(v)}}$()}))}),($=>{if($)return I($);const L=ge(this._hashFunction);L.update(v.timestampHash);if(v.safeTime){R=Math.max(R,v.safeTime)}P.sort();for(const v of P){L.update(v)}I(null,v.resolved={safeTime:R,timestampHash:L.digest("hex")})}))}_readContextHash(v,I){this._readContext({path:v,fromImmutablePath:()=>"",fromManagedItem:v=>v||"",fromSymlink:(v,I,P)=>{P(null,{hash:I,symlinks:new Set([I])})},fromFile:(v,I,P)=>this.getFileHash(v,((v,I)=>{P(v,I||"")})),fromDirectory:(v,I,P)=>{this.contextHashQueue.increaseParallelism();this._getUnresolvedContextHash(v,((v,I)=>{this.contextHashQueue.decreaseParallelism();P(v,I||"")}))},reduce:(v,I)=>{let P;const R=ge(this._hashFunction);for(const I of v)R.update(I);for(const v of I){if(typeof v==="string"){R.update(v)}else{R.update(v.hash);if(v.symlinks){if(P===undefined)P=new Set;addAll(v.symlinks,P)}}}const $={hash:R.digest("hex")};if(P)$.symlinks=P;return $}},((P,R)=>{if(P)return I(P);const $=R;this._contextHashes.set(v,$);return I(null,$)}))}_resolveContextHash(v,I){const P=[];He(v.symlinks,10,((v,I,R)=>{this._getUnresolvedContextHash(v,((v,$)=>{if(v)return R(v);if($){P.push($.hash);if($.symlinks!==undefined){for(const v of $.symlinks)I(v)}}R()}))}),(R=>{if(R)return I(R);const $=ge(this._hashFunction);$.update(v.hash);P.sort();for(const v of P){$.update(v)}I(null,v.resolved=$.digest("hex"))}))}_readContextTimestampAndHash(v,I){const finalize=(P,R)=>{const $=P==="ignore"?R:{...P,...R};this._contextTshs.set(v,$);I(null,$)};const P=this._contextHashes.get(v);const R=this._contextTimestamps.get(v);if(P!==undefined){if(R!==undefined){finalize(R,P)}else{this.contextTimestampQueue.add(v,((v,R)=>{if(v)return I(v);finalize(R,P)}))}}else if(R!==undefined){this.contextHashQueue.add(v,((v,P)=>{if(v)return I(v);finalize(R,P)}))}else{this._readContext({path:v,fromImmutablePath:()=>null,fromManagedItem:v=>({safeTime:0,timestampHash:v,hash:v||""}),fromSymlink:(v,I,P)=>{P(null,{timestampHash:I,hash:I,symlinks:new Set([I])})},fromFile:(v,I,P)=>{this._getFileTimestampAndHash(v,P)},fromDirectory:(v,I,P)=>{this.contextTshQueue.increaseParallelism();this.contextTshQueue.add(v,((v,I)=>{this.contextTshQueue.decreaseParallelism();P(v,I)}))},reduce:(v,I)=>{let P;const R=ge(this._hashFunction);const $=ge(this._hashFunction);for(const I of v){R.update(I);$.update(I)}let L=0;for(const v of I){if(!v){R.update("n");continue}if(typeof v==="string"){R.update("n");$.update(v);continue}if(v.timestamp){R.update("f");R.update(`${v.timestamp}`)}else if(v.timestampHash){R.update("d");R.update(`${v.timestampHash}`)}if(v.symlinks!==undefined){if(P===undefined)P=new Set;addAll(v.symlinks,P)}if(v.safeTime){L=Math.max(L,v.safeTime)}$.update(v.hash)}const q={safeTime:L,timestampHash:R.digest("hex"),hash:$.digest("hex")};if(P)q.symlinks=P;return q}},((P,R)=>{if(P)return I(P);const $=R;this._contextTshs.set(v,$);return I(null,$)}))}}_resolveContextTsh(v,I){const P=[];const R=[];let $=0;He(v.symlinks,10,((v,I,L)=>{this._getUnresolvedContextTsh(v,((v,q)=>{if(v)return L(v);if(q){P.push(q.hash);if(q.timestampHash)R.push(q.timestampHash);if(q.safeTime){$=Math.max($,q.safeTime)}if(q.symlinks!==undefined){for(const v of q.symlinks)I(v)}}L()}))}),(L=>{if(L)return I(L);const q=ge(this._hashFunction);const K=ge(this._hashFunction);q.update(v.hash);if(v.timestampHash)K.update(v.timestampHash);if(v.safeTime){$=Math.max($,v.safeTime)}P.sort();for(const v of P){q.update(v)}R.sort();for(const v of R){K.update(v)}I(null,v.resolved={safeTime:$,timestampHash:K.digest("hex"),hash:q.digest("hex")})}))}_getManagedItemDirectoryInfo(v,I){this.fs.readdir(v,((P,R)=>{if(P){if(P.code==="ENOENT"||P.code==="ENOTDIR"){return I(null,Ke)}return I(P)}const $=new Set(R.map((I=>be(this.fs,v,I))));I(null,$)}))}_getManagedItemInfo(v,I){const P=xe(this.fs,v);this.managedItemDirectoryQueue.add(P,((P,R)=>{if(P){return I(P)}if(!R.has(v)){this._managedItems.set(v,"*missing");return I(null,"*missing")}if(v.endsWith("node_modules")&&(v.endsWith("/node_modules")||v.endsWith("\\node_modules"))){this._managedItems.set(v,"*node_modules");return I(null,"*node_modules")}const $=be(this.fs,v,"package.json");this.fs.readFile($,((P,R)=>{if(P){if(P.code==="ENOENT"||P.code==="ENOTDIR"){this.fs.readdir(v,((P,R)=>{if(!P&&R.length===1&&R[0]==="node_modules"){this._managedItems.set(v,"*nested");return I(null,"*nested")}this.logger.warn(`Managed item ${v} isn't a directory or doesn't contain a package.json (see snapshot.managedPaths option)`);return I()}));return}return I(P)}let L;try{L=JSON.parse(R.toString("utf-8"))}catch(v){return I(v)}if(!L.name){this.logger.warn(`${$} doesn't contain a "name" property (see snapshot.managedPaths option)`);return I()}const q=`${L.name||""}@${L.version||""}`;this._managedItems.set(v,q);I(null,q)}))}))}getDeprecatedFileTimestamps(){if(this._cachedDeprecatedFileTimestamps!==undefined)return this._cachedDeprecatedFileTimestamps;const v=new Map;for(const[I,P]of this._fileTimestamps){if(P)v.set(I,typeof P==="object"?P.safeTime:null)}return this._cachedDeprecatedFileTimestamps=v}getDeprecatedContextTimestamps(){if(this._cachedDeprecatedContextTimestamps!==undefined)return this._cachedDeprecatedContextTimestamps;const v=new Map;for(const[I,P]of this._contextTimestamps){if(P)v.set(I,typeof P==="object"?P.safeTime:null)}return this._cachedDeprecatedContextTimestamps=v}}v.exports=FileSystemInfo;v.exports.Snapshot=Snapshot},42568:function(v,I,P){"use strict";const{getEntryRuntime:R,mergeRuntimeOwned:$}=P(86620);const L="FlagAllModulesAsUsedPlugin";class FlagAllModulesAsUsedPlugin{constructor(v){this.explanation=v}apply(v){v.hooks.compilation.tap(L,(v=>{const I=v.moduleGraph;v.hooks.optimizeDependencies.tap(L,(P=>{let L;for(const[I,{options:P}]of v.entries){L=$(L,R(v,I,P))}for(const v of P){const P=I.getExportsInfo(v);P.setUsedInUnknownWay(L);I.addExtraReason(v,this.explanation);if(v.factoryMeta===undefined){v.factoryMeta={}}v.factoryMeta.sideEffectFree=false}}))}))}}v.exports=FlagAllModulesAsUsedPlugin},50722:function(v,I,P){"use strict";const R=P(78175);const $=P(44697);const L="FlagDependencyExportsPlugin";const q=`webpack.${L}`;class FlagDependencyExportsPlugin{apply(v){v.hooks.compilation.tap(L,(v=>{const I=v.moduleGraph;const P=v.getCache(L);v.hooks.finishModules.tapAsync(L,((L,K)=>{const ae=v.getLogger(q);let ge=0;let be=0;let xe=0;let ve=0;let Ce=0;let Ne=0;const{moduleMemCaches:He}=v;const Qe=new $;ae.time("restore cached provided exports");R.each(L,((v,R)=>{const $=I.getExportsInfo(v);if((!v.buildMeta||!v.buildMeta.exportsType)&&$.otherExportsInfo.provided!==null){xe++;$.setHasProvideInfo();$.setUnknownExportsProvided();return R()}if(typeof v.buildInfo.hash!=="string"){ve++;Qe.enqueue(v);$.setHasProvideInfo();return R()}const L=He&&He.get(v);const q=L&&L.get(this);if(q!==undefined){ge++;$.restoreProvided(q);return R()}P.get(v.identifier(),v.buildInfo.hash,((I,P)=>{if(I)return R(I);if(P!==undefined){be++;$.restoreProvided(P)}else{Ce++;Qe.enqueue(v);$.setHasProvideInfo()}R()}))}),(v=>{ae.timeEnd("restore cached provided exports");if(v)return K(v);const $=new Set;const L=new Map;let q;let Je;const Ve=new Map;let Ke=true;let Ye=false;const processDependenciesBlock=v=>{for(const I of v.dependencies){processDependency(I)}for(const I of v.blocks){processDependenciesBlock(I)}};const processDependency=v=>{const P=v.getExports(I);if(!P)return;Ve.set(v,P)};const processExportsSpec=(v,P)=>{const R=P.exports;const $=P.canMangle;const K=P.from;const ae=P.priority;const ge=P.terminalBinding||false;const be=P.dependencies;if(P.hideExports){for(const I of P.hideExports){const P=Je.getExportInfo(I);P.unsetTarget(v)}}if(R===true){if(Je.setUnknownExportsProvided($,P.excludeExports,K&&v,K,ae)){Ye=true}}else if(Array.isArray(R)){const mergeExports=(P,R)=>{for(const be of R){let R;let xe=$;let ve=ge;let Ce;let Ne=K;let He;let Qe=ae;let Je=false;if(typeof be==="string"){R=be}else{R=be.name;if(be.canMangle!==undefined)xe=be.canMangle;if(be.export!==undefined)He=be.export;if(be.exports!==undefined)Ce=be.exports;if(be.from!==undefined)Ne=be.from;if(be.priority!==undefined)Qe=be.priority;if(be.terminalBinding!==undefined)ve=be.terminalBinding;if(be.hidden!==undefined)Je=be.hidden}const Ve=P.getExportInfo(R);if(Ve.provided===false||Ve.provided===null){Ve.provided=true;Ye=true}if(Ve.canMangleProvide!==false&&xe===false){Ve.canMangleProvide=false;Ye=true}if(ve&&!Ve.terminalBinding){Ve.terminalBinding=true;Ye=true}if(Ce){const v=Ve.createNestedExportsInfo();mergeExports(v,Ce)}if(Ne&&(Je?Ve.unsetTarget(v):Ve.setTarget(v,Ne,He===undefined?[R]:He,Qe))){Ye=true}const Ke=Ve.getTarget(I);let Xe;if(Ke){const v=I.getExportsInfo(Ke.module);Xe=v.getNestedExportsInfo(Ke.export);const P=L.get(Ke.module);if(P===undefined){L.set(Ke.module,new Set([q]))}else{P.add(q)}}if(Ve.exportsInfoOwned){if(Ve.exportsInfo.setRedirectNamedTo(Xe)){Ye=true}}else if(Ve.exportsInfo!==Xe){Ve.exportsInfo=Xe;Ye=true}}};mergeExports(Je,R)}if(be){Ke=false;for(const v of be){const I=L.get(v);if(I===undefined){L.set(v,new Set([q]))}else{I.add(q)}}}};const notifyDependencies=()=>{const v=L.get(q);if(v!==undefined){for(const I of v){Qe.enqueue(I)}}};ae.time("figure out provided exports");while(Qe.length>0){q=Qe.dequeue();Ne++;Je=I.getExportsInfo(q);Ke=true;Ye=false;Ve.clear();I.freeze();processDependenciesBlock(q);I.unfreeze();for(const[v,I]of Ve){processExportsSpec(v,I)}if(Ke){$.add(q)}if(Ye){notifyDependencies()}}ae.timeEnd("figure out provided exports");ae.log(`${Math.round(100*(ve+Ce)/(ge+be+Ce+ve+xe))}% of exports of modules have been determined (${xe} no declared exports, ${Ce} not cached, ${ve} flagged uncacheable, ${be} from cache, ${ge} from mem cache, ${Ne-Ce-ve} additional calculations due to dependencies)`);ae.time("store provided exports into cache");R.each($,((v,R)=>{if(typeof v.buildInfo.hash!=="string"){return R()}const $=I.getExportsInfo(v).getRestoreProvidedData();const L=He&&He.get(v);if(L){L.set(this,$)}P.store(v.identifier(),v.buildInfo.hash,$,R)}),(v=>{ae.timeEnd("store provided exports into cache");K(v)}))}))}));const K=new WeakMap;v.hooks.rebuildModule.tap(L,(v=>{K.set(v,I.getExportsInfo(v).getRestoreProvidedData())}));v.hooks.finishRebuildingModule.tap(L,(v=>{I.getExportsInfo(v).restoreProvided(K.get(v))}))}))}}v.exports=FlagDependencyExportsPlugin},66654:function(v,I,P){"use strict";const R=P(49790);const{UsageState:$}=P(21311);const L=P(73418);const{STAGE_DEFAULT:q}=P(64152);const K=P(95112);const ae=P(11859);const{getEntryRuntime:ge,mergeRuntimeOwned:be}=P(86620);const{NO_EXPORTS_REFERENCED:xe,EXPORTS_OBJECT_REFERENCED:ve}=R;const Ce="FlagDependencyUsagePlugin";const Ne=`webpack.${Ce}`;class FlagDependencyUsagePlugin{constructor(v){this.global=v}apply(v){v.hooks.compilation.tap(Ce,(v=>{const I=v.moduleGraph;v.hooks.optimizeDependencies.tap({name:Ce,stage:q},(P=>{if(v.moduleMemCaches){throw new Error("optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect")}const R=v.getLogger(Ne);const q=new Map;const Ce=new ae;const processReferencedModule=(v,P,R,L)=>{const K=I.getExportsInfo(v);if(P.length>0){if(!v.buildMeta||!v.buildMeta.exportsType){if(K.setUsedWithoutInfo(R)){Ce.enqueue(v,R)}return}for(const I of P){let P;let L=true;if(Array.isArray(I)){P=I}else{P=I.name;L=I.canMangle!==false}if(P.length===0){if(K.setUsedInUnknownWay(R)){Ce.enqueue(v,R)}}else{let I=K;for(let ae=0;ae<P.length;ae++){const ge=I.getExportInfo(P[ae]);if(L===false){ge.canMangleUse=false}const be=ae===P.length-1;if(!be){const P=ge.getNestedExportsInfo();if(P){if(ge.setUsedConditionally((v=>v===$.Unused),$.OnlyPropertiesUsed,R)){const P=I===K?v:q.get(I);if(P){Ce.enqueue(P,R)}}I=P;continue}}if(ge.setUsedConditionally((v=>v!==$.Used),$.Used,R)){const P=I===K?v:q.get(I);if(P){Ce.enqueue(P,R)}}break}}}}else{if(!L&&v.factoryMeta!==undefined&&v.factoryMeta.sideEffectFree){return}if(K.setUsedForSideEffectsOnly(R)){Ce.enqueue(v,R)}}};const processModule=(P,R,$)=>{const q=new Map;const ae=new K;ae.enqueue(P);for(;;){const P=ae.dequeue();if(P===undefined)break;for(const v of P.blocks){if(!this.global&&v.groupOptions&&v.groupOptions.entryOptions){processModule(v,v.groupOptions.entryOptions.runtime||undefined,true)}else{ae.enqueue(v)}}for(const $ of P.dependencies){const P=I.getConnection($);if(!P||!P.module){continue}const K=P.getActiveState(R);if(K===false)continue;const{module:ae}=P;if(K===L.TRANSITIVE_ONLY){processModule(ae,R,false);continue}const ge=q.get(ae);if(ge===ve){continue}const be=v.getDependencyReferencedExports($,R);if(ge===undefined||ge===xe||be===ve){q.set(ae,be)}else if(ge!==undefined&&be===xe){continue}else{let v;if(Array.isArray(ge)){v=new Map;for(const I of ge){if(Array.isArray(I)){v.set(I.join("\n"),I)}else{v.set(I.name.join("\n"),I)}}q.set(ae,v)}else{v=ge}for(const I of be){if(Array.isArray(I)){const P=I.join("\n");const R=v.get(P);if(R===undefined){v.set(P,I)}}else{const P=I.name.join("\n");const R=v.get(P);if(R===undefined||Array.isArray(R)){v.set(P,I)}else{v.set(P,{name:I.name,canMangle:I.canMangle&&R.canMangle})}}}}}}for(const[v,I]of q){if(Array.isArray(I)){processReferencedModule(v,I,R,$)}else{processReferencedModule(v,Array.from(I.values()),R,$)}}};R.time("initialize exports usage");for(const v of P){const P=I.getExportsInfo(v);q.set(P,v);P.setHasUseInfo()}R.timeEnd("initialize exports usage");R.time("trace exports usage in graph");const processEntryDependency=(v,P)=>{const R=I.getModule(v);if(R){processReferencedModule(R,xe,P,true)}};let He;for(const[I,{dependencies:P,includeDependencies:R,options:$}]of v.entries){const L=this.global?undefined:ge(v,I,$);for(const v of P){processEntryDependency(v,L)}for(const v of R){processEntryDependency(v,L)}He=be(He,L)}for(const I of v.globalEntry.dependencies){processEntryDependency(I,He)}for(const I of v.globalEntry.includeDependencies){processEntryDependency(I,He)}while(Ce.length){const[v,I]=Ce.dequeue();processModule(v,I,false)}R.timeEnd("trace exports usage in graph")}))}))}}v.exports=FlagDependencyUsagePlugin},52402:function(v,I,P){"use strict";class Generator{static byType(v){return new ByTypeGenerator(v)}getTypes(v){const I=P(50655);throw new I}getSize(v,I){const R=P(50655);throw new R}generate(v,{dependencyTemplates:I,runtimeTemplate:R,moduleGraph:$,type:L}){const q=P(50655);throw new q}getConcatenationBailoutReason(v,I){return`Module Concatenation is not implemented for ${this.constructor.name}`}updateHash(v,{module:I,runtime:P}){}}class ByTypeGenerator extends Generator{constructor(v){super();this.map=v;this._types=new Set(Object.keys(v))}getTypes(v){return this._types}getSize(v,I="javascript"){const P=I;const R=this.map[P];return R?R.getSize(v,P):0}generate(v,I){const P=I.type;const R=this.map[P];if(!R){throw new Error(`Generator.byType: no generator specified for ${P}`)}return R.generate(v,I)}}v.exports=Generator},84017:function(v){"use strict";const connectChunkGroupAndChunk=(v,I)=>{if(v.pushChunk(I)){I.addGroup(v)}};const connectChunkGroupParentAndChild=(v,I)=>{if(v.addChild(I)){I.addParent(v)}};v.exports.connectChunkGroupAndChunk=connectChunkGroupAndChunk;v.exports.connectChunkGroupParentAndChild=connectChunkGroupParentAndChild},83403:function(v,I,P){"use strict";const R=P(94252);v.exports=class HarmonyLinkingError extends R{constructor(v){super(v);this.name="HarmonyLinkingError";this.hideStack=true}}},73404:function(v,I,P){"use strict";const R=P(94252);class HookWebpackError extends R{constructor(v,I){super(v.message);this.name="HookWebpackError";this.hook=I;this.error=v;this.hideStack=true;this.details=`caused by plugins in ${I}\n${v.stack}`;this.stack+=`\n-- inner error --\n${v.stack}`}}v.exports=HookWebpackError;const makeWebpackError=(v,I)=>{if(v instanceof R)return v;return new HookWebpackError(v,I)};v.exports.makeWebpackError=makeWebpackError;const makeWebpackErrorCallback=(v,I)=>(P,$)=>{if(P){if(P instanceof R){v(P);return}v(new HookWebpackError(P,I));return}v(null,$)};v.exports.makeWebpackErrorCallback=makeWebpackErrorCallback;const tryRunOrWebpackError=(v,I)=>{let P;try{P=v()}catch(v){if(v instanceof R){throw v}throw new HookWebpackError(v,I)}return P};v.exports.tryRunOrWebpackError=tryRunOrWebpackError},59035:function(v,I,P){"use strict";const{SyncBailHook:R}=P(84891);const{RawSource:$}=P(51255);const L=P(23630);const q=P(29327);const K=P(59336);const ae=P(32594);const ge=P(5205);const be=P(94252);const xe=P(34022);const ve=P(31894);const Ce=P(48536);const Ne=P(9897);const He=P(48242);const Qe=P(6457);const Je=P(31384);const{evaluateToIdentifier:Ve}=P(59932);const{find:Ke,isSubset:Ye}=P(81956);const Xe=P(98975);const{compareModulesById:Ze}=P(21398);const{getRuntimeKey:et,keyToRuntime:tt,forEachRuntime:nt,mergeRuntimeOwned:st,subtractRuntime:rt,intersectRuntime:ot}=P(86620);const{JAVASCRIPT_MODULE_TYPE_AUTO:it,JAVASCRIPT_MODULE_TYPE_DYNAMIC:at,JAVASCRIPT_MODULE_TYPE_ESM:ct,WEBPACK_MODULE_TYPE_RUNTIME:lt}=P(6041);const ut=new WeakMap;const pt="HotModuleReplacementPlugin";class HotModuleReplacementPlugin{static getParserHooks(v){if(!(v instanceof Je)){throw new TypeError("The 'parser' argument must be an instance of JavascriptParser")}let I=ut.get(v);if(I===undefined){I={hotAcceptCallback:new R(["expression","requests"]),hotAcceptWithoutCallback:new R(["expression","requests"])};ut.set(v,I)}return I}constructor(v){this.options=v||{}}apply(v){const{_backCompat:I}=v;if(v.options.output.strictModuleErrorHandling===undefined)v.options.output.strictModuleErrorHandling=true;const P=[ge.module];const createAcceptHandler=(v,I)=>{const{hotAcceptCallback:R,hotAcceptWithoutCallback:$}=HotModuleReplacementPlugin.getParserHooks(v);return L=>{const q=v.state.module;const K=new xe(`${q.moduleArgument}.hot.accept`,L.callee.range,P);K.loc=L.loc;q.addPresentationalDependency(K);q.buildInfo.moduleConcatenationBailout="Hot Module Replacement";if(L.arguments.length>=1){const P=v.evaluateExpression(L.arguments[0]);let K=[];if(P.isString()){K=[P]}else if(P.isArray()){K=P.items.filter((v=>v.isString()))}const ae=[];if(K.length>0){for(const[v,P]of K.entries()){const R=P.string;const $=new I(R,P.range);$.optional=true;$.loc=Object.create(L.loc);$.loc.index=v;q.addDependency($);ae.push(R)}if(L.arguments.length>1){R.call(L.arguments[1],ae);for(let I=1;I<L.arguments.length;I++){v.walkExpression(L.arguments[I])}return true}$.call(L,ae);return true}}v.walkExpressions(L.arguments);return true}};const createDeclineHandler=(v,I)=>R=>{const $=v.state.module;const L=new xe(`${$.moduleArgument}.hot.decline`,R.callee.range,P);L.loc=R.loc;$.addPresentationalDependency(L);$.buildInfo.moduleConcatenationBailout="Hot Module Replacement";if(R.arguments.length===1){const P=v.evaluateExpression(R.arguments[0]);let L=[];if(P.isString()){L=[P]}else if(P.isArray()){L=P.items.filter((v=>v.isString()))}for(const[v,P]of L.entries()){const L=new I(P.string,P.range);L.optional=true;L.loc=Object.create(R.loc);L.loc.index=v;$.addDependency(L)}}return true};const createHMRExpressionHandler=v=>I=>{const R=v.state.module;const $=new xe(`${R.moduleArgument}.hot`,I.range,P);$.loc=I.loc;R.addPresentationalDependency($);R.buildInfo.moduleConcatenationBailout="Hot Module Replacement";return true};const applyModuleHot=v=>{v.hooks.evaluateIdentifier.for("module.hot").tap({name:pt,before:"NodeStuffPlugin"},(v=>Ve("module.hot","module",(()=>["hot"]),true)(v)));v.hooks.call.for("module.hot.accept").tap(pt,createAcceptHandler(v,Ne));v.hooks.call.for("module.hot.decline").tap(pt,createDeclineHandler(v,He));v.hooks.expression.for("module.hot").tap(pt,createHMRExpressionHandler(v))};const applyImportMetaHot=v=>{v.hooks.evaluateIdentifier.for("import.meta.webpackHot").tap(pt,(v=>Ve("import.meta.webpackHot","import.meta",(()=>["webpackHot"]),true)(v)));v.hooks.call.for("import.meta.webpackHot.accept").tap(pt,createAcceptHandler(v,ve));v.hooks.call.for("import.meta.webpackHot.decline").tap(pt,createDeclineHandler(v,Ce));v.hooks.expression.for("import.meta.webpackHot").tap(pt,createHMRExpressionHandler(v))};v.hooks.compilation.tap(pt,((P,{normalModuleFactory:R})=>{if(P.compiler!==v)return;P.dependencyFactories.set(Ne,R);P.dependencyTemplates.set(Ne,new Ne.Template);P.dependencyFactories.set(He,R);P.dependencyTemplates.set(He,new He.Template);P.dependencyFactories.set(ve,R);P.dependencyTemplates.set(ve,new ve.Template);P.dependencyFactories.set(Ce,R);P.dependencyTemplates.set(Ce,new Ce.Template);let xe=0;const Je={};const Ve={};P.hooks.record.tap(pt,((v,I)=>{if(I.hash===v.hash)return;const P=v.chunkGraph;I.hash=v.hash;I.hotIndex=xe;I.fullHashChunkModuleHashes=Je;I.chunkModuleHashes=Ve;I.chunkHashes={};I.chunkRuntime={};for(const P of v.chunks){const v=P.id;I.chunkHashes[v]=P.hash;I.chunkRuntime[v]=et(P.runtime)}I.chunkModuleIds={};for(const R of v.chunks){I.chunkModuleIds[R.id]=Array.from(P.getOrderedChunkModulesIterable(R,Ze(P)),(v=>P.getModuleId(v)))}}));const ut=new Xe;const dt=new Xe;const ft=new Xe;P.hooks.fullHash.tap(pt,(v=>{const I=P.chunkGraph;const R=P.records;for(const v of P.chunks){const getModuleHash=R=>{if(P.codeGenerationResults.has(R,v.runtime)){return P.codeGenerationResults.getHash(R,v.runtime)}ft.add(R,v.runtime);return I.getModuleHash(R,v.runtime)};const $=I.getChunkFullHashModulesSet(v);if($!==undefined){for(const I of $){dt.add(I,v)}}const L=I.getChunkModulesIterable(v);if(L!==undefined){if(R.chunkModuleHashes){if($!==undefined){for(const I of L){const P=`${v.id}|${I.identifier()}`;const L=getModuleHash(I);if($.has(I)){if(R.fullHashChunkModuleHashes[P]!==L){ut.add(I,v)}Je[P]=L}else{if(R.chunkModuleHashes[P]!==L){ut.add(I,v)}Ve[P]=L}}}else{for(const I of L){const P=`${v.id}|${I.identifier()}`;const $=getModuleHash(I);if(R.chunkModuleHashes[P]!==$){ut.add(I,v)}Ve[P]=$}}}else if($!==undefined){for(const I of L){const P=`${v.id}|${I.identifier()}`;const R=getModuleHash(I);if($.has(I)){Je[P]=R}else{Ve[P]=R}}}else{for(const I of L){const P=`${v.id}|${I.identifier()}`;const R=getModuleHash(I);Ve[P]=R}}}}xe=R.hotIndex||0;if(ut.size>0)xe++;v.update(`${xe}`)}));P.hooks.processAssets.tap({name:pt,stage:q.PROCESS_ASSETS_STAGE_ADDITIONAL},(()=>{const v=P.chunkGraph;const R=P.records;if(R.hash===P.hash)return;if(!R.chunkModuleHashes||!R.chunkHashes||!R.chunkModuleIds){return}for(const[I,$]of dt){const L=`${$.id}|${I.identifier()}`;const q=ft.has(I,$.runtime)?v.getModuleHash(I,$.runtime):P.codeGenerationResults.getHash(I,$.runtime);if(R.chunkModuleHashes[L]!==q){ut.add(I,$)}Ve[L]=q}const q=new Map;let ae;for(const v of Object.keys(R.chunkRuntime)){const I=tt(R.chunkRuntime[v]);ae=st(ae,I)}nt(ae,(v=>{const{path:I,info:$}=P.getPathWithInfo(P.outputOptions.hotUpdateMainFilename,{hash:R.hash,runtime:v});q.set(v,{updatedChunkIds:new Set,removedChunkIds:new Set,removedModules:new Set,filename:I,assetInfo:$})}));if(q.size===0)return;const ge=new Map;for(const I of P.modules){const P=v.getModuleId(I);ge.set(P,I)}const xe=new Set;for(const $ of Object.keys(R.chunkHashes)){const be=tt(R.chunkRuntime[$]);const ve=[];for(const v of R.chunkModuleIds[$]){const I=ge.get(v);if(I===undefined){xe.add(v)}else{ve.push(I)}}let Ce;let Ne;let He;let Qe;let Je;let Ve;let Ye;const Xe=Ke(P.chunks,(v=>`${v.id}`===$));if(Xe){Ce=Xe.id;Ve=ot(Xe.runtime,ae);if(Ve===undefined)continue;Ne=v.getChunkModules(Xe).filter((v=>ut.has(v,Xe)));He=Array.from(v.getChunkRuntimeModulesIterable(Xe)).filter((v=>ut.has(v,Xe)));const I=v.getChunkFullHashModulesIterable(Xe);Qe=I&&Array.from(I).filter((v=>ut.has(v,Xe)));const P=v.getChunkDependentHashModulesIterable(Xe);Je=P&&Array.from(P).filter((v=>ut.has(v,Xe)));Ye=rt(be,Ve)}else{Ce=`${Number($)}`===$?Number($):$;Ye=be;Ve=be}if(Ye){nt(Ye,(v=>{const I=q.get(v);I.removedChunkIds.add(Ce)}));for(const I of ve){const L=`${$}|${I.identifier()}`;const K=R.chunkModuleHashes[L];const ae=v.getModuleRuntimes(I);if(be===Ve&&ae.has(Ve)){const R=ft.has(I,Ve)?v.getModuleHash(I,Ve):P.codeGenerationResults.getHash(I,Ve);if(R!==K){if(I.type===lt){He=He||[];He.push(I)}else{Ne=Ne||[];Ne.push(I)}}}else{nt(Ye,(v=>{for(const I of ae){if(typeof I==="string"){if(I===v)return}else if(I!==undefined&&I.has(v))return}const P=q.get(v);P.removedModules.add(I)}))}}}if(Ne&&Ne.length>0||He&&He.length>0){const $=new K;if(I)L.setChunkGraphForChunk($,v);$.id=Ce;$.runtime=Xe?Xe.runtime:Ve;if(Xe){for(const v of Xe.groupsIterable)$.addGroup(v)}v.attachModules($,Ne||[]);v.attachRuntimeModules($,He||[]);if(Qe){v.attachFullHashModules($,Qe)}if(Je){v.attachDependentHashModules($,Je)}const ae=P.getRenderManifest({chunk:$,hash:R.hash,fullHash:R.hash,outputOptions:P.outputOptions,moduleTemplates:P.moduleTemplates,dependencyTemplates:P.dependencyTemplates,codeGenerationResults:P.codeGenerationResults,runtimeTemplate:P.runtimeTemplate,moduleGraph:P.moduleGraph,chunkGraph:v});for(const v of ae){let I;let R;if("filename"in v){I=v.filename;R=v.info}else{({path:I,info:R}=P.getPathWithInfo(v.filenameTemplate,v.pathOptions))}const $=v.render();P.additionalChunkAssets.push(I);P.emitAsset(I,$,{hotModuleReplacement:true,...R});if(Xe){Xe.files.add(I);P.hooks.chunkAsset.call(Xe,I)}}nt(Ve,(v=>{const I=q.get(v);I.updatedChunkIds.add(Ce)}))}}const ve=Array.from(xe);const Ce=new Map;for(const{removedChunkIds:v,removedModules:I,updatedChunkIds:R,filename:$,assetInfo:L}of q.values()){const q=Ce.get($);if(q&&(!Ye(q.removedChunkIds,v)||!Ye(q.removedModules,I)||!Ye(q.updatedChunkIds,R))){P.warnings.push(new be(`HotModuleReplacementPlugin\nThe configured output.hotUpdateMainFilename doesn't lead to unique filenames per runtime and HMR update differs between runtimes.\nThis might lead to incorrect runtime behavior of the applied update.\nTo fix this, make sure to include [runtime] in the output.hotUpdateMainFilename option, or use the default config.`));for(const I of v)q.removedChunkIds.add(I);for(const v of I)q.removedModules.add(v);for(const v of R)q.updatedChunkIds.add(v);continue}Ce.set($,{removedChunkIds:v,removedModules:I,updatedChunkIds:R,assetInfo:L})}for(const[I,{removedChunkIds:R,removedModules:L,updatedChunkIds:q,assetInfo:K}]of Ce){const ae={c:Array.from(q),r:Array.from(R),m:L.size===0?ve:ve.concat(Array.from(L,(I=>v.getModuleId(I))))};const ge=new $(JSON.stringify(ae));P.emitAsset(I,ge,{hotModuleReplacement:true,...K})}}));P.hooks.additionalTreeRuntimeRequirements.tap(pt,((v,I)=>{I.add(ge.hmrDownloadManifest);I.add(ge.hmrDownloadUpdateHandlers);I.add(ge.interceptModuleExecution);I.add(ge.moduleCache);P.addRuntimeModule(v,new Qe)}));R.hooks.parser.for(it).tap(pt,(v=>{applyModuleHot(v);applyImportMetaHot(v)}));R.hooks.parser.for(at).tap(pt,(v=>{applyModuleHot(v)}));R.hooks.parser.for(ct).tap(pt,(v=>{applyImportMetaHot(v)}));R.hooks.module.tap(pt,(v=>{v.hot=true;return v}));ae.getCompilationHooks(P).loader.tap(pt,(v=>{v.hot=true}))}))}}v.exports=HotModuleReplacementPlugin},59336:function(v,I,P){"use strict";const R=P(56754);class HotUpdateChunk extends R{constructor(){super()}}v.exports=HotUpdateChunk},30033:function(v,I,P){"use strict";const R=P(8412);class IgnoreErrorModuleFactory extends R{constructor(v){super();this.normalModuleFactory=v}create(v,I){this.normalModuleFactory.create(v,((v,P)=>I(null,P)))}}v.exports=IgnoreErrorModuleFactory},28421:function(v,I,P){"use strict";const R=P(88490);const $=P(2932);const L=P(86750);const q=L(P(42855),(()=>P(64808)),{name:"Ignore Plugin",baseDataPath:"options"});class IgnorePlugin{constructor(v){q(v);this.options=v;this.checkIgnore=this.checkIgnore.bind(this)}checkIgnore(v){if("checkResource"in this.options&&this.options.checkResource&&this.options.checkResource(v.request,v.context)){return false}if("resourceRegExp"in this.options&&this.options.resourceRegExp&&this.options.resourceRegExp.test(v.request)){if("contextRegExp"in this.options&&this.options.contextRegExp){if(this.options.contextRegExp.test(v.context)){return false}}else{return false}}}apply(v){v.hooks.normalModuleFactory.tap("IgnorePlugin",(v=>{v.hooks.beforeResolve.tap("IgnorePlugin",(v=>{const I=this.checkIgnore(v);if(I===false&&v.dependencies.length>0&&v.dependencies[0]instanceof $){v.ignoredModule=new R("","ignored-entry-module","(ignored-entry-module)")}return I}))}));v.hooks.contextModuleFactory.tap("IgnorePlugin",(v=>{v.hooks.beforeResolve.tap("IgnorePlugin",this.checkIgnore)}))}}v.exports=IgnorePlugin},37264:function(v){"use strict";class IgnoreWarningsPlugin{constructor(v){this._ignoreWarnings=v}apply(v){v.hooks.compilation.tap("IgnoreWarningsPlugin",(v=>{v.hooks.processWarnings.tap("IgnoreWarningsPlugin",(I=>I.filter((I=>!this._ignoreWarnings.some((P=>P(I,v)))))))}))}}v.exports=IgnoreWarningsPlugin},89959:function(v,I,P){"use strict";const{ConcatSource:R}=P(51255);const $=P(65317);const extractFragmentIndex=(v,I)=>[v,I];const sortFragmentWithIndex=([v,I],[P,R])=>{const $=v.stage-P.stage;if($!==0)return $;const L=v.position-P.position;if(L!==0)return L;return I-R};class InitFragment{constructor(v,I,P,R,$){this.content=v;this.stage=I;this.position=P;this.key=R;this.endContent=$}getContent(v){return this.content}getEndContent(v){return this.endContent}static addToSource(v,I,P){if(I.length>0){const $=I.map(extractFragmentIndex).sort(sortFragmentWithIndex);const L=new Map;for(const[v]of $){if(typeof v.mergeAll==="function"){if(!v.key){throw new Error(`InitFragment with mergeAll function must have a valid key: ${v.constructor.name}`)}const I=L.get(v.key);if(I===undefined){L.set(v.key,v)}else if(Array.isArray(I)){I.push(v)}else{L.set(v.key,[I,v])}continue}else if(typeof v.merge==="function"){const I=L.get(v.key);if(I!==undefined){L.set(v.key,v.merge(I));continue}}L.set(v.key||Symbol("fragment key"),v)}const q=new R;const K=[];for(let v of L.values()){if(Array.isArray(v)){v=v[0].mergeAll(v)}q.add(v.getContent(P));const I=v.getEndContent(P);if(I){K.push(I)}}q.add(v);for(const v of K.reverse()){q.add(v)}return q}return v}serialize(v){const{write:I}=v;I(this.content);I(this.stage);I(this.position);I(this.key);I(this.endContent)}deserialize(v){const{read:I}=v;this.content=I();this.stage=I();this.position=I();this.key=I();this.endContent=I()}}$(InitFragment,"webpack/lib/InitFragment");InitFragment.prototype.merge=undefined;InitFragment.STAGE_CONSTANTS=10;InitFragment.STAGE_ASYNC_BOUNDARY=20;InitFragment.STAGE_HARMONY_EXPORTS=30;InitFragment.STAGE_HARMONY_IMPORTS=40;InitFragment.STAGE_PROVIDES=50;InitFragment.STAGE_ASYNC_DEPENDENCIES=60;InitFragment.STAGE_ASYNC_HARMONY_IMPORTS=70;v.exports=InitFragment},70870:function(v,I,P){"use strict";const R=P(94252);const $=P(65317);class InvalidDependenciesModuleWarning extends R{constructor(v,I){const P=I?Array.from(I).sort():[];const R=P.map((v=>` * ${JSON.stringify(v)}`));super(`Invalid dependencies have been reported by plugins or loaders for this module. All reported dependencies need to be absolute paths.\nInvalid dependencies may lead to broken watching and caching.\nAs best effort we try to convert all invalid values to absolute paths and converting globs into context dependencies, but this is deprecated behavior.\nLoaders: Pass absolute paths to this.addDependency (existing files), this.addMissingDependency (not existing files), and this.addContextDependency (directories).\nPlugins: Pass absolute paths to fileDependencies (existing files), missingDependencies (not existing files), and contextDependencies (directories).\nGlobs: They are not supported. Pass absolute path to the directory as context dependencies.\nThe following invalid values have been reported:\n${R.slice(0,3).join("\n")}${R.length>3?"\n * and more ...":""}`);this.name="InvalidDependenciesModuleWarning";this.details=R.slice(3).join("\n");this.module=v}}$(InvalidDependenciesModuleWarning,"webpack/lib/InvalidDependenciesModuleWarning");v.exports=InvalidDependenciesModuleWarning},127:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$,JAVASCRIPT_MODULE_TYPE_ESM:L}=P(6041);const q=P(9696);const K="JavascriptMetaInfoPlugin";class JavascriptMetaInfoPlugin{apply(v){v.hooks.compilation.tap(K,((v,{normalModuleFactory:I})=>{const handler=v=>{v.hooks.call.for("eval").tap(K,(()=>{const I=v.state.module.buildInfo;I.moduleConcatenationBailout="eval()";I.usingEval=true;const P=q.getTopLevelSymbol(v.state);if(P){q.addUsage(v.state,null,P)}else{q.bailout(v.state)}}));v.hooks.finish.tap(K,(()=>{const I=v.state.module.buildInfo;let P=I.topLevelDeclarations;if(P===undefined){P=I.topLevelDeclarations=new Set}for(const I of v.scope.definitions.asSet()){const R=v.getFreeInfoFromVariable(I);if(R===undefined){P.add(I)}}}))};I.hooks.parser.for(R).tap(K,handler);I.hooks.parser.for($).tap(K,handler);I.hooks.parser.for(L).tap(K,handler)}))}}v.exports=JavascriptMetaInfoPlugin},72853:function(v,I,P){"use strict";const R=P(78175);const $=P(2932);const{someInIterable:L}=P(57031);const{compareModulesById:q}=P(21398);const{dirname:K,mkdirp:ae}=P(80749);class LibManifestPlugin{constructor(v){this.options=v}apply(v){v.hooks.emit.tapAsync({name:"LibManifestPlugin",stage:110},((I,P)=>{const ge=I.moduleGraph;const be=new Set;R.each(Array.from(I.chunks),((P,R)=>{if(!P.canBeInitial()){R();return}const xe=I.chunkGraph;const ve=I.getPath(this.options.path,{chunk:P});if(be.has(ve)){R(new Error("each chunk must have a unique path"));return}be.add(ve);const Ce=this.options.name&&I.getPath(this.options.name,{chunk:P,contentHashType:"javascript"});const Ne=Object.create(null);for(const I of xe.getOrderedChunkModulesIterable(P,q(xe))){if(this.options.entryOnly&&!L(ge.getIncomingConnections(I),(v=>v.dependency instanceof $))){continue}const P=I.libIdent({context:this.options.context||v.options.context,associatedObjectForCache:v.root});if(P){const v=ge.getExportsInfo(I);const R=v.getProvidedExports();const $={id:xe.getModuleId(I),buildMeta:I.buildMeta,exports:Array.isArray(R)?R:undefined};Ne[P]=$}}const He={name:Ce,type:this.options.type,content:Ne};const Qe=this.options.format?JSON.stringify(He,null,2):JSON.stringify(He);const Je=Buffer.from(Qe,"utf8");const Ve=v.intermediateFileSystem;ae(Ve,K(Ve,ve),(v=>{if(v)return R(v);Ve.writeFile(ve,Je,R)}))}),P)}))}}v.exports=LibManifestPlugin},22946:function(v,I,P){"use strict";const R=P(48296);class LibraryTemplatePlugin{constructor(v,I,P,R,$){this.library={type:I||"var",name:v,umdNamedDefine:P,auxiliaryComment:R,export:$}}apply(v){const{output:I}=v.options;I.library=this.library;new R(this.library.type).apply(v)}}v.exports=LibraryTemplatePlugin},89681:function(v,I,P){"use strict";const R=P(20610);const $=P(32594);const L=P(86750);const q=L(P(37070),(()=>P(73373)),{name:"Loader Options Plugin",baseDataPath:"options"});class LoaderOptionsPlugin{constructor(v={}){q(v);if(typeof v!=="object")v={};if(!v.test){const I={test:()=>true};v.test=I}this.options=v}apply(v){const I=this.options;v.hooks.compilation.tap("LoaderOptionsPlugin",(v=>{$.getCompilationHooks(v).loader.tap("LoaderOptionsPlugin",((v,P)=>{const $=P.resource;if(!$)return;const L=$.indexOf("?");if(R.matchObject(I,L<0?$:$.slice(0,L))){for(const P of Object.keys(I)){if(P==="include"||P==="exclude"||P==="test"){continue}v[P]=I[P]}}}))}))}}v.exports=LoaderOptionsPlugin},91855:function(v,I,P){"use strict";const R=P(32594);class LoaderTargetPlugin{constructor(v){this.target=v}apply(v){v.hooks.compilation.tap("LoaderTargetPlugin",(v=>{R.getCompilationHooks(v).loader.tap("LoaderTargetPlugin",(v=>{v.target=this.target}))}))}}v.exports=LoaderTargetPlugin},16253:function(v,I,P){"use strict";const{SyncWaterfallHook:R}=P(84891);const $=P(73837);const L=P(5205);const q=P(13594);const K=q((()=>P(36926)));const ae=q((()=>P(51672)));const ge=q((()=>P(28706)));class MainTemplate{constructor(v,I){this._outputOptions=v||{};this.hooks=Object.freeze({renderManifest:{tap:$.deprecate(((v,P)=>{I.hooks.renderManifest.tap(v,((v,I)=>{if(!I.chunk.hasRuntime())return v;return P(v,I)}))}),"MainTemplate.hooks.renderManifest is deprecated (use Compilation.hooks.renderManifest instead)","DEP_WEBPACK_MAIN_TEMPLATE_RENDER_MANIFEST")},modules:{tap:()=>{throw new Error("MainTemplate.hooks.modules has been removed (there is no replacement, please create an issue to request that)")}},moduleObj:{tap:()=>{throw new Error("MainTemplate.hooks.moduleObj has been removed (there is no replacement, please create an issue to request that)")}},require:{tap:$.deprecate(((v,P)=>{K().getCompilationHooks(I).renderRequire.tap(v,P)}),"MainTemplate.hooks.require is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderRequire instead)","DEP_WEBPACK_MAIN_TEMPLATE_REQUIRE")},beforeStartup:{tap:()=>{throw new Error("MainTemplate.hooks.beforeStartup has been removed (use RuntimeGlobals.startupOnlyBefore instead)")}},startup:{tap:()=>{throw new Error("MainTemplate.hooks.startup has been removed (use RuntimeGlobals.startup instead)")}},afterStartup:{tap:()=>{throw new Error("MainTemplate.hooks.afterStartup has been removed (use RuntimeGlobals.startupOnlyAfter instead)")}},render:{tap:$.deprecate(((v,P)=>{K().getCompilationHooks(I).render.tap(v,((v,R)=>{if(R.chunkGraph.getNumberOfEntryModules(R.chunk)===0||!R.chunk.hasRuntime()){return v}return P(v,R.chunk,I.hash,I.moduleTemplates.javascript,I.dependencyTemplates)}))}),"MainTemplate.hooks.render is deprecated (use JavascriptModulesPlugin.getCompilationHooks().render instead)","DEP_WEBPACK_MAIN_TEMPLATE_RENDER")},renderWithEntry:{tap:$.deprecate(((v,P)=>{K().getCompilationHooks(I).render.tap(v,((v,R)=>{if(R.chunkGraph.getNumberOfEntryModules(R.chunk)===0||!R.chunk.hasRuntime()){return v}return P(v,R.chunk,I.hash)}))}),"MainTemplate.hooks.renderWithEntry is deprecated (use JavascriptModulesPlugin.getCompilationHooks().render instead)","DEP_WEBPACK_MAIN_TEMPLATE_RENDER_WITH_ENTRY")},assetPath:{tap:$.deprecate(((v,P)=>{I.hooks.assetPath.tap(v,P)}),"MainTemplate.hooks.assetPath is deprecated (use Compilation.hooks.assetPath instead)","DEP_WEBPACK_MAIN_TEMPLATE_ASSET_PATH"),call:$.deprecate(((v,P)=>I.getAssetPath(v,P)),"MainTemplate.hooks.assetPath is deprecated (use Compilation.hooks.assetPath instead)","DEP_WEBPACK_MAIN_TEMPLATE_ASSET_PATH")},hash:{tap:$.deprecate(((v,P)=>{I.hooks.fullHash.tap(v,P)}),"MainTemplate.hooks.hash is deprecated (use Compilation.hooks.fullHash instead)","DEP_WEBPACK_MAIN_TEMPLATE_HASH")},hashForChunk:{tap:$.deprecate(((v,P)=>{K().getCompilationHooks(I).chunkHash.tap(v,((v,I)=>{if(!v.hasRuntime())return;return P(I,v)}))}),"MainTemplate.hooks.hashForChunk is deprecated (use JavascriptModulesPlugin.getCompilationHooks().chunkHash instead)","DEP_WEBPACK_MAIN_TEMPLATE_HASH_FOR_CHUNK")},globalHashPaths:{tap:$.deprecate((()=>{}),"MainTemplate.hooks.globalHashPaths has been removed (it's no longer needed)","DEP_WEBPACK_MAIN_TEMPLATE_HASH_FOR_CHUNK")},globalHash:{tap:$.deprecate((()=>{}),"MainTemplate.hooks.globalHash has been removed (it's no longer needed)","DEP_WEBPACK_MAIN_TEMPLATE_HASH_FOR_CHUNK")},hotBootstrap:{tap:()=>{throw new Error("MainTemplate.hooks.hotBootstrap has been removed (use your own RuntimeModule instead)")}},bootstrap:new R(["source","chunk","hash","moduleTemplate","dependencyTemplates"]),localVars:new R(["source","chunk","hash"]),requireExtensions:new R(["source","chunk","hash"]),requireEnsure:new R(["source","chunk","hash","chunkIdExpression"]),get jsonpScript(){const v=ge().getCompilationHooks(I);return v.createScript},get linkPrefetch(){const v=ae().getCompilationHooks(I);return v.linkPrefetch},get linkPreload(){const v=ae().getCompilationHooks(I);return v.linkPreload}});this.renderCurrentHashCode=$.deprecate(((v,I)=>{if(I){return`${L.getFullHash} ? ${L.getFullHash}().slice(0, ${I}) : ${v.slice(0,I)}`}return`${L.getFullHash} ? ${L.getFullHash}() : ${v}`}),"MainTemplate.renderCurrentHashCode is deprecated (use RuntimeGlobals.getFullHash runtime function instead)","DEP_WEBPACK_MAIN_TEMPLATE_RENDER_CURRENT_HASH_CODE");this.getPublicPath=$.deprecate((v=>I.getAssetPath(I.outputOptions.publicPath,v)),"MainTemplate.getPublicPath is deprecated (use Compilation.getAssetPath(compilation.outputOptions.publicPath, options) instead)","DEP_WEBPACK_MAIN_TEMPLATE_GET_PUBLIC_PATH");this.getAssetPath=$.deprecate(((v,P)=>I.getAssetPath(v,P)),"MainTemplate.getAssetPath is deprecated (use Compilation.getAssetPath instead)","DEP_WEBPACK_MAIN_TEMPLATE_GET_ASSET_PATH");this.getAssetPathWithInfo=$.deprecate(((v,P)=>I.getAssetPathWithInfo(v,P)),"MainTemplate.getAssetPathWithInfo is deprecated (use Compilation.getAssetPath instead)","DEP_WEBPACK_MAIN_TEMPLATE_GET_ASSET_PATH_WITH_INFO")}}Object.defineProperty(MainTemplate.prototype,"requireFn",{get:$.deprecate((()=>L.require),`MainTemplate.requireFn is deprecated (use "${L.require}")`,"DEP_WEBPACK_MAIN_TEMPLATE_REQUIRE_FN")});Object.defineProperty(MainTemplate.prototype,"outputOptions",{get:$.deprecate((function(){return this._outputOptions}),"MainTemplate.outputOptions is deprecated (use Compilation.outputOptions instead)","DEP_WEBPACK_MAIN_TEMPLATE_OUTPUT_OPTIONS")});v.exports=MainTemplate},34803:function(v,I,P){"use strict";const R=P(73837);const $=P(23630);const L=P(98733);const q=P(48101);const{JS_TYPES:K}=P(30021);const ae=P(5205);const{first:ge}=P(81956);const{compareChunksById:be}=P(21398);const xe=P(65317);const ve={};let Ce=1e3;const Ne=new Set(["unknown"]);const He=R.deprecate(((v,I)=>v.needRebuild(I.fileSystemInfo.getDeprecatedFileTimestamps(),I.fileSystemInfo.getDeprecatedContextTimestamps())),"Module.needRebuild is deprecated in favor of Module.needBuild","DEP_WEBPACK_MODULE_NEED_REBUILD");class Module extends L{constructor(v,I=null,P=null){super();this.type=v;this.context=I;this.layer=P;this.needId=true;this.debugId=Ce++;this.resolveOptions=ve;this.factoryMeta=undefined;this.useSourceMap=false;this.useSimpleSourceMap=false;this.hot=false;this._warnings=undefined;this._errors=undefined;this.buildMeta=undefined;this.buildInfo=undefined;this.presentationalDependencies=undefined;this.codeGenerationDependencies=undefined}get id(){return $.getChunkGraphForModule(this,"Module.id","DEP_WEBPACK_MODULE_ID").getModuleId(this)}set id(v){if(v===""){this.needId=false;return}$.getChunkGraphForModule(this,"Module.id","DEP_WEBPACK_MODULE_ID").setModuleId(this,v)}get hash(){return $.getChunkGraphForModule(this,"Module.hash","DEP_WEBPACK_MODULE_HASH").getModuleHash(this,undefined)}get renderedHash(){return $.getChunkGraphForModule(this,"Module.renderedHash","DEP_WEBPACK_MODULE_RENDERED_HASH").getRenderedModuleHash(this,undefined)}get profile(){return q.getModuleGraphForModule(this,"Module.profile","DEP_WEBPACK_MODULE_PROFILE").getProfile(this)}set profile(v){q.getModuleGraphForModule(this,"Module.profile","DEP_WEBPACK_MODULE_PROFILE").setProfile(this,v)}get index(){return q.getModuleGraphForModule(this,"Module.index","DEP_WEBPACK_MODULE_INDEX").getPreOrderIndex(this)}set index(v){q.getModuleGraphForModule(this,"Module.index","DEP_WEBPACK_MODULE_INDEX").setPreOrderIndex(this,v)}get index2(){return q.getModuleGraphForModule(this,"Module.index2","DEP_WEBPACK_MODULE_INDEX2").getPostOrderIndex(this)}set index2(v){q.getModuleGraphForModule(this,"Module.index2","DEP_WEBPACK_MODULE_INDEX2").setPostOrderIndex(this,v)}get depth(){return q.getModuleGraphForModule(this,"Module.depth","DEP_WEBPACK_MODULE_DEPTH").getDepth(this)}set depth(v){q.getModuleGraphForModule(this,"Module.depth","DEP_WEBPACK_MODULE_DEPTH").setDepth(this,v)}get issuer(){return q.getModuleGraphForModule(this,"Module.issuer","DEP_WEBPACK_MODULE_ISSUER").getIssuer(this)}set issuer(v){q.getModuleGraphForModule(this,"Module.issuer","DEP_WEBPACK_MODULE_ISSUER").setIssuer(this,v)}get usedExports(){return q.getModuleGraphForModule(this,"Module.usedExports","DEP_WEBPACK_MODULE_USED_EXPORTS").getUsedExports(this,undefined)}get optimizationBailout(){return q.getModuleGraphForModule(this,"Module.optimizationBailout","DEP_WEBPACK_MODULE_OPTIMIZATION_BAILOUT").getOptimizationBailout(this)}get optional(){return this.isOptional(q.getModuleGraphForModule(this,"Module.optional","DEP_WEBPACK_MODULE_OPTIONAL"))}addChunk(v){const I=$.getChunkGraphForModule(this,"Module.addChunk","DEP_WEBPACK_MODULE_ADD_CHUNK");if(I.isModuleInChunk(this,v))return false;I.connectChunkAndModule(v,this);return true}removeChunk(v){return $.getChunkGraphForModule(this,"Module.removeChunk","DEP_WEBPACK_MODULE_REMOVE_CHUNK").disconnectChunkAndModule(v,this)}isInChunk(v){return $.getChunkGraphForModule(this,"Module.isInChunk","DEP_WEBPACK_MODULE_IS_IN_CHUNK").isModuleInChunk(this,v)}isEntryModule(){return $.getChunkGraphForModule(this,"Module.isEntryModule","DEP_WEBPACK_MODULE_IS_ENTRY_MODULE").isEntryModule(this)}getChunks(){return $.getChunkGraphForModule(this,"Module.getChunks","DEP_WEBPACK_MODULE_GET_CHUNKS").getModuleChunks(this)}getNumberOfChunks(){return $.getChunkGraphForModule(this,"Module.getNumberOfChunks","DEP_WEBPACK_MODULE_GET_NUMBER_OF_CHUNKS").getNumberOfModuleChunks(this)}get chunksIterable(){return $.getChunkGraphForModule(this,"Module.chunksIterable","DEP_WEBPACK_MODULE_CHUNKS_ITERABLE").getOrderedModuleChunksIterable(this,be)}isProvided(v){return q.getModuleGraphForModule(this,"Module.usedExports","DEP_WEBPACK_MODULE_USED_EXPORTS").isExportProvided(this,v)}get exportsArgument(){return this.buildInfo&&this.buildInfo.exportsArgument||"exports"}get moduleArgument(){return this.buildInfo&&this.buildInfo.moduleArgument||"module"}getExportsType(v,I){switch(this.buildMeta&&this.buildMeta.exportsType){case"flagged":return I?"default-with-named":"namespace";case"namespace":return"namespace";case"default":switch(this.buildMeta.defaultObject){case"redirect":return"default-with-named";case"redirect-warn":return I?"default-only":"default-with-named";default:return"default-only"}case"dynamic":{if(I)return"default-with-named";const handleDefault=()=>{switch(this.buildMeta.defaultObject){case"redirect":case"redirect-warn":return"default-with-named";default:return"default-only"}};const P=v.getReadOnlyExportInfo(this,"__esModule");if(P.provided===false){return handleDefault()}const R=P.getTarget(v);if(!R||!R.export||R.export.length!==1||R.export[0]!=="__esModule"){return"dynamic"}switch(R.module.buildMeta&&R.module.buildMeta.exportsType){case"flagged":case"namespace":return"namespace";case"default":return handleDefault();default:return"dynamic"}}default:return I?"default-with-named":"dynamic"}}addPresentationalDependency(v){if(this.presentationalDependencies===undefined){this.presentationalDependencies=[]}this.presentationalDependencies.push(v)}addCodeGenerationDependency(v){if(this.codeGenerationDependencies===undefined){this.codeGenerationDependencies=[]}this.codeGenerationDependencies.push(v)}clearDependenciesAndBlocks(){if(this.presentationalDependencies!==undefined){this.presentationalDependencies.length=0}if(this.codeGenerationDependencies!==undefined){this.codeGenerationDependencies.length=0}super.clearDependenciesAndBlocks()}addWarning(v){if(this._warnings===undefined){this._warnings=[]}this._warnings.push(v)}getWarnings(){return this._warnings}getNumberOfWarnings(){return this._warnings!==undefined?this._warnings.length:0}addError(v){if(this._errors===undefined){this._errors=[]}this._errors.push(v)}getErrors(){return this._errors}getNumberOfErrors(){return this._errors!==undefined?this._errors.length:0}clearWarningsAndErrors(){if(this._warnings!==undefined){this._warnings.length=0}if(this._errors!==undefined){this._errors.length=0}}isOptional(v){let I=false;for(const P of v.getIncomingConnections(this)){if(!P.dependency||!P.dependency.optional||!P.isTargetActive(undefined)){return false}I=true}return I}isAccessibleInChunk(v,I,P){for(const P of I.groupsIterable){if(!this.isAccessibleInChunkGroup(v,P))return false}return true}isAccessibleInChunkGroup(v,I,P){const R=new Set([I]);e:for(const $ of R){for(const I of $.chunks){if(I!==P&&v.isModuleInChunk(this,I))continue e}if(I.isInitial())return false;for(const v of I.parentsIterable)R.add(v)}return true}hasReasonForChunk(v,I,P){for(const[R,$]of I.getIncomingConnectionsByOriginModule(this)){if(!$.some((I=>I.isTargetActive(v.runtime))))continue;for(const I of P.getModuleChunksIterable(R)){if(!this.isAccessibleInChunk(P,I,v))return true}}return false}hasReasons(v,I){for(const P of v.getIncomingConnections(this)){if(P.isTargetActive(I))return true}return false}toString(){return`Module[${this.debugId}: ${this.identifier()}]`}needBuild(v,I){I(null,!this.buildMeta||this.needRebuild===Module.prototype.needRebuild||He(this,v))}needRebuild(v,I){return true}updateHash(v,I={chunkGraph:$.getChunkGraphForModule(this,"Module.updateHash","DEP_WEBPACK_MODULE_UPDATE_HASH"),runtime:undefined}){const{chunkGraph:P,runtime:R}=I;v.update(P.getModuleGraphHash(this,R));if(this.presentationalDependencies!==undefined){for(const P of this.presentationalDependencies){P.updateHash(v,I)}}super.updateHash(v,I)}invalidateBuild(){}identifier(){const v=P(50655);throw new v}readableIdentifier(v){const I=P(50655);throw new I}build(v,I,R,$,L){const q=P(50655);throw new q}getSourceTypes(){if(this.source===Module.prototype.source){return Ne}return K}source(v,I,R="javascript"){if(this.codeGeneration===Module.prototype.codeGeneration){const v=P(50655);throw new v}const L=$.getChunkGraphForModule(this,"Module.source() is deprecated. Use Compilation.codeGenerationResults.getSource(module, runtime, type) instead","DEP_WEBPACK_MODULE_SOURCE");const q={dependencyTemplates:v,runtimeTemplate:I,moduleGraph:L.moduleGraph,chunkGraph:L,runtime:undefined,codeGenerationResults:undefined};const K=this.codeGeneration(q).sources;return R?K.get(R):K.get(ge(this.getSourceTypes()))}size(v){const I=P(50655);throw new I}libIdent(v){return null}nameForCondition(){return null}getConcatenationBailoutReason(v){return`Module Concatenation is not implemented for ${this.constructor.name}`}getSideEffectsConnectionState(v){return true}codeGeneration(v){const I=new Map;for(const P of this.getSourceTypes()){if(P!=="unknown"){I.set(P,this.source(v.dependencyTemplates,v.runtimeTemplate,P))}}return{sources:I,runtimeRequirements:new Set([ae.module,ae.exports,ae.require])}}chunkCondition(v,I){return true}hasChunkCondition(){return this.chunkCondition!==Module.prototype.chunkCondition}updateCacheModule(v){this.type=v.type;this.layer=v.layer;this.context=v.context;this.factoryMeta=v.factoryMeta;this.resolveOptions=v.resolveOptions}getUnsafeCacheData(){return{factoryMeta:this.factoryMeta,resolveOptions:this.resolveOptions}}_restoreFromUnsafeCache(v,I){this.factoryMeta=v.factoryMeta;this.resolveOptions=v.resolveOptions}cleanupForCache(){this.factoryMeta=undefined;this.resolveOptions=undefined}originalSource(){return null}addCacheDependencies(v,I,P,R){}serialize(v){const{write:I}=v;I(this.type);I(this.layer);I(this.context);I(this.resolveOptions);I(this.factoryMeta);I(this.useSourceMap);I(this.useSimpleSourceMap);I(this.hot);I(this._warnings!==undefined&&this._warnings.length===0?undefined:this._warnings);I(this._errors!==undefined&&this._errors.length===0?undefined:this._errors);I(this.buildMeta);I(this.buildInfo);I(this.presentationalDependencies);I(this.codeGenerationDependencies);super.serialize(v)}deserialize(v){const{read:I}=v;this.type=I();this.layer=I();this.context=I();this.resolveOptions=I();this.factoryMeta=I();this.useSourceMap=I();this.useSimpleSourceMap=I();this.hot=I();this._warnings=I();this._errors=I();this.buildMeta=I();this.buildInfo=I();this.presentationalDependencies=I();this.codeGenerationDependencies=I();super.deserialize(v)}}xe(Module,"webpack/lib/Module");Object.defineProperty(Module.prototype,"hasEqualsChunks",{get(){throw new Error("Module.hasEqualsChunks was renamed (use hasEqualChunks instead)")}});Object.defineProperty(Module.prototype,"isUsed",{get(){throw new Error("Module.isUsed was renamed (use getUsedName, isExportUsed or isModuleUsed instead)")}});Object.defineProperty(Module.prototype,"errors",{get:R.deprecate((function(){if(this._errors===undefined){this._errors=[]}return this._errors}),"Module.errors was removed (use getErrors instead)","DEP_WEBPACK_MODULE_ERRORS")});Object.defineProperty(Module.prototype,"warnings",{get:R.deprecate((function(){if(this._warnings===undefined){this._warnings=[]}return this._warnings}),"Module.warnings was removed (use getWarnings instead)","DEP_WEBPACK_MODULE_WARNINGS")});Object.defineProperty(Module.prototype,"used",{get(){throw new Error("Module.used was refactored (use ModuleGraph.getUsedExports instead)")},set(v){throw new Error("Module.used was refactored (use ModuleGraph.setUsedExports instead)")}});v.exports=Module},63090:function(v,I,P){"use strict";const{cutOffLoaderExecution:R}=P(35199);const $=P(94252);const L=P(65317);class ModuleBuildError extends ${constructor(v,{from:I=null}={}){let P="Module build failed";let $;P+=I?` (from ${I}):\n`:": ";if(v!==null&&typeof v==="object"){if(typeof v.stack==="string"&&v.stack){const I=R(v.stack);if(!v.hideStack){P+=I}else{$=I;P+=typeof v.message==="string"&&v.message?v.message:v}}else if(typeof v.message==="string"&&v.message){P+=v.message}else{P+=String(v)}}else{P+=String(v)}super(P);this.name="ModuleBuildError";this.details=$;this.error=v}serialize(v){const{write:I}=v;I(this.error);super.serialize(v)}deserialize(v){const{read:I}=v;this.error=I();super.deserialize(v)}}L(ModuleBuildError,"webpack/lib/ModuleBuildError");v.exports=ModuleBuildError},6171:function(v,I,P){"use strict";const R=P(94252);class ModuleDependencyError extends R{constructor(v,I,P){super(I.message);this.name="ModuleDependencyError";this.details=I&&!I.hideStack?I.stack.split("\n").slice(1).join("\n"):undefined;this.module=v;this.loc=P;this.error=I;if(I&&I.hideStack&&I.stack){this.stack=`${I.stack.split("\n").slice(1).join("\n")}\n\n${this.stack}`}}}v.exports=ModuleDependencyError},96868:function(v,I,P){"use strict";const R=P(94252);const $=P(65317);class ModuleDependencyWarning extends R{constructor(v,I,P){super(I?I.message:"");this.name="ModuleDependencyWarning";this.details=I&&!I.hideStack?I.stack.split("\n").slice(1).join("\n"):undefined;this.module=v;this.loc=P;this.error=I;if(I&&I.hideStack&&I.stack){this.stack=`${I.stack.split("\n").slice(1).join("\n")}\n\n${this.stack}`}}}$(ModuleDependencyWarning,"webpack/lib/ModuleDependencyWarning");v.exports=ModuleDependencyWarning},73716:function(v,I,P){"use strict";const{cleanUp:R}=P(35199);const $=P(94252);const L=P(65317);class ModuleError extends ${constructor(v,{from:I=null}={}){let P="Module Error";P+=I?` (from ${I}):\n`:": ";if(v&&typeof v==="object"&&v.message){P+=v.message}else if(v){P+=v}super(P);this.name="ModuleError";this.error=v;this.details=v&&typeof v==="object"&&v.stack?R(v.stack,this.message):undefined}serialize(v){const{write:I}=v;I(this.error);super.serialize(v)}deserialize(v){const{read:I}=v;this.error=I();super.deserialize(v)}}L(ModuleError,"webpack/lib/ModuleError");v.exports=ModuleError},8412:function(v,I,P){"use strict";class ModuleFactory{create(v,I){const R=P(50655);throw new R}}v.exports=ModuleFactory},20610:function(v,I,P){"use strict";const R=P(32594);const $=P(12471);const L=P(13594);const q=v.exports;q.ALL_LOADERS_RESOURCE="[all-loaders][resource]";q.REGEXP_ALL_LOADERS_RESOURCE=/\[all-?loaders\]\[resource\]/gi;q.LOADERS_RESOURCE="[loaders][resource]";q.REGEXP_LOADERS_RESOURCE=/\[loaders\]\[resource\]/gi;q.RESOURCE="[resource]";q.REGEXP_RESOURCE=/\[resource\]/gi;q.ABSOLUTE_RESOURCE_PATH="[absolute-resource-path]";q.REGEXP_ABSOLUTE_RESOURCE_PATH=/\[abs(olute)?-?resource-?path\]/gi;q.RESOURCE_PATH="[resource-path]";q.REGEXP_RESOURCE_PATH=/\[resource-?path\]/gi;q.ALL_LOADERS="[all-loaders]";q.REGEXP_ALL_LOADERS=/\[all-?loaders\]/gi;q.LOADERS="[loaders]";q.REGEXP_LOADERS=/\[loaders\]/gi;q.QUERY="[query]";q.REGEXP_QUERY=/\[query\]/gi;q.ID="[id]";q.REGEXP_ID=/\[id\]/gi;q.HASH="[hash]";q.REGEXP_HASH=/\[hash\]/gi;q.NAMESPACE="[namespace]";q.REGEXP_NAMESPACE=/\[namespace\]/gi;const getAfter=(v,I)=>()=>{const P=v();const R=P.indexOf(I);return R<0?"":P.slice(R)};const getBefore=(v,I)=>()=>{const P=v();const R=P.lastIndexOf(I);return R<0?"":P.slice(0,R)};const getHash=(v,I="md4")=>()=>{const P=$(I);P.update(v());const R=P.digest("hex");return R.slice(0,4)};const lazyObject=v=>{const I={};for(const P of Object.keys(v)){const R=v[P];Object.defineProperty(I,P,{get:()=>R(),set:v=>{Object.defineProperty(I,P,{value:v,enumerable:true,writable:true})},enumerable:true,configurable:true})}return I};const K=/\[\\*([\w-]+)\\*\]/gi;q.createFilename=(v="",I,{requestShortener:P,chunkGraph:$,hashFunction:ae="md4"})=>{const ge={namespace:"",moduleFilenameTemplate:"",...typeof I==="object"?I:{moduleFilenameTemplate:I}};let be;let xe;let ve;let Ce;let Ne;if(typeof v==="string"){Ne=L((()=>P.shorten(v)));ve=Ne;Ce=()=>"";be=()=>v.split("!").pop();xe=getHash(ve,ae)}else{Ne=L((()=>v.readableIdentifier(P)));ve=L((()=>P.shorten(v.identifier())));Ce=()=>$.getModuleId(v);be=()=>v instanceof R?v.resource:v.identifier().split("!").pop();xe=getHash(ve,ae)}const He=L((()=>Ne().split("!").pop()));const Qe=getBefore(Ne,"!");const Je=getBefore(ve,"!");const Ve=getAfter(He,"?");const resourcePath=()=>{const v=Ve().length;return v===0?He():He().slice(0,-v)};if(typeof ge.moduleFilenameTemplate==="function"){return ge.moduleFilenameTemplate(lazyObject({identifier:ve,shortIdentifier:Ne,resource:He,resourcePath:L(resourcePath),absoluteResourcePath:L(be),loaders:L(Qe),allLoaders:L(Je),query:L(Ve),moduleId:L(Ce),hash:L(xe),namespace:()=>ge.namespace}))}const Ke=new Map([["identifier",ve],["short-identifier",Ne],["resource",He],["resource-path",resourcePath],["resourcepath",resourcePath],["absolute-resource-path",be],["abs-resource-path",be],["absoluteresource-path",be],["absresource-path",be],["absolute-resourcepath",be],["abs-resourcepath",be],["absoluteresourcepath",be],["absresourcepath",be],["all-loaders",Je],["allloaders",Je],["loaders",Qe],["query",Ve],["id",Ce],["hash",xe],["namespace",()=>ge.namespace]]);return ge.moduleFilenameTemplate.replace(q.REGEXP_ALL_LOADERS_RESOURCE,"[identifier]").replace(q.REGEXP_LOADERS_RESOURCE,"[short-identifier]").replace(K,((v,I)=>{if(I.length+2===v.length){const v=Ke.get(I.toLowerCase());if(v!==undefined){return v()}}else if(v.startsWith("[\\")&&v.endsWith("\\]")){return`[${v.slice(2,-2)}]`}return v}))};q.replaceDuplicates=(v,I,P)=>{const R=Object.create(null);const $=Object.create(null);for(const[I,P]of v.entries()){R[P]=R[P]||[];R[P].push(I);$[P]=0}if(P){for(const v of Object.keys(R)){R[v].sort(P)}}return v.map(((v,L)=>{if(R[v].length>1){if(P&&R[v][0]===L)return v;return I(v,L,$[v]++)}return v}))};const matchPart=(v,I)=>{if(!I)return true;if(Array.isArray(I)){return I.some((I=>matchPart(v,I)))}if(typeof I==="string"){return v.startsWith(I)}return I.test(v)};q.matchPart=matchPart;q.matchObject=(v,I)=>{if(v.test&&!q.matchPart(I,v.test)){return false}if(v.include&&!q.matchPart(I,v.include)){return false}if(v.exclude&&q.matchPart(I,v.exclude)){return false}return true}},48101:function(v,I,P){"use strict";const R=P(73837);const $=P(21311);const L=P(73418);const q=P(6022);const K=P(97599);const ae=new Set;const getConnectionsByOriginModule=v=>{const I=new Map;let P=0;let R;for(const $ of v){const{originModule:v}=$;if(P===v){R.push($)}else{P=v;const L=I.get(v);if(L!==undefined){R=L;L.push($)}else{const P=[$];R=P;I.set(v,P)}}}return I};const getConnectionsByModule=v=>{const I=new Map;let P=0;let R;for(const $ of v){const{module:v}=$;if(P===v){R.push($)}else{P=v;const L=I.get(v);if(L!==undefined){R=L;L.push($)}else{const P=[$];R=P;I.set(v,P)}}}return I};class ModuleGraphModule{constructor(){this.incomingConnections=new q;this.outgoingConnections=undefined;this.issuer=undefined;this.optimizationBailout=[];this.exports=new $;this.preOrderIndex=null;this.postOrderIndex=null;this.depth=null;this.profile=undefined;this.async=false;this._unassignedConnections=undefined}}class ModuleGraph{constructor(){this._dependencyMap=new WeakMap;this._moduleMap=new Map;this._metaMap=new WeakMap;this._cache=undefined;this._moduleMemCaches=undefined;this._cacheStage=undefined}_getModuleGraphModule(v){let I=this._moduleMap.get(v);if(I===undefined){I=new ModuleGraphModule;this._moduleMap.set(v,I)}return I}setParents(v,I,P,R=-1){v._parentDependenciesBlockIndex=R;v._parentDependenciesBlock=I;v._parentModule=P}getParentModule(v){return v._parentModule}getParentBlock(v){return v._parentDependenciesBlock}getParentBlockIndex(v){return v._parentDependenciesBlockIndex}setResolvedModule(v,I,P){const R=new L(v,I,P,undefined,I.weak,I.getCondition(this));const $=this._getModuleGraphModule(P).incomingConnections;$.add(R);if(v){const I=this._getModuleGraphModule(v);if(I._unassignedConnections===undefined){I._unassignedConnections=[]}I._unassignedConnections.push(R);if(I.outgoingConnections===undefined){I.outgoingConnections=new q}I.outgoingConnections.add(R)}else{this._dependencyMap.set(I,R)}}updateModule(v,I){const P=this.getConnection(v);if(P.module===I)return;const R=P.clone();R.module=I;this._dependencyMap.set(v,R);P.setActive(false);const $=this._getModuleGraphModule(P.originModule);$.outgoingConnections.add(R);const L=this._getModuleGraphModule(I);L.incomingConnections.add(R)}removeConnection(v){const I=this.getConnection(v);const P=this._getModuleGraphModule(I.module);P.incomingConnections.delete(I);const R=this._getModuleGraphModule(I.originModule);R.outgoingConnections.delete(I);this._dependencyMap.set(v,null)}addExplanation(v,I){const P=this.getConnection(v);P.addExplanation(I)}cloneModuleAttributes(v,I){const P=this._getModuleGraphModule(v);const R=this._getModuleGraphModule(I);R.postOrderIndex=P.postOrderIndex;R.preOrderIndex=P.preOrderIndex;R.depth=P.depth;R.exports=P.exports;R.async=P.async}removeModuleAttributes(v){const I=this._getModuleGraphModule(v);I.postOrderIndex=null;I.preOrderIndex=null;I.depth=null;I.async=false}removeAllModuleAttributes(){for(const v of this._moduleMap.values()){v.postOrderIndex=null;v.preOrderIndex=null;v.depth=null;v.async=false}}moveModuleConnections(v,I,P){if(v===I)return;const R=this._getModuleGraphModule(v);const $=this._getModuleGraphModule(I);const L=R.outgoingConnections;if(L!==undefined){if($.outgoingConnections===undefined){$.outgoingConnections=new q}const v=$.outgoingConnections;for(const R of L){if(P(R)){R.originModule=I;v.add(R);L.delete(R)}}}const K=R.incomingConnections;const ae=$.incomingConnections;for(const v of K){if(P(v)){v.module=I;ae.add(v);K.delete(v)}}}copyOutgoingModuleConnections(v,I,P){if(v===I)return;const R=this._getModuleGraphModule(v);const $=this._getModuleGraphModule(I);const L=R.outgoingConnections;if(L!==undefined){if($.outgoingConnections===undefined){$.outgoingConnections=new q}const v=$.outgoingConnections;for(const R of L){if(P(R)){const P=R.clone();P.originModule=I;v.add(P);if(P.module!==undefined){const v=this._getModuleGraphModule(P.module);v.incomingConnections.add(P)}}}}}addExtraReason(v,I){const P=this._getModuleGraphModule(v).incomingConnections;P.add(new L(null,null,v,I))}getResolvedModule(v){const I=this.getConnection(v);return I!==undefined?I.resolvedModule:null}getConnection(v){const I=this._dependencyMap.get(v);if(I===undefined){const I=this.getParentModule(v);if(I!==undefined){const P=this._getModuleGraphModule(I);if(P._unassignedConnections&&P._unassignedConnections.length!==0){let I;for(const R of P._unassignedConnections){this._dependencyMap.set(R.dependency,R);if(R.dependency===v)I=R}P._unassignedConnections.length=0;if(I!==undefined){return I}}}this._dependencyMap.set(v,null);return}return I===null?undefined:I}getModule(v){const I=this.getConnection(v);return I!==undefined?I.module:null}getOrigin(v){const I=this.getConnection(v);return I!==undefined?I.originModule:null}getResolvedOrigin(v){const I=this.getConnection(v);return I!==undefined?I.resolvedOriginModule:null}getIncomingConnections(v){const I=this._getModuleGraphModule(v).incomingConnections;return I}getOutgoingConnections(v){const I=this._getModuleGraphModule(v).outgoingConnections;return I===undefined?ae:I}getIncomingConnectionsByOriginModule(v){const I=this._getModuleGraphModule(v).incomingConnections;return I.getFromUnorderedCache(getConnectionsByOriginModule)}getOutgoingConnectionsByModule(v){const I=this._getModuleGraphModule(v).outgoingConnections;return I===undefined?undefined:I.getFromUnorderedCache(getConnectionsByModule)}getProfile(v){const I=this._getModuleGraphModule(v);return I.profile}setProfile(v,I){const P=this._getModuleGraphModule(v);P.profile=I}getIssuer(v){const I=this._getModuleGraphModule(v);return I.issuer}setIssuer(v,I){const P=this._getModuleGraphModule(v);P.issuer=I}setIssuerIfUnset(v,I){const P=this._getModuleGraphModule(v);if(P.issuer===undefined)P.issuer=I}getOptimizationBailout(v){const I=this._getModuleGraphModule(v);return I.optimizationBailout}getProvidedExports(v){const I=this._getModuleGraphModule(v);return I.exports.getProvidedExports()}isExportProvided(v,I){const P=this._getModuleGraphModule(v);const R=P.exports.isExportProvided(I);return R===undefined?null:R}getExportsInfo(v){const I=this._getModuleGraphModule(v);return I.exports}getExportInfo(v,I){const P=this._getModuleGraphModule(v);return P.exports.getExportInfo(I)}getReadOnlyExportInfo(v,I){const P=this._getModuleGraphModule(v);return P.exports.getReadOnlyExportInfo(I)}getUsedExports(v,I){const P=this._getModuleGraphModule(v);return P.exports.getUsedExports(I)}getPreOrderIndex(v){const I=this._getModuleGraphModule(v);return I.preOrderIndex}getPostOrderIndex(v){const I=this._getModuleGraphModule(v);return I.postOrderIndex}setPreOrderIndex(v,I){const P=this._getModuleGraphModule(v);P.preOrderIndex=I}setPreOrderIndexIfUnset(v,I){const P=this._getModuleGraphModule(v);if(P.preOrderIndex===null){P.preOrderIndex=I;return true}return false}setPostOrderIndex(v,I){const P=this._getModuleGraphModule(v);P.postOrderIndex=I}setPostOrderIndexIfUnset(v,I){const P=this._getModuleGraphModule(v);if(P.postOrderIndex===null){P.postOrderIndex=I;return true}return false}getDepth(v){const I=this._getModuleGraphModule(v);return I.depth}setDepth(v,I){const P=this._getModuleGraphModule(v);P.depth=I}setDepthIfLower(v,I){const P=this._getModuleGraphModule(v);if(P.depth===null||P.depth>I){P.depth=I;return true}return false}isAsync(v){const I=this._getModuleGraphModule(v);return I.async}setAsync(v){const I=this._getModuleGraphModule(v);I.async=true}getMeta(v){let I=this._metaMap.get(v);if(I===undefined){I=Object.create(null);this._metaMap.set(v,I)}return I}getMetaIfExisting(v){return this._metaMap.get(v)}freeze(v){this._cache=new K;this._cacheStage=v}unfreeze(){this._cache=undefined;this._cacheStage=undefined}cached(v,...I){if(this._cache===undefined)return v(this,...I);return this._cache.provide(v,...I,(()=>v(this,...I)))}setModuleMemCaches(v){this._moduleMemCaches=v}dependencyCacheProvide(v,...I){const P=I.pop();if(this._moduleMemCaches&&this._cacheStage){const R=this._moduleMemCaches.get(this.getParentModule(v));if(R!==undefined){return R.provide(v,this._cacheStage,...I,(()=>P(this,v,...I)))}}if(this._cache===undefined)return P(this,v,...I);return this._cache.provide(v,...I,(()=>P(this,v,...I)))}static getModuleGraphForModule(v,I,P){const $=be.get(I);if($)return $(v);const L=R.deprecate((v=>{const P=ge.get(v);if(!P)throw new Error(`${I}There was no ModuleGraph assigned to the Module for backward-compat (Use the new API)`);return P}),`${I}: Use new ModuleGraph API`,P);be.set(I,L);return L(v)}static setModuleGraphForModule(v,I){ge.set(v,I)}static clearModuleGraphForModule(v){ge.delete(v)}}const ge=new WeakMap;const be=new Map;v.exports=ModuleGraph;v.exports.ModuleGraphConnection=L},73418:function(v){"use strict";const I=Symbol("transitive only");const P=Symbol("circular connection");const addConnectionStates=(v,P)=>{if(v===true||P===true)return true;if(v===false)return P;if(P===false)return v;if(v===I)return P;if(P===I)return v;return v};const intersectConnectionStates=(v,I)=>{if(v===false||I===false)return false;if(v===true)return I;if(I===true)return v;if(v===P)return I;if(I===P)return v;return v};class ModuleGraphConnection{constructor(v,I,P,R,$=false,L=undefined){this.originModule=v;this.resolvedOriginModule=v;this.dependency=I;this.resolvedModule=P;this.module=P;this.weak=$;this.conditional=Boolean(L);this._active=L!==false;this.condition=L||undefined;this.explanations=undefined;if(R){this.explanations=new Set;this.explanations.add(R)}}clone(){const v=new ModuleGraphConnection(this.resolvedOriginModule,this.dependency,this.resolvedModule,undefined,this.weak,this.condition);v.originModule=this.originModule;v.module=this.module;v.conditional=this.conditional;v._active=this._active;if(this.explanations)v.explanations=new Set(this.explanations);return v}addCondition(v){if(this.conditional){const I=this.condition;this.condition=(P,R)=>intersectConnectionStates(I(P,R),v(P,R))}else if(this._active){this.conditional=true;this.condition=v}}addExplanation(v){if(this.explanations===undefined){this.explanations=new Set}this.explanations.add(v)}get explanation(){if(this.explanations===undefined)return"";return Array.from(this.explanations).join(" ")}isActive(v){if(!this.conditional)return this._active;return this.condition(this,v)!==false}isTargetActive(v){if(!this.conditional)return this._active;return this.condition(this,v)===true}getActiveState(v){if(!this.conditional)return this._active;return this.condition(this,v)}setActive(v){this.conditional=false;this._active=v}get active(){throw new Error("Use getActiveState instead")}set active(v){throw new Error("Use setActive instead")}}v.exports=ModuleGraphConnection;v.exports.addConnectionStates=addConnectionStates;v.exports.TRANSITIVE_ONLY=I;v.exports.CIRCULAR_CONNECTION=P},72979:function(v,I,P){"use strict";const R=P(94252);class ModuleHashingError extends R{constructor(v,I){super();this.name="ModuleHashingError";this.error=I;this.message=I.message;this.details=I.stack;this.module=v}}v.exports=ModuleHashingError},52394:function(v,I,P){"use strict";const{ConcatSource:R,RawSource:$,CachedSource:L}=P(51255);const{UsageState:q}=P(21311);const K=P(57227);const ae=P(53296);const ge=P(36926);const joinIterableWithComma=v=>{let I="";let P=true;for(const R of v){if(P){P=false}else{I+=", "}I+=R}return I};const printExportsInfoToSource=(v,I,P,R,$,L=new Set)=>{const ae=P.otherExportsInfo;let ge=0;const be=[];for(const v of P.orderedExports){if(!L.has(v)){L.add(v);be.push(v)}else{ge++}}let xe=false;if(!L.has(ae)){L.add(ae);xe=true}else{ge++}for(const P of be){const q=P.getTarget(R);v.add(`${K.toComment(`${I}export ${JSON.stringify(P.name).slice(1,-1)} [${P.getProvidedInfo()}] [${P.getUsedInfo()}] [${P.getRenameInfo()}]${q?` -> ${q.module.readableIdentifier($)}${q.export?` .${q.export.map((v=>JSON.stringify(v).slice(1,-1))).join(".")}`:""}`:""}`)}\n`);if(P.exportsInfo){printExportsInfoToSource(v,`${I}  `,P.exportsInfo,R,$,L)}}if(ge){v.add(`${K.toComment(`${I}... (${ge} already listed exports)`)}\n`)}if(xe){const P=ae.getTarget(R);if(P||ae.provided!==false||ae.getUsed(undefined)!==q.Unused){const R=be.length>0||ge>0?"other exports":"exports";v.add(`${K.toComment(`${I}${R} [${ae.getProvidedInfo()}] [${ae.getUsedInfo()}]${P?` -> ${P.module.readableIdentifier($)}`:""}`)}\n`)}}};const be=new WeakMap;class ModuleInfoHeaderPlugin{constructor(v=true){this._verbose=v}apply(v){const{_verbose:I}=this;v.hooks.compilation.tap("ModuleInfoHeaderPlugin",(v=>{const P=ge.getCompilationHooks(v);P.renderModulePackage.tap("ModuleInfoHeaderPlugin",((v,P,{chunk:$,chunkGraph:q,moduleGraph:ae,runtimeTemplate:ge})=>{const{requestShortener:xe}=ge;let ve;let Ce=be.get(xe);if(Ce===undefined){be.set(xe,Ce=new WeakMap);Ce.set(P,ve={header:undefined,full:new WeakMap})}else{ve=Ce.get(P);if(ve===undefined){Ce.set(P,ve={header:undefined,full:new WeakMap})}else if(!I){const I=ve.full.get(v);if(I!==undefined)return I}}const Ne=new R;let He=ve.header;if(He===undefined){He=this.generateHeader(P,xe);ve.header=He}Ne.add(He);if(I){const I=P.buildMeta.exportsType;Ne.add(`${K.toComment(I?`${I} exports`:"unknown exports (runtime-defined)")}\n`);if(I){const v=ae.getExportsInfo(P);printExportsInfoToSource(Ne,"",v,ae,xe)}Ne.add(`${K.toComment(`runtime requirements: ${joinIterableWithComma(q.getModuleRuntimeRequirements(P,$.runtime))}`)}\n`);const R=ae.getOptimizationBailout(P);if(R){for(const v of R){const I=typeof v==="function"?v(xe):v;Ne.add(`${K.toComment(`${I}`)}\n`)}}Ne.add(v);return Ne}Ne.add(v);const Qe=new L(Ne);ve.full.set(v,Qe);return Qe}));P.chunkHash.tap("ModuleInfoHeaderPlugin",((v,I)=>{I.update("ModuleInfoHeaderPlugin");I.update("1")}));const $=ae.getCompilationHooks(v);$.renderModulePackage.tap("ModuleInfoHeaderPlugin",((v,P,{runtimeTemplate:$})=>{const{requestShortener:q}=$;let K;let ae=be.get(q);if(ae===undefined){be.set(q,ae=new WeakMap);ae.set(P,K={header:undefined,full:new WeakMap})}else{K=ae.get(P);if(K===undefined){ae.set(P,K={header:undefined,full:new WeakMap})}else if(!I){const I=K.full.get(v);if(I!==undefined)return I}}const ge=new R;let xe=K.header;if(xe===undefined){xe=this.generateHeader(P,q);K.header=xe}ge.add(xe);ge.add(v);const ve=new L(ge);K.full.set(v,ve);return ve}));$.chunkHash.tap("ModuleInfoHeaderPlugin",((v,I)=>{I.update("ModuleInfoHeaderPlugin");I.update("1")}))}))}generateHeader(v,I){const P=v.readableIdentifier(I);const R=P.replace(/\*\//g,"*_/");const L="*".repeat(R.length);const q=`/*!****${L}****!*\\\n  !*** ${R} ***!\n  \\****${L}****/\n`;return new $(q)}}v.exports=ModuleInfoHeaderPlugin},42383:function(v,I,P){"use strict";const R=P(94252);const $={assert:"assert/",buffer:"buffer/",console:"console-browserify",constants:"constants-browserify",crypto:"crypto-browserify",domain:"domain-browser",events:"events/",http:"stream-http",https:"https-browserify",os:"os-browserify/browser",path:"path-browserify",punycode:"punycode/",process:"process/browser",querystring:"querystring-es3",stream:"stream-browserify",_stream_duplex:"readable-stream/duplex",_stream_passthrough:"readable-stream/passthrough",_stream_readable:"readable-stream/readable",_stream_transform:"readable-stream/transform",_stream_writable:"readable-stream/writable",string_decoder:"string_decoder/",sys:"util/",timers:"timers-browserify",tty:"tty-browserify",url:"url/",util:"util/",vm:"vm-browserify",zlib:"browserify-zlib"};class ModuleNotFoundError extends R{constructor(v,I,P){let R=`Module not found: ${I.toString()}`;const L=I.message.match(/Can't resolve '([^']+)'/);if(L){const v=L[1];const I=$[v];if(I){const P=I.indexOf("/");const $=P>0?I.slice(0,P):I;R+="\n\n"+"BREAKING CHANGE: "+"webpack < 5 used to include polyfills for node.js core modules by default.\n"+"This is no longer the case. Verify if you need this module and configure a polyfill for it.\n\n";R+="If you want to include a polyfill, you need to:\n"+`\t- add a fallback 'resolve.fallback: { "${v}": require.resolve("${I}") }'\n`+`\t- install '${$}'\n`;R+="If you don't want to include a polyfill, you can use an empty module like this:\n"+`\tresolve.fallback: { "${v}": false }`}}super(R);this.name="ModuleNotFoundError";this.details=I.details;this.module=v;this.error=I;this.loc=P}}v.exports=ModuleNotFoundError},93153:function(v,I,P){"use strict";const R=P(94252);const $=P(65317);const L=Buffer.from([0,97,115,109]);class ModuleParseError extends R{constructor(v,I,P,R){let $=`Module parse failed: ${I&&I.message}`;let q;if((Buffer.isBuffer(v)&&v.slice(0,4).equals(L)||typeof v==="string"&&/^\0asm/.test(v))&&!R.startsWith("webassembly")){$+="\nThe module seem to be a WebAssembly module, but module is not flagged as WebAssembly module for webpack.";$+="\nBREAKING CHANGE: Since webpack 5 WebAssembly is not enabled by default and flagged as experimental feature.";$+="\nYou need to enable one of the WebAssembly experiments via 'experiments.asyncWebAssembly: true' (based on async modules) or 'experiments.syncWebAssembly: true' (like webpack 4, deprecated).";$+="\nFor files that transpile to WebAssembly, make sure to set the module type in the 'module.rules' section of the config (e. g. 'type: \"webassembly/async\"')."}else if(!P){$+="\nYou may need an appropriate loader to handle this file type."}else if(P.length>=1){$+=`\nFile was processed with these loaders:${P.map((v=>`\n * ${v}`)).join("")}`;$+="\nYou may need an additional loader to handle the result of these loaders."}else{$+="\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders"}if(I&&I.loc&&typeof I.loc==="object"&&typeof I.loc.line==="number"){const P=I.loc.line;if(Buffer.isBuffer(v)||/[\0\u0001\u0002\u0003\u0004\u0005\u0006\u0007]/.test(v)){$+="\n(Source code omitted for this binary file)"}else{const I=v.split(/\r?\n/);const R=Math.max(0,P-3);const L=I.slice(R,P-1);const q=I[P-1];const K=I.slice(P,P+2);$+=`${L.map((v=>`\n| ${v}`)).join("")}\n> ${q}${K.map((v=>`\n| ${v}`)).join("")}`}q={start:I.loc}}else if(I&&I.stack){$+=`\n${I.stack}`}super($);this.name="ModuleParseError";this.loc=q;this.error=I}serialize(v){const{write:I}=v;I(this.error);super.serialize(v)}deserialize(v){const{read:I}=v;this.error=I();super.deserialize(v)}}$(ModuleParseError,"webpack/lib/ModuleParseError");v.exports=ModuleParseError},7265:function(v){"use strict";class ModuleProfile{constructor(){this.startTime=Date.now();this.factoryStartTime=0;this.factoryEndTime=0;this.factory=0;this.factoryParallelismFactor=0;this.restoringStartTime=0;this.restoringEndTime=0;this.restoring=0;this.restoringParallelismFactor=0;this.integrationStartTime=0;this.integrationEndTime=0;this.integration=0;this.integrationParallelismFactor=0;this.buildingStartTime=0;this.buildingEndTime=0;this.building=0;this.buildingParallelismFactor=0;this.storingStartTime=0;this.storingEndTime=0;this.storing=0;this.storingParallelismFactor=0;this.additionalFactoryTimes=undefined;this.additionalFactories=0;this.additionalFactoriesParallelismFactor=0;this.additionalIntegration=0}markFactoryStart(){this.factoryStartTime=Date.now()}markFactoryEnd(){this.factoryEndTime=Date.now();this.factory=this.factoryEndTime-this.factoryStartTime}markRestoringStart(){this.restoringStartTime=Date.now()}markRestoringEnd(){this.restoringEndTime=Date.now();this.restoring=this.restoringEndTime-this.restoringStartTime}markIntegrationStart(){this.integrationStartTime=Date.now()}markIntegrationEnd(){this.integrationEndTime=Date.now();this.integration=this.integrationEndTime-this.integrationStartTime}markBuildingStart(){this.buildingStartTime=Date.now()}markBuildingEnd(){this.buildingEndTime=Date.now();this.building=this.buildingEndTime-this.buildingStartTime}markStoringStart(){this.storingStartTime=Date.now()}markStoringEnd(){this.storingEndTime=Date.now();this.storing=this.storingEndTime-this.storingStartTime}mergeInto(v){v.additionalFactories=this.factory;(v.additionalFactoryTimes=v.additionalFactoryTimes||[]).push({start:this.factoryStartTime,end:this.factoryEndTime})}}v.exports=ModuleProfile},31262:function(v,I,P){"use strict";const R=P(94252);class ModuleRestoreError extends R{constructor(v,I){let P="Module restore failed: ";const R=undefined;if(I!==null&&typeof I==="object"){if(typeof I.stack==="string"&&I.stack){const v=I.stack;P+=v}else if(typeof I.message==="string"&&I.message){P+=I.message}else{P+=I}}else{P+=String(I)}super(P);this.name="ModuleRestoreError";this.details=R;this.module=v;this.error=I}}v.exports=ModuleRestoreError},30021:function(v){"use strict";const I=new Set;const P=new Set(["asset"]);const R=new Set(["asset","javascript"]);const $=new Set(["asset","css-url"]);const L=new Set(["asset","javascript","css-url"]);const q=new Set(["javascript"]);const K=new Set(["javascript","css-export"]);const ae=new Set(["javascript","css-url"]);const ge=new Set(["javascript","css"]);const be=new Set(["css"]);const xe=new Set(["css-url"]);const ve=new Set(["css-import"]);const Ce=new Set(["webassembly"]);const Ne=new Set(["runtime"]);const He=new Set(["remote","share-init"]);const Qe=new Set(["consume-shared"]);const Je=new Set(["share-init"]);v.exports.NO_TYPES=I;v.exports.JS_TYPES=q;v.exports.JS_AND_CSS_TYPES=ge;v.exports.JS_AND_CSS_URL_TYPES=ae;v.exports.JS_AND_CSS_EXPORT_TYPES=K;v.exports.ASSET_TYPES=P;v.exports.ASSET_AND_JS_TYPES=R;v.exports.ASSET_AND_CSS_URL_TYPES=$;v.exports.ASSET_AND_JS_AND_CSS_URL_TYPES=L;v.exports.CSS_TYPES=be;v.exports.CSS_URL_TYPES=xe;v.exports.CSS_IMPORT_TYPES=ve;v.exports.WEBASSEMBLY_TYPES=Ce;v.exports.RUNTIME_TYPES=Ne;v.exports.REMOTE_AND_SHARE_INIT_TYPES=He;v.exports.CONSUME_SHARED_TYPES=Qe;v.exports.SHARED_INIT_TYPES=Je},78719:function(v,I,P){"use strict";const R=P(94252);class ModuleStoreError extends R{constructor(v,I){let P="Module storing failed: ";const R=undefined;if(I!==null&&typeof I==="object"){if(typeof I.stack==="string"&&I.stack){const v=I.stack;P+=v}else if(typeof I.message==="string"&&I.message){P+=I.message}else{P+=I}}else{P+=String(I)}super(P);this.name="ModuleStoreError";this.details=R;this.module=v;this.error=I}}v.exports=ModuleStoreError},80764:function(v,I,P){"use strict";const R=P(73837);const $=P(13594);const L=$((()=>P(36926)));class ModuleTemplate{constructor(v,I){this._runtimeTemplate=v;this.type="javascript";this.hooks=Object.freeze({content:{tap:R.deprecate(((v,P)=>{L().getCompilationHooks(I).renderModuleContent.tap(v,((v,I,R)=>P(v,I,R,R.dependencyTemplates)))}),"ModuleTemplate.hooks.content is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderModuleContent instead)","DEP_MODULE_TEMPLATE_CONTENT")},module:{tap:R.deprecate(((v,P)=>{L().getCompilationHooks(I).renderModuleContent.tap(v,((v,I,R)=>P(v,I,R,R.dependencyTemplates)))}),"ModuleTemplate.hooks.module is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderModuleContent instead)","DEP_MODULE_TEMPLATE_MODULE")},render:{tap:R.deprecate(((v,P)=>{L().getCompilationHooks(I).renderModuleContainer.tap(v,((v,I,R)=>P(v,I,R,R.dependencyTemplates)))}),"ModuleTemplate.hooks.render is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderModuleContainer instead)","DEP_MODULE_TEMPLATE_RENDER")},package:{tap:R.deprecate(((v,P)=>{L().getCompilationHooks(I).renderModulePackage.tap(v,((v,I,R)=>P(v,I,R,R.dependencyTemplates)))}),"ModuleTemplate.hooks.package is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderModulePackage instead)","DEP_MODULE_TEMPLATE_PACKAGE")},hash:{tap:R.deprecate(((v,P)=>{I.hooks.fullHash.tap(v,P)}),"ModuleTemplate.hooks.hash is deprecated (use Compilation.hooks.fullHash instead)","DEP_MODULE_TEMPLATE_HASH")}})}}Object.defineProperty(ModuleTemplate.prototype,"runtimeTemplate",{get:R.deprecate((function(){return this._runtimeTemplate}),"ModuleTemplate.runtimeTemplate is deprecated (use Compilation.runtimeTemplate instead)","DEP_WEBPACK_CHUNK_TEMPLATE_OUTPUT_OPTIONS")});v.exports=ModuleTemplate},6041:function(v){"use strict";const I="javascript/auto";const P="javascript/dynamic";const R="javascript/esm";const $="json";const L="webassembly/async";const q="webassembly/sync";const K="css";const ae="css/global";const ge="css/module";const be="css/auto";const xe="asset";const ve="asset/inline";const Ce="asset/resource";const Ne="asset/source";const He="asset/raw-data-url";const Qe="runtime";const Je="fallback-module";const Ve="remote-module";const Ke="provide-module";const Ye="consume-shared-module";const Xe="lazy-compilation-proxy";v.exports.ASSET_MODULE_TYPE=xe;v.exports.ASSET_MODULE_TYPE_RAW_DATA_URL=He;v.exports.ASSET_MODULE_TYPE_SOURCE=Ne;v.exports.ASSET_MODULE_TYPE_RESOURCE=Ce;v.exports.ASSET_MODULE_TYPE_INLINE=ve;v.exports.JAVASCRIPT_MODULE_TYPE_AUTO=I;v.exports.JAVASCRIPT_MODULE_TYPE_DYNAMIC=P;v.exports.JAVASCRIPT_MODULE_TYPE_ESM=R;v.exports.JSON_MODULE_TYPE=$;v.exports.WEBASSEMBLY_MODULE_TYPE_ASYNC=L;v.exports.WEBASSEMBLY_MODULE_TYPE_SYNC=q;v.exports.CSS_MODULE_TYPE=K;v.exports.CSS_MODULE_TYPE_GLOBAL=ae;v.exports.CSS_MODULE_TYPE_MODULE=ge;v.exports.CSS_MODULE_TYPE_AUTO=be;v.exports.WEBPACK_MODULE_TYPE_RUNTIME=Qe;v.exports.WEBPACK_MODULE_TYPE_FALLBACK=Je;v.exports.WEBPACK_MODULE_TYPE_REMOTE=Ve;v.exports.WEBPACK_MODULE_TYPE_PROVIDE=Ke;v.exports.WEBPACK_MODULE_TYPE_CONSUME_SHARED_MODULE=Ye;v.exports.WEBPACK_MODULE_TYPE_LAZY_COMPILATION_PROXY=Xe},67330:function(v,I,P){"use strict";const{cleanUp:R}=P(35199);const $=P(94252);const L=P(65317);class ModuleWarning extends ${constructor(v,{from:I=null}={}){let P="Module Warning";P+=I?` (from ${I}):\n`:": ";if(v&&typeof v==="object"&&v.message){P+=v.message}else if(v){P+=String(v)}super(P);this.name="ModuleWarning";this.warning=v;this.details=v&&typeof v==="object"&&v.stack?R(v.stack,this.message):undefined}serialize(v){const{write:I}=v;I(this.warning);super.serialize(v)}deserialize(v){const{read:I}=v;this.warning=I();super.deserialize(v)}}L(ModuleWarning,"webpack/lib/ModuleWarning");v.exports=ModuleWarning},34324:function(v,I,P){"use strict";const R=P(78175);const{SyncHook:$,MultiHook:L}=P(84891);const q=P(57753);const K=P(47968);const ae=P(1483);const ge=P(94252);const be=P(95112);v.exports=class MultiCompiler{constructor(v,I){if(!Array.isArray(v)){v=Object.keys(v).map((I=>{v[I].name=I;return v[I]}))}this.hooks=Object.freeze({done:new $(["stats"]),invalid:new L(v.map((v=>v.hooks.invalid))),run:new L(v.map((v=>v.hooks.run))),watchClose:new $([]),watchRun:new L(v.map((v=>v.hooks.watchRun))),infrastructureLog:new L(v.map((v=>v.hooks.infrastructureLog)))});this.compilers=v;this._options={parallelism:I.parallelism||Infinity};this.dependencies=new WeakMap;this.running=false;const P=this.compilers.map((()=>null));let R=0;for(let v=0;v<this.compilers.length;v++){const I=this.compilers[v];const $=v;let L=false;I.hooks.done.tap("MultiCompiler",(v=>{if(!L){L=true;R++}P[$]=v;if(R===this.compilers.length){this.hooks.done.call(new K(P))}}));I.hooks.invalid.tap("MultiCompiler",(()=>{if(L){L=false;R--}}))}this._validateCompilersOptions()}_validateCompilersOptions(){if(this.compilers.length<2)return;const addWarning=(v,I)=>{v.hooks.thisCompilation.tap("MultiCompiler",(v=>{v.warnings.push(I)}))};const v=new Set;for(const I of this.compilers){if(I.options.cache&&"name"in I.options.cache){const P=I.options.cache.name;if(v.has(P)){addWarning(I,new ge(`${I.name?`Compiler with name "${I.name}" doesn't use unique cache name. `:""}Please set unique "cache.name" option. Name "${P}" already used.`))}else{v.add(P)}}}}get options(){return Object.assign(this.compilers.map((v=>v.options)),this._options)}get outputPath(){let v=this.compilers[0].outputPath;for(const I of this.compilers){while(I.outputPath.indexOf(v)!==0&&/[/\\]/.test(v)){v=v.replace(/[/\\][^/\\]*$/,"")}}if(!v&&this.compilers[0].outputPath[0]==="/")return"/";return v}get inputFileSystem(){throw new Error("Cannot read inputFileSystem of a MultiCompiler")}set inputFileSystem(v){for(const I of this.compilers){I.inputFileSystem=v}}get outputFileSystem(){throw new Error("Cannot read outputFileSystem of a MultiCompiler")}set outputFileSystem(v){for(const I of this.compilers){I.outputFileSystem=v}}get watchFileSystem(){throw new Error("Cannot read watchFileSystem of a MultiCompiler")}set watchFileSystem(v){for(const I of this.compilers){I.watchFileSystem=v}}set intermediateFileSystem(v){for(const I of this.compilers){I.intermediateFileSystem=v}}get intermediateFileSystem(){throw new Error("Cannot read outputFileSystem of a MultiCompiler")}getInfrastructureLogger(v){return this.compilers[0].getInfrastructureLogger(v)}setDependencies(v,I){this.dependencies.set(v,I)}validateDependencies(v){const I=new Set;const P=[];const targetFound=v=>{for(const P of I){if(P.target===v){return true}}return false};const sortEdges=(v,I)=>v.source.name.localeCompare(I.source.name)||v.target.name.localeCompare(I.target.name);for(const v of this.compilers){const R=this.dependencies.get(v);if(R){for(const $ of R){const R=this.compilers.find((v=>v.name===$));if(!R){P.push($)}else{I.add({source:v,target:R})}}}}const R=P.map((v=>`Compiler dependency \`${v}\` not found.`));const $=this.compilers.filter((v=>!targetFound(v)));while($.length>0){const v=$.pop();for(const P of I){if(P.source===v){I.delete(P);const v=P.target;if(!targetFound(v)){$.push(v)}}}}if(I.size>0){const v=Array.from(I).sort(sortEdges).map((v=>`${v.source.name} -> ${v.target.name}`));v.unshift("Circular dependency found in compiler dependencies.");R.unshift(v.join("\n"))}if(R.length>0){const I=R.join("\n");v(new Error(I));return false}return true}runWithDependencies(v,I,P){const $=new Set;let L=v;const isDependencyFulfilled=v=>$.has(v);const getReadyCompilers=()=>{const v=[];const I=L;L=[];for(const P of I){const I=this.dependencies.get(P);const R=!I||I.every(isDependencyFulfilled);if(R){v.push(P)}else{L.push(P)}}return v};const runCompilers=v=>{if(L.length===0)return v(null);R.map(getReadyCompilers(),((v,P)=>{I(v,(I=>{if(I)return P(I);$.add(v.name);runCompilers(P)}))}),((I,P)=>{v(I,P)}))};runCompilers(P)}_runGraph(v,I,P){const $=this.compilers.map((v=>({compiler:v,setupResult:undefined,result:undefined,state:"blocked",children:[],parents:[]})));const L=new Map;for(const v of $){L.set(v.compiler.name,v)}for(const v of $){const I=this.dependencies.get(v.compiler);if(!I)continue;for(const P of I){const I=L.get(P);v.parents.push(I);I.children.push(v)}}const q=new be;for(const v of $){if(v.parents.length===0){v.state="queued";q.enqueue(v)}}let ae=false;let ge=0;const xe=this._options.parallelism;const nodeDone=(v,I,L)=>{if(ae)return;if(I){ae=true;return R.each($,((v,I)=>{if(v.compiler.watching){v.compiler.watching.close(I)}else{I()}}),(()=>P(I)))}v.result=L;ge--;if(v.state==="running"){v.state="done";for(const I of v.children){if(I.state==="blocked")q.enqueue(I)}}else if(v.state==="running-outdated"){v.state="blocked";q.enqueue(v)}processQueue()};const nodeInvalidFromParent=v=>{if(v.state==="done"){v.state="blocked"}else if(v.state==="running"){v.state="running-outdated"}for(const I of v.children){nodeInvalidFromParent(I)}};const nodeInvalid=v=>{if(v.state==="done"){v.state="pending"}else if(v.state==="running"){v.state="running-outdated"}for(const I of v.children){nodeInvalidFromParent(I)}};const nodeChange=v=>{nodeInvalid(v);if(v.state==="pending"){v.state="blocked"}if(v.state==="blocked"){q.enqueue(v);processQueue()}};const ve=[];for(const[I,P]of $.entries()){ve.push(P.setupResult=v(P.compiler,I,nodeDone.bind(null,P),(()=>P.state!=="starting"&&P.state!=="running"),(()=>nodeChange(P)),(()=>nodeInvalid(P))))}let Ce=true;const processQueue=()=>{if(Ce)return;Ce=true;process.nextTick(processQueueWorker)};const processQueueWorker=()=>{while(ge<xe&&q.length>0&&!ae){const v=q.dequeue();if(v.state==="queued"||v.state==="blocked"&&v.parents.every((v=>v.state==="done"))){ge++;v.state="starting";I(v.compiler,v.setupResult,nodeDone.bind(null,v));v.state="running"}}Ce=false;if(!ae&&ge===0&&$.every((v=>v.state==="done"))){const v=[];for(const I of $){const P=I.result;if(P){I.result=undefined;v.push(P)}}if(v.length>0){P(null,new K(v))}}};processQueueWorker();return ve}watch(v,I){if(this.running){return I(new q)}this.running=true;if(this.validateDependencies(I)){const P=this._runGraph(((I,P,R,$,L,q)=>{const K=I.watch(Array.isArray(v)?v[P]:v,R);if(K){K._onInvalid=q;K._onChange=L;K._isBlocked=$}return K}),((v,I,P)=>{if(v.watching!==I)return;if(!I.running)I.invalidate()}),I);return new ae(P,this)}return new ae([],this)}run(v){if(this.running){return v(new q)}this.running=true;if(this.validateDependencies(v)){this._runGraph((()=>{}),((v,I,P)=>v.run(P)),((I,P)=>{this.running=false;if(v!==undefined){return v(I,P)}}))}}purgeInputFileSystem(){for(const v of this.compilers){if(v.inputFileSystem&&v.inputFileSystem.purge){v.inputFileSystem.purge()}}}close(v){R.each(this.compilers,((v,I)=>{v.close(I)}),(I=>{v(I)}))}}},47968:function(v,I,P){"use strict";const R=P(46579);const indent=(v,I)=>{const P=v.replace(/\n([^\n])/g,`\n${I}$1`);return I+P};class MultiStats{constructor(v){this.stats=v}get hash(){return this.stats.map((v=>v.hash)).join("")}hasErrors(){return this.stats.some((v=>v.hasErrors()))}hasWarnings(){return this.stats.some((v=>v.hasWarnings()))}_createChildOptions(v,I){const getCreateStatsOptions=()=>{if(!v){v={}}const{children:I=undefined,...P}=typeof v==="string"?{preset:v}:v;return{childrenOptions:I,baseOptions:P}};const P=this.stats.map(((P,R)=>{if(typeof v==="boolean"){return P.compilation.createStatsOptions(v,I)}const{childrenOptions:$,baseOptions:L}=getCreateStatsOptions();const q=Array.isArray($)?$[R]:$;return P.compilation.createStatsOptions({...L,...typeof q==="string"?{preset:q}:q&&typeof q==="object"?q:undefined},I)}));return{version:P.every((v=>v.version)),hash:P.every((v=>v.hash)),errorsCount:P.every((v=>v.errorsCount)),warningsCount:P.every((v=>v.warningsCount)),errors:P.every((v=>v.errors)),warnings:P.every((v=>v.warnings)),children:P}}toJson(v){const I=this._createChildOptions(v,{forToString:false});const P={};P.children=this.stats.map(((v,P)=>{const $=v.toJson(I.children[P]);const L=v.compilation.name;const q=L&&R.makePathsRelative(v.compilation.compiler.context,L,v.compilation.compiler.root);$.name=q;return $}));if(I.version){P.version=P.children[0].version}if(I.hash){P.hash=P.children.map((v=>v.hash)).join("")}const mapError=(v,I)=>({...I,compilerPath:I.compilerPath?`${v.name}.${I.compilerPath}`:v.name});if(I.errors){P.errors=[];for(const v of P.children){const I=v.errors;for(const R of I){P.errors.push(mapError(v,R))}}}if(I.warnings){P.warnings=[];for(const v of P.children){const I=v.warnings;for(const R of I){P.warnings.push(mapError(v,R))}}}if(I.errorsCount){P.errorsCount=0;for(const v of P.children){P.errorsCount+=v.errorsCount}}if(I.warningsCount){P.warningsCount=0;for(const v of P.children){P.warningsCount+=v.warningsCount}}return P}toString(v){const I=this._createChildOptions(v,{forToString:true});const P=this.stats.map(((v,P)=>{const $=v.toString(I.children[P]);const L=v.compilation.name;const q=L&&R.makePathsRelative(v.compilation.compiler.context,L,v.compilation.compiler.root).replace(/\|/g," ");if(!$)return $;return q?`${q}:\n${indent($,"  ")}`:$}));return P.filter(Boolean).join("\n\n")}}v.exports=MultiStats},1483:function(v,I,P){"use strict";const R=P(78175);class MultiWatching{constructor(v,I){this.watchings=v;this.compiler=I}invalidate(v){if(v){R.each(this.watchings,((v,I)=>v.invalidate(I)),v)}else{for(const v of this.watchings){v.invalidate()}}}suspend(){for(const v of this.watchings){v.suspend()}}resume(){for(const v of this.watchings){v.resume()}}close(v){R.each(this.watchings,((v,I)=>{v.close(I)}),(I=>{this.compiler.hooks.watchClose.call();if(typeof v==="function"){this.compiler.running=false;v(I)}}))}}v.exports=MultiWatching},48489:function(v){"use strict";class NoEmitOnErrorsPlugin{apply(v){v.hooks.shouldEmit.tap("NoEmitOnErrorsPlugin",(v=>{if(v.getStats().hasErrors())return false}));v.hooks.compilation.tap("NoEmitOnErrorsPlugin",(v=>{v.hooks.shouldRecord.tap("NoEmitOnErrorsPlugin",(()=>{if(v.getStats().hasErrors())return false}))}))}}v.exports=NoEmitOnErrorsPlugin},20798:function(v,I,P){"use strict";const R=P(94252);v.exports=class NoModeWarning extends R{constructor(){super();this.name="NoModeWarning";this.message="configuration\n"+"The 'mode' option has not been set, webpack will fallback to 'production' for this value.\n"+"Set 'mode' option to 'development' or 'production' to enable defaults for each environment.\n"+"You can also set it to 'none' to disable any default behavior. "+"Learn more: https://webpack.js.org/configuration/mode/"}}},53661:function(v,I,P){"use strict";const R=P(94252);const $=P(65317);class NodeStuffInWebError extends R{constructor(v,I,P){super(`${JSON.stringify(I)} has been used, it will be undefined in next major version.\n${P}`);this.name="NodeStuffInWebError";this.loc=v}}$(NodeStuffInWebError,"webpack/lib/NodeStuffInWebError");v.exports=NodeStuffInWebError},93438:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$}=P(6041);const L=P(53661);const q=P(5205);const K=P(45871);const ae=P(34022);const ge=P(63121);const{evaluateToString:be,expressionIsUnsupported:xe}=P(59932);const{relative:ve}=P(80749);const{parseResource:Ce}=P(46579);const Ne="NodeStuffPlugin";class NodeStuffPlugin{constructor(v){this.options=v}apply(v){const I=this.options;v.hooks.compilation.tap(Ne,((P,{normalModuleFactory:He})=>{P.dependencyTemplates.set(ge,new ge.Template);const handler=(P,R)=>{if(R.node===false)return;let $=I;if(R.node){$={...$,...R.node}}if($.global!==false){const v=$.global==="warn";P.hooks.expression.for("global").tap(Ne,(I=>{const R=new ae(q.global,I.range,[q.global]);R.loc=I.loc;P.state.module.addPresentationalDependency(R);if(v){P.state.module.addWarning(new L(R.loc,"global","The global namespace object is a Node.js feature and isn't available in browsers."))}}));P.hooks.rename.for("global").tap(Ne,(v=>{const I=new ae(q.global,v.range,[q.global]);I.loc=v.loc;P.state.module.addPresentationalDependency(I);return false}))}const setModuleConstant=(v,I,R)=>{P.hooks.expression.for(v).tap(Ne,($=>{const q=new K(JSON.stringify(I(P.state.module)),$.range,v);q.loc=$.loc;P.state.module.addPresentationalDependency(q);if(R){P.state.module.addWarning(new L(q.loc,v,R))}return true}))};const setUrlModuleConstant=(v,I)=>{P.hooks.expression.for(v).tap(Ne,(R=>{const $=new ge("url",[{name:"fileURLToPath",value:"__webpack_fileURLToPath__"}],undefined,I("__webpack_fileURLToPath__"),R.range,v);$.loc=R.loc;P.state.module.addPresentationalDependency($);return true}))};const setConstant=(v,I,P)=>setModuleConstant(v,(()=>I),P);const He=v.context;if($.__filename){switch($.__filename){case"mock":setConstant("__filename","/index.js");break;case"warn-mock":setConstant("__filename","/index.js","__filename is a Node.js feature and isn't available in browsers.");break;case"node-module":setUrlModuleConstant("__filename",(v=>`${v}(import.meta.url)`));break;case true:setModuleConstant("__filename",(I=>ve(v.inputFileSystem,He,I.resource)));break}P.hooks.evaluateIdentifier.for("__filename").tap(Ne,(v=>{if(!P.state.module)return;const I=Ce(P.state.module.resource);return be(I.path)(v)}))}if($.__dirname){switch($.__dirname){case"mock":setConstant("__dirname","/");break;case"warn-mock":setConstant("__dirname","/","__dirname is a Node.js feature and isn't available in browsers.");break;case"node-module":setUrlModuleConstant("__dirname",(v=>`${v}(import.meta.url + "/..").slice(0, -1)`));break;case true:setModuleConstant("__dirname",(I=>ve(v.inputFileSystem,He,I.context)));break}P.hooks.evaluateIdentifier.for("__dirname").tap(Ne,(v=>{if(!P.state.module)return;return be(P.state.module.context)(v)}))}P.hooks.expression.for("require.extensions").tap(Ne,xe(P,"require.extensions is not supported by webpack. Use a loader instead."))};He.hooks.parser.for(R).tap(Ne,handler);He.hooks.parser.for($).tap(Ne,handler)}))}}v.exports=NodeStuffPlugin},32594:function(v,I,P){"use strict";const R=P(54650);const{getContext:$,runLoaders:L}=P(22955);const q=P(63477);const{HookMap:K,SyncHook:ae,AsyncSeriesBailHook:ge}=P(84891);const{CachedSource:be,OriginalSource:xe,RawSource:ve,SourceMapSource:Ce}=P(51255);const Ne=P(29327);const He=P(73404);const Qe=P(34803);const Je=P(63090);const Ve=P(73716);const Ke=P(73418);const Ye=P(93153);const{JAVASCRIPT_MODULE_TYPE_AUTO:Xe}=P(6041);const Ze=P(67330);const et=P(5205);const tt=P(65754);const nt=P(94252);const st=P(28408);const rt=P(11584);const{isSubset:ot}=P(81956);const{getScheme:it}=P(48537);const{compareLocations:at,concatComparators:ct,compareSelect:lt,keepOriginalOrder:ut}=P(21398);const pt=P(12471);const{createFakeHook:dt}=P(10416);const{join:ft}=P(80749);const{contextify:ht,absolutify:mt,makePathsRelative:gt}=P(46579);const yt=P(65317);const bt=P(13594);const xt=bt((()=>P(70870)));const kt=bt((()=>P(38476).validate));const vt=/^([a-zA-Z]:\\|\\\\|\/)/;const contextifySourceUrl=(v,I,P)=>{if(I.startsWith("webpack://"))return I;return`webpack://${gt(v,I,P)}`};const contextifySourceMap=(v,I,P)=>{if(!Array.isArray(I.sources))return I;const{sourceRoot:R}=I;const $=!R?v=>v:R.endsWith("/")?v=>v.startsWith("/")?`${R.slice(0,-1)}${v}`:`${R}${v}`:v=>v.startsWith("/")?`${R}${v}`:`${R}/${v}`;const L=I.sources.map((I=>contextifySourceUrl(v,$(I),P)));return{...I,file:"x",sourceRoot:undefined,sources:L}};const asString=v=>{if(Buffer.isBuffer(v)){return v.toString("utf-8")}return v};const asBuffer=v=>{if(!Buffer.isBuffer(v)){return Buffer.from(v,"utf-8")}return v};class NonErrorEmittedError extends nt{constructor(v){super();this.name="NonErrorEmittedError";this.message=`(Emitted value instead of an instance of Error) ${v}`}}yt(NonErrorEmittedError,"webpack/lib/NormalModule","NonErrorEmittedError");const wt=new WeakMap;class NormalModule extends Qe{static getCompilationHooks(v){if(!(v instanceof Ne)){throw new TypeError("The 'compilation' argument must be an instance of Compilation")}let I=wt.get(v);if(I===undefined){I={loader:new ae(["loaderContext","module"]),beforeLoaders:new ae(["loaders","module","loaderContext"]),beforeParse:new ae(["module"]),beforeSnapshot:new ae(["module"]),readResourceForScheme:new K((v=>{const P=I.readResource.for(v);return dt({tap:(v,I)=>P.tap(v,(v=>I(v.resource,v._module))),tapAsync:(v,I)=>P.tapAsync(v,((v,P)=>I(v.resource,v._module,P))),tapPromise:(v,I)=>P.tapPromise(v,(v=>I(v.resource,v._module)))})})),readResource:new K((()=>new ge(["loaderContext"]))),needBuild:new ge(["module","context"])};wt.set(v,I)}return I}constructor({layer:v,type:I,request:P,userRequest:R,rawRequest:L,loaders:q,resource:K,resourceResolveData:ae,context:ge,matchResource:be,parser:xe,parserOptions:ve,generator:Ce,generatorOptions:Ne,resolveOptions:He}){super(I,ge||$(K),v);this.request=P;this.userRequest=R;this.rawRequest=L;this.binary=/^(asset|webassembly)\b/.test(I);this.parser=xe;this.parserOptions=ve;this.generator=Ce;this.generatorOptions=Ne;this.resource=K;this.resourceResolveData=ae;this.matchResource=be;this.loaders=q;if(He!==undefined){this.resolveOptions=He}this.error=null;this._source=null;this._sourceSizes=undefined;this._sourceTypes=undefined;this._lastSuccessfulBuildMeta={};this._forceBuild=true;this._isEvaluatingSideEffects=false;this._addedSideEffectsBailout=undefined;this._codeGeneratorData=new Map}identifier(){if(this.layer===null){if(this.type===Xe){return this.request}return`${this.type}|${this.request}`}return`${this.type}|${this.request}|${this.layer}`}readableIdentifier(v){return v.shorten(this.userRequest)}libIdent(v){let I=ht(v.context,this.userRequest,v.associatedObjectForCache);if(this.layer)I=`(${this.layer})/${I}`;return I}nameForCondition(){const v=this.matchResource||this.resource;const I=v.indexOf("?");if(I>=0)return v.slice(0,I);return v}updateCacheModule(v){super.updateCacheModule(v);const I=v;this.binary=I.binary;this.request=I.request;this.userRequest=I.userRequest;this.rawRequest=I.rawRequest;this.parser=I.parser;this.parserOptions=I.parserOptions;this.generator=I.generator;this.generatorOptions=I.generatorOptions;this.resource=I.resource;this.resourceResolveData=I.resourceResolveData;this.context=I.context;this.matchResource=I.matchResource;this.loaders=I.loaders}cleanupForCache(){if(this.buildInfo){if(this._sourceTypes===undefined)this.getSourceTypes();for(const v of this._sourceTypes){this.size(v)}}super.cleanupForCache();this.parser=undefined;this.parserOptions=undefined;this.generator=undefined;this.generatorOptions=undefined}getUnsafeCacheData(){const v=super.getUnsafeCacheData();v.parserOptions=this.parserOptions;v.generatorOptions=this.generatorOptions;return v}restoreFromUnsafeCache(v,I){this._restoreFromUnsafeCache(v,I)}_restoreFromUnsafeCache(v,I){super._restoreFromUnsafeCache(v,I);this.parserOptions=v.parserOptions;this.parser=I.getParser(this.type,this.parserOptions);this.generatorOptions=v.generatorOptions;this.generator=I.getGenerator(this.type,this.generatorOptions)}createSourceForAsset(v,I,P,R,$){if(R){if(typeof R==="string"&&(this.useSourceMap||this.useSimpleSourceMap)){return new xe(P,contextifySourceUrl(v,R,$))}if(this.useSourceMap){return new Ce(P,I,contextifySourceMap(v,R,$))}}return new ve(P)}_createLoaderContext(v,I,P,$,L){const{requestShortener:K}=P.runtimeTemplate;const getCurrentLoaderName=()=>{const v=this.getCurrentLoader(Ce);if(!v)return"(not in loader scope)";return K.shorten(v.loader)};const getResolveContext=()=>({fileDependencies:{add:v=>Ce.addDependency(v)},contextDependencies:{add:v=>Ce.addContextDependency(v)},missingDependencies:{add:v=>Ce.addMissingDependency(v)}});const ae=bt((()=>mt.bindCache(P.compiler.root)));const ge=bt((()=>mt.bindContextCache(this.context,P.compiler.root)));const be=bt((()=>ht.bindCache(P.compiler.root)));const xe=bt((()=>ht.bindContextCache(this.context,P.compiler.root)));const ve={absolutify:(v,I)=>v===this.context?ge()(I):ae()(v,I),contextify:(v,I)=>v===this.context?xe()(I):be()(v,I),createHash:v=>pt(v||P.outputOptions.hashFunction)};const Ce={version:2,getOptions:v=>{const I=this.getCurrentLoader(Ce);let{options:P}=I;if(typeof P==="string"){if(P.startsWith("{")&&P.endsWith("}")){try{P=R(P)}catch(v){throw new Error(`Cannot parse string options: ${v.message}`)}}else{P=q.parse(P,"&","=",{maxKeys:0})}}if(P===null||P===undefined){P={}}if(v){let I="Loader";let R="options";let $;if(v.title&&($=/^(.+) (.+)$/.exec(v.title))){[,I,R]=$}kt()(v,P,{name:I,baseDataPath:R})}return P},emitWarning:v=>{if(!(v instanceof Error)){v=new NonErrorEmittedError(v)}this.addWarning(new Ze(v,{from:getCurrentLoaderName()}))},emitError:v=>{if(!(v instanceof Error)){v=new NonErrorEmittedError(v)}this.addError(new Ve(v,{from:getCurrentLoaderName()}))},getLogger:v=>{const I=this.getCurrentLoader(Ce);return P.getLogger((()=>[I&&I.loader,v,this.identifier()].filter(Boolean).join("|")))},resolve(I,P,R){v.resolve({},I,P,getResolveContext(),R)},getResolve(I){const P=I?v.withOptions(I):v;return(v,I,R)=>{if(R){P.resolve({},v,I,getResolveContext(),R)}else{return new Promise(((R,$)=>{P.resolve({},v,I,getResolveContext(),((v,I)=>{if(v)$(v);else R(I)}))}))}}},emitFile:(v,R,$,L)=>{const q=this.buildInfo;if(!q.assets){q.assets=Object.create(null);q.assetsInfo=new Map}const K=q.assets;const ae=q.assetsInfo;K[v]=this.createSourceForAsset(I.context,v,R,$,P.compiler.root);ae.set(v,L)},addBuildDependency:v=>{const I=this.buildInfo;if(I.buildDependencies===undefined){I.buildDependencies=new rt}I.buildDependencies.add(v)},utils:ve,rootContext:I.context,webpack:true,sourceMap:Boolean(this.useSourceMap),mode:I.mode||"production",hashFunction:I.output.hashFunction,hashDigest:I.output.hashDigest,hashDigestLength:I.output.hashDigestLength,hashSalt:I.output.hashSalt,_module:this,_compilation:P,_compiler:P.compiler,fs:$};Object.assign(Ce,I.loader);L.loader.call(Ce,this);return Ce}getCurrentLoader(v,I=v.loaderIndex){if(this.loaders&&this.loaders.length&&I<this.loaders.length&&I>=0&&this.loaders[I]){return this.loaders[I]}return null}createSource(v,I,P,R){if(Buffer.isBuffer(I)){return new ve(I)}if(!this.identifier){return new ve(I)}const $=this.identifier();if(this.useSourceMap&&P){return new Ce(I,contextifySourceUrl(v,$,R),contextifySourceMap(v,P,R))}if(this.useSourceMap||this.useSimpleSourceMap){return new xe(I,contextifySourceUrl(v,$,R))}return new ve(I)}_doBuild(v,I,P,R,$,q){const K=this._createLoaderContext(P,v,I,R,$);const processResult=(P,R)=>{if(P){if(!(P instanceof Error)){P=new NonErrorEmittedError(P)}const v=this.getCurrentLoader(K);const R=new Je(P,{from:v&&I.runtimeTemplate.requestShortener.shorten(v.loader)});return q(R)}const $=R;const L=$[0];const ae=$.length>=1?$[1]:null;const ge=$.length>=2?$[2]:null;if(!Buffer.isBuffer(L)&&typeof L!=="string"){const v=this.getCurrentLoader(K,0);const P=new Error(`Final loader (${v?I.runtimeTemplate.requestShortener.shorten(v.loader):"unknown"}) didn't return a Buffer or String`);const R=new Je(P);return q(R)}const be=this.generatorOptions&&this.generatorOptions.binary!==undefined?this.generatorOptions.binary:this.binary;this._source=this.createSource(v.context,be?asBuffer(L):asString(L),ae,I.compiler.root);if(this._sourceSizes!==undefined)this._sourceSizes.clear();this._ast=typeof ge==="object"&&ge!==null&&ge.webpackAST!==undefined?ge.webpackAST:null;return q()};const ae=this.buildInfo;ae.fileDependencies=new rt;ae.contextDependencies=new rt;ae.missingDependencies=new rt;ae.cacheable=true;try{$.beforeLoaders.call(this.loaders,this,K)}catch(v){processResult(v);return}if(this.loaders.length>0){this.buildInfo.buildDependencies=new rt}L({resource:this.resource,loaders:this.loaders,context:K,processResource:(v,I,P)=>{const R=v.resource;const L=it(R);$.readResource.for(L).callAsync(v,((v,I)=>{if(v)return P(v);if(typeof I!=="string"&&!I){return P(new tt(L,R))}return P(null,I)}))}},((v,I)=>{K._compilation=K._compiler=K._module=K.fs=undefined;if(!I){this.buildInfo.cacheable=false;return processResult(v||new Error("No result from loader-runner processing"),null)}const P=this.buildInfo;const R=P.fileDependencies;const $=P.contextDependencies;const L=P.missingDependencies;R.addAll(I.fileDependencies);$.addAll(I.contextDependencies);L.addAll(I.missingDependencies);for(const v of this.loaders){const I=P.buildDependencies;I.add(v.loader)}P.cacheable=P.cacheable&&I.cacheable;processResult(v,I.result)}))}markModuleAsErrored(v){this.buildMeta={...this._lastSuccessfulBuildMeta};this.error=v;this.addError(v)}applyNoParseRule(v,I){if(typeof v==="string"){return I.startsWith(v)}if(typeof v==="function"){return v(I)}return v.test(I)}shouldPreventParsing(v,I){if(!v){return false}if(!Array.isArray(v)){return this.applyNoParseRule(v,I)}for(let P=0;P<v.length;P++){const R=v[P];if(this.applyNoParseRule(R,I)){return true}}return false}_initBuildHash(v){const I=pt(v.outputOptions.hashFunction);if(this._source){I.update("source");this._source.updateHash(I)}I.update("meta");I.update(JSON.stringify(this.buildMeta));this.buildInfo.hash=I.digest("hex")}build(v,I,P,R,$){this._forceBuild=false;this._source=null;if(this._sourceSizes!==undefined)this._sourceSizes.clear();this._sourceTypes=undefined;this._ast=null;this.error=null;this.clearWarningsAndErrors();this.clearDependenciesAndBlocks();this.buildMeta={};this.buildInfo={cacheable:false,parsed:true,fileDependencies:undefined,contextDependencies:undefined,missingDependencies:undefined,buildDependencies:undefined,valueDependencies:undefined,hash:undefined,assets:undefined,assetsInfo:undefined};const L=I.compiler.fsStartTime||Date.now();const q=NormalModule.getCompilationHooks(I);return this._doBuild(v,I,P,R,q,(P=>{if(P){this.markModuleAsErrored(P);this._initBuildHash(I);return $()}const handleParseError=P=>{const R=this._source.source();const L=this.loaders.map((P=>ht(v.context,P.loader,I.compiler.root)));const q=new Ye(R,P,L,this.type);this.markModuleAsErrored(q);this._initBuildHash(I);return $()};const handleParseResult=()=>{this.dependencies.sort(ct(lt((v=>v.loc),at),ut(this.dependencies)));this._initBuildHash(I);this._lastSuccessfulBuildMeta=this.buildMeta;return handleBuildDone()};const handleBuildDone=()=>{try{q.beforeSnapshot.call(this)}catch(v){this.markModuleAsErrored(v);return $()}const v=I.options.snapshot.module;const{cacheable:P}=this.buildInfo;if(!P||!v){return $()}let R;const checkDependencies=v=>{for(const P of v){if(!vt.test(P)){if(R===undefined)R=new Set;R.add(P);v.delete(P);try{const R=P.replace(/[\\/]?\*.*$/,"");const $=ft(I.fileSystemInfo.fs,this.context,R);if($!==P&&vt.test($)){(R!==P?this.buildInfo.contextDependencies:v).add($)}}catch(v){}}}};const K=this.buildInfo;const ae=K.fileDependencies;const ge=K.contextDependencies;const be=K.missingDependencies;checkDependencies(ae);checkDependencies(be);checkDependencies(ge);if(R!==undefined){const v=xt();this.addWarning(new v(this,R))}I.fileSystemInfo.createSnapshot(L,ae,ge,be,v,((v,I)=>{if(v){this.markModuleAsErrored(v);return}K.fileDependencies=undefined;K.contextDependencies=undefined;K.missingDependencies=undefined;K.snapshot=I;return $()}))};try{q.beforeParse.call(this)}catch(P){this.markModuleAsErrored(P);this._initBuildHash(I);return $()}const R=v.module&&v.module.noParse;if(this.shouldPreventParsing(R,this.request)){this.buildInfo.parsed=false;this._initBuildHash(I);return handleBuildDone()}try{const P=this._source.source();this.parser.parse(this._ast||P,{source:P,current:this,module:this,compilation:I,options:v})}catch(v){handleParseError(v);return}handleParseResult()}))}getConcatenationBailoutReason(v){return this.generator.getConcatenationBailoutReason(this,v)}getSideEffectsConnectionState(v){if(this.factoryMeta!==undefined){if(this.factoryMeta.sideEffectFree)return false;if(this.factoryMeta.sideEffectFree===false)return true}if(this.buildMeta!==undefined&&this.buildMeta.sideEffectFree){if(this._isEvaluatingSideEffects)return Ke.CIRCULAR_CONNECTION;this._isEvaluatingSideEffects=true;let I=false;for(const P of this.dependencies){const R=P.getModuleEvaluationSideEffectsState(v);if(R===true){if(this._addedSideEffectsBailout===undefined?(this._addedSideEffectsBailout=new WeakSet,true):!this._addedSideEffectsBailout.has(v)){this._addedSideEffectsBailout.add(v);v.getOptimizationBailout(this).push((()=>`Dependency (${P.type}) with side effects at ${st(P.loc)}`))}this._isEvaluatingSideEffects=false;return true}else if(R!==Ke.CIRCULAR_CONNECTION){I=Ke.addConnectionStates(I,R)}}this._isEvaluatingSideEffects=false;return I}return true}getSourceTypes(){if(this._sourceTypes===undefined){this._sourceTypes=this.generator.getTypes(this)}return this._sourceTypes}codeGeneration({dependencyTemplates:v,runtimeTemplate:I,moduleGraph:P,chunkGraph:R,runtime:$,concatenationScope:L,codeGenerationResults:q,sourceTypes:K}){const ae=new Set;const{parsed:ge}=this.buildInfo;if(!ge){ae.add(et.module);ae.add(et.exports);ae.add(et.thisAsExports)}const getData=()=>this._codeGeneratorData;const xe=new Map;for(const ge of K||R.getModuleSourceTypes(this)){const K=this.error?new ve(`throw new Error(${JSON.stringify(this.error.message)});`):this.generator.generate(this,{dependencyTemplates:v,runtimeTemplate:I,moduleGraph:P,chunkGraph:R,runtimeRequirements:ae,runtime:$,concatenationScope:L,codeGenerationResults:q,getData:getData,type:ge});if(K){xe.set(ge,new be(K))}}const Ce={sources:xe,runtimeRequirements:ae,data:this._codeGeneratorData};return Ce}originalSource(){return this._source}invalidateBuild(){this._forceBuild=true}needBuild(v,I){const{fileSystemInfo:P,compilation:R,valueCacheVersions:$}=v;if(this._forceBuild)return I(null,true);if(this.error)return I(null,true);const{cacheable:L,snapshot:q,valueDependencies:K}=this.buildInfo;if(!L)return I(null,true);if(!q)return I(null,true);if(K){if(!$)return I(null,true);for(const[v,P]of K){if(P===undefined)return I(null,true);const R=$.get(v);if(P!==R&&(typeof P==="string"||typeof R==="string"||R===undefined||!ot(P,R))){return I(null,true)}}}P.checkSnapshotValid(q,((P,$)=>{if(P)return I(P);if(!$)return I(null,true);const L=NormalModule.getCompilationHooks(R);L.needBuild.callAsync(this,v,((v,P)=>{if(v){return I(He.makeWebpackError(v,"NormalModule.getCompilationHooks().needBuild"))}I(null,Boolean(P))}))}))}size(v){const I=this._sourceSizes===undefined?undefined:this._sourceSizes.get(v);if(I!==undefined){return I}const P=Math.max(1,this.generator.getSize(this,v));if(this._sourceSizes===undefined){this._sourceSizes=new Map}this._sourceSizes.set(v,P);return P}addCacheDependencies(v,I,P,R){const{snapshot:$,buildDependencies:L}=this.buildInfo;if($){v.addAll($.getFileIterable());I.addAll($.getContextIterable());P.addAll($.getMissingIterable())}else{const{fileDependencies:R,contextDependencies:$,missingDependencies:L}=this.buildInfo;if(R!==undefined)v.addAll(R);if($!==undefined)I.addAll($);if(L!==undefined)P.addAll(L)}if(L!==undefined){R.addAll(L)}}updateHash(v,I){v.update(this.buildInfo.hash);this.generator.updateHash(v,{module:this,...I});super.updateHash(v,I)}serialize(v){const{write:I}=v;I(this._source);I(this.error);I(this._lastSuccessfulBuildMeta);I(this._forceBuild);I(this._codeGeneratorData);super.serialize(v)}static deserialize(v){const I=new NormalModule({layer:null,type:"",resource:"",context:"",request:null,userRequest:null,rawRequest:null,loaders:null,matchResource:null,parser:null,parserOptions:null,generator:null,generatorOptions:null,resolveOptions:null});I.deserialize(v);return I}deserialize(v){const{read:I}=v;this._source=I();this.error=I();this._lastSuccessfulBuildMeta=I();this._forceBuild=I();this._codeGeneratorData=I();super.deserialize(v)}}yt(NormalModule,"webpack/lib/NormalModule");v.exports=NormalModule},79497:function(v,I,P){"use strict";const{getContext:R}=P(22955);const $=P(78175);const{AsyncSeriesBailHook:L,SyncWaterfallHook:q,SyncBailHook:K,SyncHook:ae,HookMap:ge}=P(84891);const be=P(23630);const xe=P(34803);const ve=P(8412);const Ce=P(48101);const{JAVASCRIPT_MODULE_TYPE_AUTO:Ne}=P(6041);const He=P(32594);const Qe=P(3134);const Je=P(70091);const Ve=P(94042);const Ke=P(71621);const Ye=P(62477);const Xe=P(11584);const{getScheme:Ze}=P(48537);const{cachedCleverMerge:et,cachedSetProperty:tt}=P(22298);const{join:nt}=P(80749);const{parseResource:st,parseResourceWithoutFragment:rt}=P(46579);const ot={};const it={};const at={};const ct=[];const lt=/^([^!]+)!=!/;const ut=/^[^.]/;const loaderToIdent=v=>{if(!v.options){return v.loader}if(typeof v.options==="string"){return`${v.loader}?${v.options}`}if(typeof v.options!=="object"){throw new Error("loader options must be string or object")}if(v.ident){return`${v.loader}??${v.ident}`}return`${v.loader}?${JSON.stringify(v.options)}`};const stringifyLoadersAndResource=(v,I)=>{let P="";for(const I of v){P+=`${loaderToIdent(I)}!`}return P+I};const needCalls=(v,I)=>P=>{if(--v===0){return I(P)}if(P&&v>0){v=Number.NaN;return I(P)}};const mergeGlobalOptions=(v,I,P)=>{const R=I.split("/");let $;let L="";for(const I of R){L=L?`${L}/${I}`:I;const P=v[L];if(typeof P==="object"){$=$===undefined?P:et($,P)}}if($===undefined){return P}return et($,P)};const deprecationChangedHookMessage=(v,I)=>{const P=I.taps.map((v=>v.name)).join(", ");return`NormalModuleFactory.${v} (${P}) is no longer a waterfall hook, but a bailing hook instead. `+"Do not return the passed object, but modify it instead. "+"Returning false will ignore the request and results in no module created."};const pt=new Ke([new Je("test","resource"),new Je("scheme"),new Je("mimetype"),new Je("dependency"),new Je("include","resource"),new Je("exclude","resource",true),new Je("resource"),new Je("resourceQuery"),new Je("resourceFragment"),new Je("realResource"),new Je("issuer"),new Je("compiler"),new Je("issuerLayer"),new Ve("assert","assertions",(v=>{if(v){return v._isLegacyAssert!==undefined}return false})),new Ve("with","assertions",(v=>{if(v){return!v._isLegacyAssert}return false})),new Ve("descriptionData"),new Qe("type"),new Qe("sideEffects"),new Qe("parser"),new Qe("resolve"),new Qe("generator"),new Qe("layer"),new Ye]);class NormalModuleFactory extends ve{constructor({context:v,fs:I,resolverFactory:P,options:$,associatedObjectForCache:be,layers:ve=false}){super();this.hooks=Object.freeze({resolve:new L(["resolveData"]),resolveForScheme:new ge((()=>new L(["resourceData","resolveData"]))),resolveInScheme:new ge((()=>new L(["resourceData","resolveData"]))),factorize:new L(["resolveData"]),beforeResolve:new L(["resolveData"]),afterResolve:new L(["resolveData"]),createModule:new L(["createData","resolveData"]),module:new q(["module","createData","resolveData"]),createParser:new ge((()=>new K(["parserOptions"]))),parser:new ge((()=>new ae(["parser","parserOptions"]))),createGenerator:new ge((()=>new K(["generatorOptions"]))),generator:new ge((()=>new ae(["generator","generatorOptions"]))),createModuleClass:new ge((()=>new K(["createData","resolveData"])))});this.resolverFactory=P;this.ruleSet=pt.compile([{rules:$.defaultRules},{rules:$.rules}]);this.context=v||"";this.fs=I;this._globalParserOptions=$.parser;this._globalGeneratorOptions=$.generator;this.parserCache=new Map;this.generatorCache=new Map;this._restoredUnsafeCacheEntries=new Set;const Ce=st.bindCache(be);const Qe=rt.bindCache(be);this._parseResourceWithoutFragment=Qe;this.hooks.factorize.tapAsync({name:"NormalModuleFactory",stage:100},((v,I)=>{this.hooks.resolve.callAsync(v,((P,R)=>{if(P)return I(P);if(R===false)return I();if(R instanceof xe)return I(null,R);if(typeof R==="object")throw new Error(`${deprecationChangedHookMessage("resolve",this.hooks.resolve)} Returning a Module object will result in this module used as result.`);this.hooks.afterResolve.callAsync(v,((P,R)=>{if(P)return I(P);if(typeof R==="object")throw new Error(deprecationChangedHookMessage("afterResolve",this.hooks.afterResolve));if(R===false)return I();const $=v.createData;this.hooks.createModule.callAsync($,v,((P,R)=>{if(!R){if(!v.request){return I(new Error("Empty dependency (no request)"))}R=this.hooks.createModuleClass.for($.settings.type).call($,v);if(!R){R=new He($)}}R=this.hooks.module.call(R,$,v);return I(null,R)}))}))}))}));this.hooks.resolve.tapAsync({name:"NormalModuleFactory",stage:100},((v,I)=>{const{contextInfo:P,context:$,dependencies:L,dependencyType:q,request:K,assertions:ae,resolveOptions:ge,fileDependencies:be,missingDependencies:xe,contextDependencies:He}=v;const Je=this.getResolver("loader");let Ve;let Ke;let Ye;let Xe=false;let st=false;let rt=false;const it=Ze($);let at=Ze(K);if(!at){let v=K;const I=lt.exec(K);if(I){let P=I[1];if(P.charCodeAt(0)===46){const v=P.charCodeAt(1);if(v===47||v===46&&P.charCodeAt(2)===47){P=nt(this.fs,$,P)}}Ve={resource:P,...Ce(P)};v=K.slice(I[0].length)}at=Ze(v);if(!at&&!it){const I=v.charCodeAt(0);const P=v.charCodeAt(1);Xe=I===45&&P===33;st=Xe||I===33;rt=I===33&&P===33;const R=v.slice(Xe||rt?2:st?1:0).split(/!+/);Ke=R.pop();Ye=R.map((v=>{const{path:I,query:P}=Qe(v);return{loader:I,options:P?P.slice(1):undefined}}));at=Ze(Ke)}else{Ke=v;Ye=ct}}else{Ke=K;Ye=ct}const ut={fileDependencies:be,missingDependencies:xe,contextDependencies:He};let pt;let dt;const ft=needCalls(2,(ge=>{if(ge)return I(ge);try{for(const v of dt){if(typeof v.options==="string"&&v.options[0]==="?"){const I=v.options.slice(1);if(I==="[[missing ident]]"){throw new Error("No ident is provided by referenced loader. "+"When using a function for Rule.use in config you need to "+"provide an 'ident' property for referenced loader options.")}v.options=this.ruleSet.references.get(I);if(v.options===undefined){throw new Error("Invalid ident is provided by referenced loader")}v.ident=I}}}catch(v){return I(v)}if(!pt){return I(null,L[0].createIgnoredModule($))}const be=(Ve!==undefined?`${Ve.resource}!=!`:"")+stringifyLoadersAndResource(dt,pt.resource);const xe={};const Ce=[];const He=[];const Qe=[];let Ke;let Ye;if(Ve&&typeof(Ke=Ve.resource)==="string"&&(Ye=/\.webpack\[([^\]]+)\]$/.exec(Ke))){xe.type=Ye[1];Ve.resource=Ve.resource.slice(0,-xe.type.length-10)}else{xe.type=Ne;const v=Ve||pt;const I=this.ruleSet.exec({resource:v.path,realResource:pt.path,resourceQuery:v.query,resourceFragment:v.fragment,scheme:at,assertions:ae,mimetype:Ve?"":pt.data.mimetype||"",dependency:q,descriptionData:Ve?undefined:pt.data.descriptionFileData,issuer:P.issuer,compiler:P.compiler,issuerLayer:P.issuerLayer||""});for(const v of I){if(v.type==="type"&&rt){continue}if(v.type==="use"){if(!st&&!rt){He.push(v.value)}}else if(v.type==="use-post"){if(!rt){Ce.push(v.value)}}else if(v.type==="use-pre"){if(!Xe&&!rt){Qe.push(v.value)}}else if(typeof v.value==="object"&&v.value!==null&&typeof xe[v.type]==="object"&&xe[v.type]!==null){xe[v.type]=et(xe[v.type],v.value)}else{xe[v.type]=v.value}}}let Ze;let tt;let nt;const ot=needCalls(3,($=>{if($){return I($)}const L=Ze;if(Ve===undefined){for(const v of dt)L.push(v);for(const v of tt)L.push(v)}else{for(const v of tt)L.push(v);for(const v of dt)L.push(v)}for(const v of nt)L.push(v);const q=xe.type;const ae=xe.resolve;const ge=xe.layer;if(ge!==undefined&&!ve){return I(new Error("'Rule.layer' is only allowed when 'experiments.layers' is enabled"))}try{Object.assign(v.createData,{layer:ge===undefined?P.issuerLayer||null:ge,request:stringifyLoadersAndResource(L,pt.resource),userRequest:be,rawRequest:K,loaders:L,resource:pt.resource,context:pt.context||R(pt.resource),matchResource:Ve?Ve.resource:undefined,resourceResolveData:pt.data,settings:xe,type:q,parser:this.getParser(q,xe.parser),parserOptions:xe.parser,generator:this.getGenerator(q,xe.generator),generatorOptions:xe.generator,resolveOptions:ae})}catch(v){return I(v)}I()}));this.resolveRequestArray(P,this.context,Ce,Je,ut,((v,I)=>{Ze=I;ot(v)}));this.resolveRequestArray(P,this.context,He,Je,ut,((v,I)=>{tt=I;ot(v)}));this.resolveRequestArray(P,this.context,Qe,Je,ut,((v,I)=>{nt=I;ot(v)}))}));this.resolveRequestArray(P,it?this.context:$,Ye,Je,ut,((v,I)=>{if(v)return ft(v);dt=I;ft()}));const defaultResolve=v=>{if(/^($|\?)/.test(Ke)){pt={resource:Ke,data:{},...Ce(Ke)};ft()}else{const I=this.getResolver("normal",q?tt(ge||ot,"dependencyType",q):ge);this.resolveResource(P,v,Ke,I,ut,((v,I,P)=>{if(v)return ft(v);if(I!==false){const v=I;pt={resource:v,data:P,...Ce(v)}}ft()}))}};if(at){pt={resource:Ke,data:{},path:undefined,query:undefined,fragment:undefined,context:undefined};this.hooks.resolveForScheme.for(at).callAsync(pt,v,(v=>{if(v)return ft(v);ft()}))}else if(it){pt={resource:Ke,data:{},path:undefined,query:undefined,fragment:undefined,context:undefined};this.hooks.resolveInScheme.for(it).callAsync(pt,v,((v,I)=>{if(v)return ft(v);if(!I)return defaultResolve(this.context);ft()}))}else defaultResolve($)}))}cleanupForCache(){for(const v of this._restoredUnsafeCacheEntries){be.clearChunkGraphForModule(v);Ce.clearModuleGraphForModule(v);v.cleanupForCache()}}create(v,I){const P=v.dependencies;const R=v.context||this.context;const $=v.resolveOptions||ot;const L=P[0];const q=L.request;const K=L.assertions;const ae=v.contextInfo;const ge=new Xe;const be=new Xe;const xe=new Xe;const ve=P.length>0&&P[0].category||"";const Ce={contextInfo:ae,resolveOptions:$,context:R,request:q,assertions:K,dependencies:P,dependencyType:ve,fileDependencies:ge,missingDependencies:be,contextDependencies:xe,createData:{},cacheable:true};this.hooks.beforeResolve.callAsync(Ce,((v,P)=>{if(v){return I(v,{fileDependencies:ge,missingDependencies:be,contextDependencies:xe,cacheable:false})}if(P===false){const v={fileDependencies:ge,missingDependencies:be,contextDependencies:xe,cacheable:Ce.cacheable};if(Ce.ignoredModule){v.module=Ce.ignoredModule}return I(null,v)}if(typeof P==="object")throw new Error(deprecationChangedHookMessage("beforeResolve",this.hooks.beforeResolve));this.hooks.factorize.callAsync(Ce,((v,P)=>{if(v){return I(v,{fileDependencies:ge,missingDependencies:be,contextDependencies:xe,cacheable:false})}const R={module:P,fileDependencies:ge,missingDependencies:be,contextDependencies:xe,cacheable:Ce.cacheable};I(null,R)}))}))}resolveResource(v,I,P,R,$,L){R.resolve(v,I,P,$,((q,K,ae)=>{if(q){return this._resolveResourceErrorHints(q,v,I,P,R,$,((v,I)=>{if(v){q.message+=`\nA fatal error happened during resolving additional hints for this error: ${v.message}`;q.stack+=`\n\nA fatal error happened during resolving additional hints for this error:\n${v.stack}`;return L(q)}if(I&&I.length>0){q.message+=`\n${I.join("\n\n")}`}let P=false;const $=Array.from(R.options.extensions);const K=$.map((v=>{if(ut.test(v)){P=true;return`.${v}`}return v}));if(P){q.message+=`\nDid you miss the leading dot in 'resolve.extensions'? Did you mean '${JSON.stringify(K)}' instead of '${JSON.stringify($)}'?`}L(q)}))}L(q,K,ae)}))}_resolveResourceErrorHints(v,I,P,R,L,q,K){$.parallel([v=>{if(!L.options.fullySpecified)return v();L.withOptions({fullySpecified:false}).resolve(I,P,R,q,((I,P)=>{if(!I&&P){const I=st(P).path.replace(/^.*[\\/]/,"");return v(null,`Did you mean '${I}'?\nBREAKING CHANGE: The request '${R}' failed to resolve only because it was resolved as fully specified\n(probably because the origin is strict EcmaScript Module, e. g. a module with javascript mimetype, a '*.mjs' file, or a '*.js' file where the package.json contains '"type": "module"').\nThe extension in the request is mandatory for it to be fully specified.\nAdd the extension to the request.`)}v()}))},v=>{if(!L.options.enforceExtension)return v();L.withOptions({enforceExtension:false,extensions:[]}).resolve(I,P,R,q,((I,P)=>{if(!I&&P){let I="";const P=/(\.[^.]+)(\?|$)/.exec(R);if(P){const v=R.replace(/(\.[^.]+)(\?|$)/,"$2");I=L.options.extensions.has(P[1])?`Did you mean '${v}'?`:`Did you mean '${v}'? Also note that '${P[1]}' is not in 'resolve.extensions' yet and need to be added for this to work?`}else{I="Did you mean to omit the extension or to remove 'resolve.enforceExtension'?"}return v(null,`The request '${R}' failed to resolve only because 'resolve.enforceExtension' was specified.\n${I}\nIncluding the extension in the request is no longer possible. Did you mean to enforce including the extension in requests with 'resolve.extensions: []' instead?`)}v()}))},v=>{if(/^\.\.?\//.test(R)||L.options.preferRelative){return v()}L.resolve(I,P,`./${R}`,q,((I,P)=>{if(I||!P)return v();const $=L.options.modules.map((v=>Array.isArray(v)?v.join(", "):v)).join(", ");v(null,`Did you mean './${R}'?\nRequests that should resolve in the current directory need to start with './'.\nRequests that start with a name are treated as module requests and resolve within module directories (${$}).\nIf changing the source code is not an option there is also a resolve options called 'preferRelative' which tries to resolve these kind of requests in the current directory too.`)}))}],((v,I)=>{if(v)return K(v);K(null,I.filter(Boolean))}))}resolveRequestArray(v,I,P,R,L,q){if(P.length===0)return q(null,P);$.map(P,((P,$)=>{R.resolve(v,I,P.loader,L,((q,K,ae)=>{if(q&&/^[^/]*$/.test(P.loader)&&!P.loader.endsWith("-loader")){return R.resolve(v,I,`${P.loader}-loader`,L,(v=>{if(!v){q.message=`${q.message}\n`+"BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\n"+`                 You need to specify '${P.loader}-loader' instead of '${P.loader}',\n`+"                 see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removed"}$(q)}))}if(q)return $(q);const ge=this._parseResourceWithoutFragment(K);const be=/\.mjs$/i.test(ge.path)?"module":/\.cjs$/i.test(ge.path)?"commonjs":ae.descriptionFileData===undefined?undefined:ae.descriptionFileData.type;const xe={loader:ge.path,type:be,options:P.options===undefined?ge.query?ge.query.slice(1):undefined:P.options,ident:P.options===undefined?undefined:P.ident};return $(null,xe)}))}),q)}getParser(v,I=it){let P=this.parserCache.get(v);if(P===undefined){P=new WeakMap;this.parserCache.set(v,P)}let R=P.get(I);if(R===undefined){R=this.createParser(v,I);P.set(I,R)}return R}createParser(v,I={}){I=mergeGlobalOptions(this._globalParserOptions,v,I);const P=this.hooks.createParser.for(v).call(I);if(!P){throw new Error(`No parser registered for ${v}`)}this.hooks.parser.for(v).call(P,I);return P}getGenerator(v,I=at){let P=this.generatorCache.get(v);if(P===undefined){P=new WeakMap;this.generatorCache.set(v,P)}let R=P.get(I);if(R===undefined){R=this.createGenerator(v,I);P.set(I,R)}return R}createGenerator(v,I={}){I=mergeGlobalOptions(this._globalGeneratorOptions,v,I);const P=this.hooks.createGenerator.for(v).call(I);if(!P){throw new Error(`No generator registered for ${v}`)}this.hooks.generator.for(v).call(P,I);return P}getResolver(v,I){return this.resolverFactory.get(v,I)}}v.exports=NormalModuleFactory},53339:function(v,I,P){"use strict";const{join:R,dirname:$}=P(80749);class NormalModuleReplacementPlugin{constructor(v,I){this.resourceRegExp=v;this.newResource=I}apply(v){const I=this.resourceRegExp;const P=this.newResource;v.hooks.normalModuleFactory.tap("NormalModuleReplacementPlugin",(L=>{L.hooks.beforeResolve.tap("NormalModuleReplacementPlugin",(v=>{if(I.test(v.request)){if(typeof P==="function"){P(v)}else{v.request=P}}}));L.hooks.afterResolve.tap("NormalModuleReplacementPlugin",(L=>{const q=L.createData;if(I.test(q.resource)){if(typeof P==="function"){P(L)}else{const I=v.inputFileSystem;if(P.startsWith("/")||P.length>1&&P[1]===":"){q.resource=P}else{q.resource=R(I,$(I,q.resource),P)}}}}))}))}}v.exports=NormalModuleReplacementPlugin},64152:function(v){"use strict";v.exports.STAGE_BASIC=-10;v.exports.STAGE_DEFAULT=0;v.exports.STAGE_ADVANCED=10},51572:function(v){"use strict";class OptionsApply{process(v,I){return v}}v.exports=OptionsApply},33157:function(v,I,P){"use strict";class Parser{parse(v,I){const R=P(50655);throw new R}}v.exports=Parser},95392:function(v){"use strict";class PlatformPlugin{constructor(v){this.platform=v}apply(v){v.hooks.environment.tap("PlatformPlugin",(()=>{v.platform={...v.platform,...this.platform}}))}}v.exports=PlatformPlugin},41598:function(v,I,P){"use strict";const R=P(27561);class PrefetchPlugin{constructor(v,I){if(I){this.context=v;this.request=I}else{this.context=null;this.request=v}}apply(v){v.hooks.compilation.tap("PrefetchPlugin",((v,{normalModuleFactory:I})=>{v.dependencyFactories.set(R,I)}));v.hooks.make.tapAsync("PrefetchPlugin",((I,P)=>{I.addModuleChain(this.context||v.context,new R(this.request),(v=>{P(v)}))}))}}v.exports=PrefetchPlugin},17531:function(v,I,P){"use strict";const R=P(46251);const $=P(34324);const L=P(32594);const q=P(86750);const{contextify:K}=P(46579);const ae=q(P(4485),(()=>P(27554)),{name:"Progress Plugin",baseDataPath:"options"});const median3=(v,I,P)=>v+I+P-Math.max(v,I,P)-Math.min(v,I,P);const createDefaultHandler=(v,I)=>{const P=[];const defaultHandler=(R,$,...L)=>{if(v){if(R===0){P.length=0}const v=[$,...L];const q=v.map((v=>v.replace(/\d+\/\d+ /g,"")));const K=Date.now();const ae=Math.max(q.length,P.length);for(let v=ae;v>=0;v--){const R=v<q.length?q[v]:undefined;const $=v<P.length?P[v]:undefined;if($){if(R!==$.value){const L=K-$.time;if($.value){let R=$.value;if(v>0){R=`${P[v-1].value} > ${R}`}const q=`${" | ".repeat(v)}${L} ms ${R}`;const K=L;{if(K>1e4){I.error(q)}else if(K>1e3){I.warn(q)}else if(K>10){I.info(q)}else if(K>5){I.log(q)}else{I.debug(q)}}}if(R===undefined){P.length=v}else{$.value=R;$.time=K;P.length=v+1}}}else{P[v]={value:R,time:K}}}}I.status(`${Math.floor(R*100)}%`,$,...L);if(R===1||!$&&L.length===0)I.status()};return defaultHandler};const ge=["import-module","load-module"];const be=new WeakMap;class ProgressPlugin{static getReporter(v){return be.get(v)}constructor(v={}){if(typeof v==="function"){v={handler:v}}ae(v);v={...ProgressPlugin.defaultOptions,...v};this.profile=v.profile;this.handler=v.handler;this.modulesCount=v.modulesCount;this.dependenciesCount=v.dependenciesCount;this.showEntries=v.entries;this.showModules=v.modules;this.showDependencies=v.dependencies;this.showActiveModules=v.activeModules;this.percentBy=v.percentBy}apply(v){const I=this.handler||createDefaultHandler(this.profile,v.getInfrastructureLogger("webpack.Progress"));if(v instanceof $){this._applyOnMultiCompiler(v,I)}else if(v instanceof R){this._applyOnCompiler(v,I)}}_applyOnMultiCompiler(v,I){const P=v.compilers.map((()=>[0]));for(const[R,$]of v.compilers.entries()){new ProgressPlugin(((v,$,...L)=>{P[R]=[v,$,...L];let q=0;for(const[v]of P)q+=v;I(q/P.length,`[${R}] ${$}`,...L)})).apply($)}}_applyOnCompiler(v,I){const P=this.showEntries;const R=this.showModules;const $=this.showDependencies;const L=this.showActiveModules;let q="";let ae="";let xe=0;let ve=0;let Ce=0;let Ne=0;let He=0;let Qe=0;let Je=0;let Ve=1;let Ke=0;let Ye=0;let Xe=0;const Ze=new Set;let et=0;const updateThrottled=()=>{if(et+500<Date.now())update()};const update=()=>{const ge=[];const be=Ke/Math.max(xe||this.modulesCount||1,Ne);const He=Xe/Math.max(Ce||this.dependenciesCount||1,Ve);const Je=Ye/Math.max(ve||1,Qe);let tt;switch(this.percentBy){case"entries":tt=He;break;case"dependencies":tt=Je;break;case"modules":tt=be;break;default:tt=median3(be,He,Je)}const nt=.1+tt*.55;if(ae){ge.push(`import loader ${K(v.context,ae,v.root)}`)}else{const v=[];if(P){v.push(`${Xe}/${Ve} entries`)}if($){v.push(`${Ye}/${Qe} dependencies`)}if(R){v.push(`${Ke}/${Ne} modules`)}if(L){v.push(`${Ze.size} active`)}if(v.length>0){ge.push(v.join(" "))}if(L){ge.push(q)}}I(nt,"building",...ge);et=Date.now()};const factorizeAdd=(v,I)=>{if(ge.includes(v.getContext())){Je++}Qe++;if(Qe<50||Qe%100===0)updateThrottled()};const factorizeDone=()=>{Ye++;if(Ye<50||Ye%100===0)updateThrottled()};const moduleAdd=(v,I)=>{if(ge.includes(v.getContext())){He++}Ne++;if(Ne<50||Ne%100===0)updateThrottled()};const moduleBuild=v=>{const I=v.identifier();if(I){Ze.add(I);q=I;update()}};const entryAdd=(v,I)=>{Ve++;if(Ve<5||Ve%10===0)updateThrottled()};const moduleDone=v=>{Ke++;if(L){const I=v.identifier();if(I){Ze.delete(I);if(q===I){q="";for(const v of Ze){q=v}update();return}}}if(Ke<50||Ke%100===0)updateThrottled()};const entryDone=(v,I)=>{Xe++;update()};const tt=v.getCache("ProgressPlugin").getItemCache("counts",null);let nt;v.hooks.beforeCompile.tap("ProgressPlugin",(()=>{if(!nt){nt=tt.getPromise().then((v=>{if(v){xe=xe||v.modulesCount;ve=ve||v.dependenciesCount}return v}),(v=>{}))}}));v.hooks.afterCompile.tapPromise("ProgressPlugin",(v=>{if(v.compiler.isChild())return Promise.resolve();return nt.then((async v=>{const I=Ne-He;const P=Qe-Je;if(!v||v.modulesCount!==I||v.dependenciesCount!==P){await tt.storePromise({modulesCount:I,dependenciesCount:P})}}))}));v.hooks.compilation.tap("ProgressPlugin",(P=>{if(P.compiler.isChild())return;xe=Ne;Ce=Ve;ve=Qe;Ne=He=Qe=Je=Ve=0;Ke=Ye=Xe=0;P.factorizeQueue.hooks.added.tap("ProgressPlugin",(v=>factorizeAdd(P.factorizeQueue,v)));P.factorizeQueue.hooks.result.tap("ProgressPlugin",factorizeDone);P.addModuleQueue.hooks.added.tap("ProgressPlugin",(v=>moduleAdd(P.addModuleQueue,v)));P.processDependenciesQueue.hooks.result.tap("ProgressPlugin",moduleDone);if(L){P.hooks.buildModule.tap("ProgressPlugin",moduleBuild)}P.hooks.addEntry.tap("ProgressPlugin",entryAdd);P.hooks.failedEntry.tap("ProgressPlugin",entryDone);P.hooks.succeedEntry.tap("ProgressPlugin",entryDone);if(false){}const R={finishModules:"finish module graph",seal:"plugins",optimizeDependencies:"dependencies optimization",afterOptimizeDependencies:"after dependencies optimization",beforeChunks:"chunk graph",afterChunks:"after chunk graph",optimize:"optimizing",optimizeModules:"module optimization",afterOptimizeModules:"after module optimization",optimizeChunks:"chunk optimization",afterOptimizeChunks:"after chunk optimization",optimizeTree:"module and chunk tree optimization",afterOptimizeTree:"after module and chunk tree optimization",optimizeChunkModules:"chunk modules optimization",afterOptimizeChunkModules:"after chunk modules optimization",reviveModules:"module reviving",beforeModuleIds:"before module ids",moduleIds:"module ids",optimizeModuleIds:"module id optimization",afterOptimizeModuleIds:"module id optimization",reviveChunks:"chunk reviving",beforeChunkIds:"before chunk ids",chunkIds:"chunk ids",optimizeChunkIds:"chunk id optimization",afterOptimizeChunkIds:"after chunk id optimization",recordModules:"record modules",recordChunks:"record chunks",beforeModuleHash:"module hashing",beforeCodeGeneration:"code generation",beforeRuntimeRequirements:"runtime requirements",beforeHash:"hashing",afterHash:"after hashing",recordHash:"record hash",beforeModuleAssets:"module assets processing",beforeChunkAssets:"chunk assets processing",processAssets:"asset processing",afterProcessAssets:"after asset optimization",record:"recording",afterSeal:"after seal"};const $=Object.keys(R).length;for(const[L,q]of Object.keys(R).entries()){const K=R[q];const ae=L/$*.25+.7;P.hooks[q].intercept({name:"ProgressPlugin",call(){I(ae,"sealing",K)},done(){be.set(v,undefined);I(ae,"sealing",K)},result(){I(ae,"sealing",K)},error(){I(ae,"sealing",K)},tap(v){be.set(P.compiler,((P,...R)=>{I(ae,"sealing",K,v.name,...R)}));I(ae,"sealing",K,v.name)}})}}));v.hooks.make.intercept({name:"ProgressPlugin",call(){I(.1,"building")},done(){I(.65,"building")}});const interceptHook=(P,R,$,L)=>{P.intercept({name:"ProgressPlugin",call(){I(R,$,L)},done(){be.set(v,undefined);I(R,$,L)},result(){I(R,$,L)},error(){I(R,$,L)},tap(P){be.set(v,((v,...q)=>{I(R,$,L,P.name,...q)}));I(R,$,L,P.name)}})};v.cache.hooks.endIdle.intercept({name:"ProgressPlugin",call(){I(0,"")}});interceptHook(v.cache.hooks.endIdle,.01,"cache","end idle");v.hooks.beforeRun.intercept({name:"ProgressPlugin",call(){I(0,"")}});interceptHook(v.hooks.beforeRun,.01,"setup","before run");interceptHook(v.hooks.run,.02,"setup","run");interceptHook(v.hooks.watchRun,.03,"setup","watch run");interceptHook(v.hooks.normalModuleFactory,.04,"setup","normal module factory");interceptHook(v.hooks.contextModuleFactory,.05,"setup","context module factory");interceptHook(v.hooks.beforeCompile,.06,"setup","before compile");interceptHook(v.hooks.compile,.07,"setup","compile");interceptHook(v.hooks.thisCompilation,.08,"setup","compilation");interceptHook(v.hooks.compilation,.09,"setup","compilation");interceptHook(v.hooks.finishMake,.69,"building","finish");interceptHook(v.hooks.emit,.95,"emitting","emit");interceptHook(v.hooks.afterEmit,.98,"emitting","after emit");interceptHook(v.hooks.done,.99,"done","plugins");v.hooks.done.intercept({name:"ProgressPlugin",done(){I(.99,"")}});interceptHook(v.cache.hooks.storeBuildDependencies,.99,"cache","store build dependencies");interceptHook(v.cache.hooks.shutdown,.99,"cache","shutdown");interceptHook(v.cache.hooks.beginIdle,.99,"cache","begin idle");interceptHook(v.hooks.watchClose,.99,"end","closing watch compilation");v.cache.hooks.beginIdle.intercept({name:"ProgressPlugin",done(){I(1,"")}});v.cache.hooks.shutdown.intercept({name:"ProgressPlugin",done(){I(1,"")}})}}ProgressPlugin.defaultOptions={profile:false,modulesCount:5e3,dependenciesCount:1e4,modules:true,dependencies:true,activeModules:false,entries:true};ProgressPlugin.createDefaultHandler=createDefaultHandler;v.exports=ProgressPlugin},27336:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$,JAVASCRIPT_MODULE_TYPE_ESM:L}=P(6041);const q=P(34022);const K=P(71434);const{approve:ae}=P(59932);const ge="ProvidePlugin";class ProvidePlugin{constructor(v){this.definitions=v}apply(v){const I=this.definitions;v.hooks.compilation.tap(ge,((v,{normalModuleFactory:P})=>{v.dependencyTemplates.set(q,new q.Template);v.dependencyFactories.set(K,P);v.dependencyTemplates.set(K,new K.Template);const handler=(v,P)=>{for(const P of Object.keys(I)){const R=[].concat(I[P]);const $=P.split(".");if($.length>0){for(const[I,P]of $.slice(1).entries()){const P=$.slice(0,I+1).join(".");v.hooks.canRename.for(P).tap(ge,ae)}}v.hooks.expression.for(P).tap(ge,(I=>{const $=P.includes(".")?`__webpack_provided_${P.replace(/\./g,"_dot_")}`:P;const L=new K(R[0],$,R.slice(1),I.range);L.loc=I.loc;v.state.module.addDependency(L);return true}));v.hooks.call.for(P).tap(ge,(I=>{const $=P.includes(".")?`__webpack_provided_${P.replace(/\./g,"_dot_")}`:P;const L=new K(R[0],$,R.slice(1),I.callee.range);L.loc=I.callee.loc;v.state.module.addDependency(L);v.walkExpressions(I.arguments);return true}))}};P.hooks.parser.for(R).tap(ge,handler);P.hooks.parser.for($).tap(ge,handler);P.hooks.parser.for(L).tap(ge,handler)}))}}v.exports=ProvidePlugin},88490:function(v,I,P){"use strict";const{OriginalSource:R,RawSource:$}=P(51255);const L=P(34803);const{JS_TYPES:q}=P(30021);const{JAVASCRIPT_MODULE_TYPE_DYNAMIC:K}=P(6041);const ae=P(65317);class RawModule extends L{constructor(v,I,P,R){super(K,null);this.sourceStr=v;this.identifierStr=I||this.sourceStr;this.readableIdentifierStr=P||this.identifierStr;this.runtimeRequirements=R||null}getSourceTypes(){return q}identifier(){return this.identifierStr}size(v){return Math.max(1,this.sourceStr.length)}readableIdentifier(v){return v.shorten(this.readableIdentifierStr)}needBuild(v,I){return I(null,!this.buildMeta)}build(v,I,P,R,$){this.buildMeta={};this.buildInfo={cacheable:true};$()}codeGeneration(v){const I=new Map;if(this.useSourceMap||this.useSimpleSourceMap){I.set("javascript",new R(this.sourceStr,this.identifier()))}else{I.set("javascript",new $(this.sourceStr))}return{sources:I,runtimeRequirements:this.runtimeRequirements}}updateHash(v,I){v.update(this.sourceStr);super.updateHash(v,I)}serialize(v){const{write:I}=v;I(this.sourceStr);I(this.identifierStr);I(this.readableIdentifierStr);I(this.runtimeRequirements);super.serialize(v)}deserialize(v){const{read:I}=v;this.sourceStr=I();this.identifierStr=I();this.readableIdentifierStr=I();this.runtimeRequirements=I();super.deserialize(v)}}ae(RawModule,"webpack/lib/RawModule");v.exports=RawModule},71801:function(v,I,P){"use strict";const{compareNumbers:R}=P(21398);const $=P(46579);class RecordIdsPlugin{constructor(v){this.options=v||{}}apply(v){const I=this.options.portableIds;const P=$.makePathsRelative.bindContextCache(v.context,v.root);const getModuleIdentifier=v=>{if(I){return P(v.identifier())}return v.identifier()};v.hooks.compilation.tap("RecordIdsPlugin",(v=>{v.hooks.recordModules.tap("RecordIdsPlugin",((I,P)=>{const $=v.chunkGraph;if(!P.modules)P.modules={};if(!P.modules.byIdentifier)P.modules.byIdentifier={};const L=new Set;for(const v of I){const I=$.getModuleId(v);if(typeof I!=="number")continue;const R=getModuleIdentifier(v);P.modules.byIdentifier[R]=I;L.add(I)}P.modules.usedIds=Array.from(L).sort(R)}));v.hooks.reviveModules.tap("RecordIdsPlugin",((I,P)=>{if(!P.modules)return;if(P.modules.byIdentifier){const R=v.chunkGraph;const $=new Set;for(const v of I){const I=R.getModuleId(v);if(I!==null)continue;const L=getModuleIdentifier(v);const q=P.modules.byIdentifier[L];if(q===undefined)continue;if($.has(q))continue;$.add(q);R.setModuleId(v,q)}}if(Array.isArray(P.modules.usedIds)){v.usedModuleIds=new Set(P.modules.usedIds)}}));const getChunkSources=v=>{const I=[];for(const P of v.groupsIterable){const R=P.chunks.indexOf(v);if(P.name){I.push(`${R} ${P.name}`)}else{for(const v of P.origins){if(v.module){if(v.request){I.push(`${R} ${getModuleIdentifier(v.module)} ${v.request}`)}else if(typeof v.loc==="string"){I.push(`${R} ${getModuleIdentifier(v.module)} ${v.loc}`)}else if(v.loc&&typeof v.loc==="object"&&"start"in v.loc){I.push(`${R} ${getModuleIdentifier(v.module)} ${JSON.stringify(v.loc.start)}`)}}}}}return I};v.hooks.recordChunks.tap("RecordIdsPlugin",((v,I)=>{if(!I.chunks)I.chunks={};if(!I.chunks.byName)I.chunks.byName={};if(!I.chunks.bySource)I.chunks.bySource={};const P=new Set;for(const R of v){if(typeof R.id!=="number")continue;const v=R.name;if(v)I.chunks.byName[v]=R.id;const $=getChunkSources(R);for(const v of $){I.chunks.bySource[v]=R.id}P.add(R.id)}I.chunks.usedIds=Array.from(P).sort(R)}));v.hooks.reviveChunks.tap("RecordIdsPlugin",((I,P)=>{if(!P.chunks)return;const R=new Set;if(P.chunks.byName){for(const v of I){if(v.id!==null)continue;if(!v.name)continue;const I=P.chunks.byName[v.name];if(I===undefined)continue;if(R.has(I))continue;R.add(I);v.id=I;v.ids=[I]}}if(P.chunks.bySource){for(const v of I){if(v.id!==null)continue;const I=getChunkSources(v);for(const $ of I){const I=P.chunks.bySource[$];if(I===undefined)continue;if(R.has(I))continue;R.add(I);v.id=I;v.ids=[I];break}}}if(Array.isArray(P.chunks.usedIds)){v.usedChunkIds=new Set(P.chunks.usedIds)}}))}))}}v.exports=RecordIdsPlugin},12981:function(v,I,P){"use strict";const{contextify:R}=P(46579);class RequestShortener{constructor(v,I){this.contextify=R.bindContextCache(v,I)}shorten(v){if(!v){return v}return this.contextify(v)}}v.exports=RequestShortener},95907:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$}=P(6041);const L=P(5205);const q=P(34022);const{toConstantDependency:K}=P(59932);const ae="RequireJsStuffPlugin";v.exports=class RequireJsStuffPlugin{apply(v){v.hooks.compilation.tap(ae,((v,{normalModuleFactory:I})=>{v.dependencyTemplates.set(q,new q.Template);const handler=(v,I)=>{if(I.requireJs===undefined||!I.requireJs){return}v.hooks.call.for("require.config").tap(ae,K(v,"undefined"));v.hooks.call.for("requirejs.config").tap(ae,K(v,"undefined"));v.hooks.expression.for("require.version").tap(ae,K(v,JSON.stringify("0.0.0")));v.hooks.expression.for("requirejs.onError").tap(ae,K(v,L.uncaughtErrorHandler,[L.uncaughtErrorHandler]))};I.hooks.parser.for(R).tap(ae,handler);I.hooks.parser.for($).tap(ae,handler)}))}}},62929:function(v,I,P){"use strict";const R=P(90878).ResolverFactory;const{HookMap:$,SyncHook:L,SyncWaterfallHook:q}=P(84891);const{cachedCleverMerge:K,removeOperations:ae,resolveByProperty:ge}=P(22298);const be={};const convertToResolveOptions=v=>{const{dependencyType:I,plugins:P,...R}=v;const $={...R,plugins:P&&P.filter((v=>v!=="..."))};if(!$.fileSystem){throw new Error("fileSystem is missing in resolveOptions, but it's required for enhanced-resolve")}const L=$;return ae(ge(L,"byDependency",I),["unsafeCache"])};v.exports=class ResolverFactory{constructor(){this.hooks=Object.freeze({resolveOptions:new $((()=>new q(["resolveOptions"]))),resolver:new $((()=>new L(["resolver","resolveOptions","userResolveOptions"])))});this.cache=new Map}get(v,I=be){let P=this.cache.get(v);if(!P){P={direct:new WeakMap,stringified:new Map};this.cache.set(v,P)}const R=P.direct.get(I);if(R){return R}const $=JSON.stringify(I);const L=P.stringified.get($);if(L){P.direct.set(I,L);return L}const q=this._create(v,I);P.direct.set(I,q);P.stringified.set($,q);return q}_create(v,I){const P={...I};const $=convertToResolveOptions(this.hooks.resolveOptions.for(v).call(I));const L=R.createResolver($);if(!L){throw new Error("No resolver created")}const q=new WeakMap;L.withOptions=I=>{const R=q.get(I);if(R!==undefined)return R;const $=K(P,I);const L=this.get(v,$);q.set(I,L);return L};this.hooks.resolver.for(v).call(L,$,P);return L}}},5205:function(v){"use strict";v.exports.require="__webpack_require__";v.exports.requireScope="__webpack_require__.*";v.exports.exports="__webpack_exports__";v.exports.thisAsExports="top-level-this-exports";v.exports.returnExportsFromRuntime="return-exports-from-runtime";v.exports.module="module";v.exports.moduleId="module.id";v.exports.moduleLoaded="module.loaded";v.exports.publicPath="__webpack_require__.p";v.exports.entryModuleId="__webpack_require__.s";v.exports.moduleCache="__webpack_require__.c";v.exports.moduleFactories="__webpack_require__.m";v.exports.moduleFactoriesAddOnly="__webpack_require__.m (add only)";v.exports.ensureChunk="__webpack_require__.e";v.exports.ensureChunkHandlers="__webpack_require__.f";v.exports.ensureChunkIncludeEntries="__webpack_require__.f (include entries)";v.exports.prefetchChunk="__webpack_require__.E";v.exports.prefetchChunkHandlers="__webpack_require__.F";v.exports.preloadChunk="__webpack_require__.G";v.exports.preloadChunkHandlers="__webpack_require__.H";v.exports.definePropertyGetters="__webpack_require__.d";v.exports.makeNamespaceObject="__webpack_require__.r";v.exports.createFakeNamespaceObject="__webpack_require__.t";v.exports.compatGetDefaultExport="__webpack_require__.n";v.exports.harmonyModuleDecorator="__webpack_require__.hmd";v.exports.nodeModuleDecorator="__webpack_require__.nmd";v.exports.getFullHash="__webpack_require__.h";v.exports.wasmInstances="__webpack_require__.w";v.exports.instantiateWasm="__webpack_require__.v";v.exports.uncaughtErrorHandler="__webpack_require__.oe";v.exports.scriptNonce="__webpack_require__.nc";v.exports.loadScript="__webpack_require__.l";v.exports.createScript="__webpack_require__.ts";v.exports.createScriptUrl="__webpack_require__.tu";v.exports.getTrustedTypesPolicy="__webpack_require__.tt";v.exports.hasFetchPriority="has fetch priority";v.exports.chunkName="__webpack_require__.cn";v.exports.runtimeId="__webpack_require__.j";v.exports.getChunkScriptFilename="__webpack_require__.u";v.exports.getChunkCssFilename="__webpack_require__.k";v.exports.hasCssModules="has css modules";v.exports.getChunkUpdateScriptFilename="__webpack_require__.hu";v.exports.getChunkUpdateCssFilename="__webpack_require__.hk";v.exports.startup="__webpack_require__.x";v.exports.startupNoDefault="__webpack_require__.x (no default handler)";v.exports.startupOnlyAfter="__webpack_require__.x (only after)";v.exports.startupOnlyBefore="__webpack_require__.x (only before)";v.exports.chunkCallback="webpackChunk";v.exports.startupEntrypoint="__webpack_require__.X";v.exports.onChunksLoaded="__webpack_require__.O";v.exports.externalInstallChunk="__webpack_require__.C";v.exports.interceptModuleExecution="__webpack_require__.i";v.exports.global="__webpack_require__.g";v.exports.shareScopeMap="__webpack_require__.S";v.exports.initializeSharing="__webpack_require__.I";v.exports.currentRemoteGetScope="__webpack_require__.R";v.exports.getUpdateManifestFilename="__webpack_require__.hmrF";v.exports.hmrDownloadManifest="__webpack_require__.hmrM";v.exports.hmrDownloadUpdateHandlers="__webpack_require__.hmrC";v.exports.hmrModuleData="__webpack_require__.hmrD";v.exports.hmrInvalidateModuleHandlers="__webpack_require__.hmrI";v.exports.hmrRuntimeStatePrefix="__webpack_require__.hmrS";v.exports.amdDefine="__webpack_require__.amdD";v.exports.amdOptions="__webpack_require__.amdO";v.exports.system="__webpack_require__.System";v.exports.hasOwnProperty="__webpack_require__.o";v.exports.systemContext="__webpack_require__.y";v.exports.baseURI="__webpack_require__.b";v.exports.relativeUrl="__webpack_require__.U";v.exports.asyncModule="__webpack_require__.a"},78994:function(v,I,P){"use strict";const{RawSource:R}=P(51255);const $=P(51255).OriginalSource;const L=P(34803);const{RUNTIME_TYPES:q}=P(30021);const{WEBPACK_MODULE_TYPE_RUNTIME:K}=P(6041);class RuntimeModule extends L{constructor(v,I=0){super(K);this.name=v;this.stage=I;this.buildMeta={};this.buildInfo={};this.compilation=undefined;this.chunk=undefined;this.chunkGraph=undefined;this.fullHash=false;this.dependentHash=false;this._cachedGeneratedCode=undefined}attach(v,I,P=v.chunkGraph){this.compilation=v;this.chunk=I;this.chunkGraph=P}identifier(){return`webpack/runtime/${this.name}`}readableIdentifier(v){return`webpack/runtime/${this.name}`}needBuild(v,I){return I(null,false)}build(v,I,P,R,$){$()}updateHash(v,I){v.update(this.name);v.update(`${this.stage}`);try{if(this.fullHash||this.dependentHash){v.update(this.generate())}else{v.update(this.getGeneratedCode())}}catch(I){v.update(I.message)}super.updateHash(v,I)}getSourceTypes(){return q}codeGeneration(v){const I=new Map;const P=this.getGeneratedCode();if(P){I.set(K,this.useSourceMap||this.useSimpleSourceMap?new $(P,this.identifier()):new R(P))}return{sources:I,runtimeRequirements:null}}size(v){try{const v=this.getGeneratedCode();return v?v.length:0}catch(v){return 0}}generate(){const v=P(50655);throw new v}getGeneratedCode(){if(this._cachedGeneratedCode){return this._cachedGeneratedCode}return this._cachedGeneratedCode=this.generate()}shouldIsolate(){return true}}RuntimeModule.STAGE_NORMAL=0;RuntimeModule.STAGE_BASIC=5;RuntimeModule.STAGE_ATTACH=10;RuntimeModule.STAGE_TRIGGER=20;v.exports=RuntimeModule},28252:function(v,I,P){"use strict";const R=P(5205);const{getChunkFilenameTemplate:$}=P(53296);const L=P(56711);const q=P(36926);const K=P(12465);const ae=P(88224);const ge=P(1878);const be=P(72719);const xe=P(17815);const ve=P(96587);const Ce=P(24287);const Ne=P(13129);const He=P(73301);const Qe=P(1445);const Je=P(2075);const Ve=P(17866);const Ke=P(30095);const Ye=P(52435);const Xe=P(25158);const Ze=P(28706);const et=P(69033);const tt=P(92778);const nt=P(99779);const st=P(49454);const rt=P(13542);const ot=P(6308);const it=P(17949);const at=P(910);const ct=P(89453);const lt=P(13594);const ut=lt((()=>P(36926)));const pt=lt((()=>P(53296)));const dt=[R.chunkName,R.runtimeId,R.compatGetDefaultExport,R.createFakeNamespaceObject,R.createScript,R.createScriptUrl,R.getTrustedTypesPolicy,R.definePropertyGetters,R.ensureChunk,R.entryModuleId,R.getFullHash,R.global,R.makeNamespaceObject,R.moduleCache,R.moduleFactories,R.moduleFactoriesAddOnly,R.interceptModuleExecution,R.publicPath,R.baseURI,R.relativeUrl,R.scriptNonce,R.uncaughtErrorHandler,R.asyncModule,R.wasmInstances,R.instantiateWasm,R.shareScopeMap,R.initializeSharing,R.loadScript,R.systemContext,R.onChunksLoaded];const ft={[R.moduleLoaded]:[R.module],[R.moduleId]:[R.module]};const ht={[R.definePropertyGetters]:[R.hasOwnProperty],[R.compatGetDefaultExport]:[R.definePropertyGetters],[R.createFakeNamespaceObject]:[R.definePropertyGetters,R.makeNamespaceObject,R.require],[R.initializeSharing]:[R.shareScopeMap],[R.shareScopeMap]:[R.hasOwnProperty]};class RuntimePlugin{apply(v){v.hooks.compilation.tap("RuntimePlugin",(v=>{const I=v.outputOptions.chunkLoading;const isChunkLoadingDisabledForChunk=v=>{const P=v.getEntryOptions();const R=P&&P.chunkLoading!==undefined?P.chunkLoading:I;return R===false};v.dependencyTemplates.set(L,new L.Template);for(const I of dt){v.hooks.runtimeRequirementInModule.for(I).tap("RuntimePlugin",((v,I)=>{I.add(R.requireScope)}));v.hooks.runtimeRequirementInTree.for(I).tap("RuntimePlugin",((v,I)=>{I.add(R.requireScope)}))}for(const I of Object.keys(ht)){const P=ht[I];v.hooks.runtimeRequirementInTree.for(I).tap("RuntimePlugin",((v,I)=>{for(const v of P)I.add(v)}))}for(const I of Object.keys(ft)){const P=ft[I];v.hooks.runtimeRequirementInModule.for(I).tap("RuntimePlugin",((v,I)=>{for(const v of P)I.add(v)}))}v.hooks.runtimeRequirementInTree.for(R.definePropertyGetters).tap("RuntimePlugin",(I=>{v.addRuntimeModule(I,new He);return true}));v.hooks.runtimeRequirementInTree.for(R.makeNamespaceObject).tap("RuntimePlugin",(I=>{v.addRuntimeModule(I,new et);return true}));v.hooks.runtimeRequirementInTree.for(R.createFakeNamespaceObject).tap("RuntimePlugin",(I=>{v.addRuntimeModule(I,new ve);return true}));v.hooks.runtimeRequirementInTree.for(R.hasOwnProperty).tap("RuntimePlugin",(I=>{v.addRuntimeModule(I,new Xe);return true}));v.hooks.runtimeRequirementInTree.for(R.compatGetDefaultExport).tap("RuntimePlugin",(I=>{v.addRuntimeModule(I,new be);return true}));v.hooks.runtimeRequirementInTree.for(R.runtimeId).tap("RuntimePlugin",(I=>{v.addRuntimeModule(I,new ot);return true}));v.hooks.runtimeRequirementInTree.for(R.publicPath).tap("RuntimePlugin",((I,P)=>{const{outputOptions:$}=v;const{publicPath:L,scriptType:q}=$;const K=I.getEntryOptions();const ge=K&&K.publicPath!==undefined?K.publicPath:L;if(ge==="auto"){const $=new ae;if(q!=="module")P.add(R.global);v.addRuntimeModule(I,$)}else{const P=new st(ge);if(typeof ge!=="string"||/\[(full)?hash\]/.test(ge)){P.fullHash=true}v.addRuntimeModule(I,P)}return true}));v.hooks.runtimeRequirementInTree.for(R.global).tap("RuntimePlugin",(I=>{v.addRuntimeModule(I,new Ye);return true}));v.hooks.runtimeRequirementInTree.for(R.asyncModule).tap("RuntimePlugin",(I=>{v.addRuntimeModule(I,new K);return true}));v.hooks.runtimeRequirementInTree.for(R.systemContext).tap("RuntimePlugin",(I=>{const P=I.getEntryOptions();const R=P&&P.library!==undefined?P.library.type:v.outputOptions.library.type;if(R==="system"){v.addRuntimeModule(I,new it)}return true}));v.hooks.runtimeRequirementInTree.for(R.getChunkScriptFilename).tap("RuntimePlugin",((I,P,{chunkGraph:$})=>{if(typeof v.outputOptions.chunkFilename==="string"&&/\[(full)?hash(:\d+)?\]/.test(v.outputOptions.chunkFilename)){P.add(R.getFullHash)}v.addRuntimeModule(I,new Je("javascript","javascript",R.getChunkScriptFilename,(I=>ut().chunkHasJs(I,$)&&(I.filenameTemplate||(I.canBeInitial()?v.outputOptions.filename:v.outputOptions.chunkFilename))),false));return true}));v.hooks.runtimeRequirementInTree.for(R.getChunkCssFilename).tap("RuntimePlugin",((I,P,{chunkGraph:L})=>{if(typeof v.outputOptions.cssChunkFilename==="string"&&/\[(full)?hash(:\d+)?\]/.test(v.outputOptions.cssChunkFilename)){P.add(R.getFullHash)}v.addRuntimeModule(I,new Je("css","css",R.getChunkCssFilename,(I=>pt().chunkHasCss(I,L)&&$(I,v.outputOptions)),P.has(R.hmrDownloadUpdateHandlers)));return true}));v.hooks.runtimeRequirementInTree.for(R.getChunkUpdateScriptFilename).tap("RuntimePlugin",((I,P)=>{if(/\[(full)?hash(:\d+)?\]/.test(v.outputOptions.hotUpdateChunkFilename))P.add(R.getFullHash);v.addRuntimeModule(I,new Je("javascript","javascript update",R.getChunkUpdateScriptFilename,(I=>v.outputOptions.hotUpdateChunkFilename),true));return true}));v.hooks.runtimeRequirementInTree.for(R.getUpdateManifestFilename).tap("RuntimePlugin",((I,P)=>{if(/\[(full)?hash(:\d+)?\]/.test(v.outputOptions.hotUpdateMainFilename)){P.add(R.getFullHash)}v.addRuntimeModule(I,new Ve("update manifest",R.getUpdateManifestFilename,v.outputOptions.hotUpdateMainFilename));return true}));v.hooks.runtimeRequirementInTree.for(R.ensureChunk).tap("RuntimePlugin",((I,P)=>{const $=I.hasAsyncChunks();if($){P.add(R.ensureChunkHandlers)}v.addRuntimeModule(I,new Qe(P));return true}));v.hooks.runtimeRequirementInTree.for(R.ensureChunkIncludeEntries).tap("RuntimePlugin",((v,I)=>{I.add(R.ensureChunkHandlers)}));v.hooks.runtimeRequirementInTree.for(R.shareScopeMap).tap("RuntimePlugin",((I,P)=>{v.addRuntimeModule(I,new at);return true}));v.hooks.runtimeRequirementInTree.for(R.loadScript).tap("RuntimePlugin",((I,P)=>{const $=Boolean(v.outputOptions.trustedTypes);if($){P.add(R.createScriptUrl)}const L=P.has(R.hasFetchPriority);v.addRuntimeModule(I,new Ze($,L));return true}));v.hooks.runtimeRequirementInTree.for(R.createScript).tap("RuntimePlugin",((I,P)=>{if(v.outputOptions.trustedTypes){P.add(R.getTrustedTypesPolicy)}v.addRuntimeModule(I,new Ce);return true}));v.hooks.runtimeRequirementInTree.for(R.createScriptUrl).tap("RuntimePlugin",((I,P)=>{if(v.outputOptions.trustedTypes){P.add(R.getTrustedTypesPolicy)}v.addRuntimeModule(I,new Ne);return true}));v.hooks.runtimeRequirementInTree.for(R.getTrustedTypesPolicy).tap("RuntimePlugin",((I,P)=>{v.addRuntimeModule(I,new Ke(P));return true}));v.hooks.runtimeRequirementInTree.for(R.relativeUrl).tap("RuntimePlugin",((I,P)=>{v.addRuntimeModule(I,new rt);return true}));v.hooks.runtimeRequirementInTree.for(R.onChunksLoaded).tap("RuntimePlugin",((I,P)=>{v.addRuntimeModule(I,new nt);return true}));v.hooks.runtimeRequirementInTree.for(R.baseURI).tap("RuntimePlugin",(I=>{if(isChunkLoadingDisabledForChunk(I)){v.addRuntimeModule(I,new ge);return true}}));v.hooks.runtimeRequirementInTree.for(R.scriptNonce).tap("RuntimePlugin",(I=>{v.addRuntimeModule(I,new tt);return true}));v.hooks.additionalTreeRuntimeRequirements.tap("RuntimePlugin",((I,P)=>{const{mainTemplate:R}=v;if(R.hooks.bootstrap.isUsed()||R.hooks.localVars.isUsed()||R.hooks.requireEnsure.isUsed()||R.hooks.requireExtensions.isUsed()){v.addRuntimeModule(I,new xe)}}));q.getCompilationHooks(v).chunkHash.tap("RuntimePlugin",((v,I,{chunkGraph:P})=>{const R=new ct;for(const I of P.getChunkRuntimeModulesIterable(v)){R.add(P.getModuleHash(I,v.runtime))}R.updateHash(I)}))}))}}v.exports=RuntimePlugin},92104:function(v,I,P){"use strict";const R=P(89959);const $=P(5205);const L=P(57227);const{equals:q}=P(29179);const K=P(61935);const ae=P(30158);const{forEachRuntime:ge,subtractRuntime:be}=P(86620);const noModuleIdErrorMessage=(v,I)=>`Module ${v.identifier()} has no id assigned.\nThis should not happen.\nIt's in these chunks: ${Array.from(I.getModuleChunksIterable(v),(v=>v.name||v.id||v.debugId)).join(", ")||"none"} (If module is in no chunk this indicates a bug in some chunk/module optimization logic)\nModule has these incoming connections: ${Array.from(I.moduleGraph.getIncomingConnections(v),(v=>`\n - ${v.originModule&&v.originModule.identifier()} ${v.dependency&&v.dependency.type} ${v.explanations&&Array.from(v.explanations).join(", ")||""}`)).join("")}`;function getGlobalObject(v){if(!v)return v;const I=v.trim();if(/^[_\p{L}][_0-9\p{L}]*$/iu.test(I)||/^([_\p{L}][_0-9\p{L}]*)?\(.*\)$/iu.test(I))return I;return`Object(${I})`}class RuntimeTemplate{constructor(v,I,P){this.compilation=v;this.outputOptions=I||{};this.requestShortener=P;this.globalObject=getGlobalObject(I.globalObject);this.contentHashReplacement="X".repeat(I.hashDigestLength)}isIIFE(){return this.outputOptions.iife}isModule(){return this.outputOptions.module}isNeutralPlatform(){return!this.outputOptions.environment.document&&!this.compilation.compiler.platform.node}supportsConst(){return this.outputOptions.environment.const}supportsArrowFunction(){return this.outputOptions.environment.arrowFunction}supportsAsyncFunction(){return this.outputOptions.environment.asyncFunction}supportsOptionalChaining(){return this.outputOptions.environment.optionalChaining}supportsForOf(){return this.outputOptions.environment.forOf}supportsDestructuring(){return this.outputOptions.environment.destructuring}supportsBigIntLiteral(){return this.outputOptions.environment.bigIntLiteral}supportsDynamicImport(){return this.outputOptions.environment.dynamicImport}supportsEcmaScriptModuleSyntax(){return this.outputOptions.environment.module}supportTemplateLiteral(){return this.outputOptions.environment.templateLiteral}supportNodePrefixForCoreModules(){return this.outputOptions.environment.nodePrefixForCoreModules}returningFunction(v,I=""){return this.supportsArrowFunction()?`(${I}) => (${v})`:`function(${I}) { return ${v}; }`}basicFunction(v,I){return this.supportsArrowFunction()?`(${v}) => {\n${L.indent(I)}\n}`:`function(${v}) {\n${L.indent(I)}\n}`}concatenation(...v){const I=v.length;if(I===2)return this._es5Concatenation(v);if(I===0)return'""';if(I===1){return typeof v[0]==="string"?JSON.stringify(v[0]):`"" + ${v[0].expr}`}if(!this.supportTemplateLiteral())return this._es5Concatenation(v);let P=0;let R=0;let $=false;for(const I of v){const v=typeof I!=="string";if(v){P+=3;R+=$?1:4}$=v}if($)R-=3;if(typeof v[0]!=="string"&&typeof v[1]==="string")R-=3;if(R<=P)return this._es5Concatenation(v);return`\`${v.map((v=>typeof v==="string"?v:`\${${v.expr}}`)).join("")}\``}_es5Concatenation(v){const I=v.map((v=>typeof v==="string"?JSON.stringify(v):v.expr)).join(" + ");return typeof v[0]!=="string"&&typeof v[1]!=="string"?`"" + ${I}`:I}expressionFunction(v,I=""){return this.supportsArrowFunction()?`(${I}) => (${v})`:`function(${I}) { ${v}; }`}emptyFunction(){return this.supportsArrowFunction()?"x => {}":"function() {}"}destructureArray(v,I){return this.supportsDestructuring()?`var [${v.join(", ")}] = ${I};`:L.asString(v.map(((v,P)=>`var ${v} = ${I}[${P}];`)))}destructureObject(v,I){return this.supportsDestructuring()?`var {${v.join(", ")}} = ${I};`:L.asString(v.map((v=>`var ${v} = ${I}${ae([v])};`)))}iife(v,I){return`(${this.basicFunction(v,I)})()`}forEach(v,I,P){return this.supportsForOf()?`for(const ${v} of ${I}) {\n${L.indent(P)}\n}`:`${I}.forEach(function(${v}) {\n${L.indent(P)}\n});`}comment({request:v,chunkName:I,chunkReason:P,message:R,exportName:$}){let q;if(this.outputOptions.pathinfo){q=[R,v,I,P].filter(Boolean).map((v=>this.requestShortener.shorten(v))).join(" | ")}else{q=[R,I,P].filter(Boolean).map((v=>this.requestShortener.shorten(v))).join(" | ")}if(!q)return"";if(this.outputOptions.pathinfo){return`${L.toComment(q)} `}return`${L.toNormalComment(q)} `}throwMissingModuleErrorBlock({request:v}){const I=`Cannot find module '${v}'`;return`var e = new Error(${JSON.stringify(I)}); e.code = 'MODULE_NOT_FOUND'; throw e;`}throwMissingModuleErrorFunction({request:v}){return`function webpackMissingModule() { ${this.throwMissingModuleErrorBlock({request:v})} }`}missingModule({request:v}){return`Object(${this.throwMissingModuleErrorFunction({request:v})}())`}missingModuleStatement({request:v}){return`${this.missingModule({request:v})};\n`}missingModulePromise({request:v}){return`Promise.resolve().then(${this.throwMissingModuleErrorFunction({request:v})})`}weakError({module:v,chunkGraph:I,request:P,idExpr:R,type:$}){const q=I.getModuleId(v);const K=q===null?JSON.stringify("Module is not available (weak dependency)"):R?`"Module '" + ${R} + "' is not available (weak dependency)"`:JSON.stringify(`Module '${q}' is not available (weak dependency)`);const ae=P?`${L.toNormalComment(P)} `:"";const ge=`var e = new Error(${K}); ${ae}e.code = 'MODULE_NOT_FOUND'; throw e;`;switch($){case"statements":return ge;case"promise":return`Promise.resolve().then(${this.basicFunction("",ge)})`;case"expression":return this.iife("",ge)}}moduleId({module:v,chunkGraph:I,request:P,weak:R}){if(!v){return this.missingModule({request:P})}const $=I.getModuleId(v);if($===null){if(R){return"null /* weak dependency, without id */"}throw new Error(`RuntimeTemplate.moduleId(): ${noModuleIdErrorMessage(v,I)}`)}return`${this.comment({request:P})}${JSON.stringify($)}`}moduleRaw({module:v,chunkGraph:I,request:P,weak:R,runtimeRequirements:L}){if(!v){return this.missingModule({request:P})}const q=I.getModuleId(v);if(q===null){if(R){return this.weakError({module:v,chunkGraph:I,request:P,type:"expression"})}throw new Error(`RuntimeTemplate.moduleId(): ${noModuleIdErrorMessage(v,I)}`)}L.add($.require);return`${$.require}(${this.moduleId({module:v,chunkGraph:I,request:P,weak:R})})`}moduleExports({module:v,chunkGraph:I,request:P,weak:R,runtimeRequirements:$}){return this.moduleRaw({module:v,chunkGraph:I,request:P,weak:R,runtimeRequirements:$})}moduleNamespace({module:v,chunkGraph:I,request:P,strict:R,weak:L,runtimeRequirements:q}){if(!v){return this.missingModule({request:P})}if(I.getModuleId(v)===null){if(L){return this.weakError({module:v,chunkGraph:I,request:P,type:"expression"})}throw new Error(`RuntimeTemplate.moduleNamespace(): ${noModuleIdErrorMessage(v,I)}`)}const K=this.moduleId({module:v,chunkGraph:I,request:P,weak:L});const ae=v.getExportsType(I.moduleGraph,R);switch(ae){case"namespace":return this.moduleRaw({module:v,chunkGraph:I,request:P,weak:L,runtimeRequirements:q});case"default-with-named":q.add($.createFakeNamespaceObject);return`${$.createFakeNamespaceObject}(${K}, 3)`;case"default-only":q.add($.createFakeNamespaceObject);return`${$.createFakeNamespaceObject}(${K}, 1)`;case"dynamic":q.add($.createFakeNamespaceObject);return`${$.createFakeNamespaceObject}(${K}, 7)`}}moduleNamespacePromise({chunkGraph:v,block:I,module:P,request:R,message:L,strict:q,weak:K,runtimeRequirements:ae}){if(!P){return this.missingModulePromise({request:R})}const ge=v.getModuleId(P);if(ge===null){if(K){return this.weakError({module:P,chunkGraph:v,request:R,type:"promise"})}throw new Error(`RuntimeTemplate.moduleNamespacePromise(): ${noModuleIdErrorMessage(P,v)}`)}const be=this.blockPromise({chunkGraph:v,block:I,message:L,runtimeRequirements:ae});let xe;let ve=JSON.stringify(v.getModuleId(P));const Ce=this.comment({request:R});let Ne="";if(K){if(ve.length>8){Ne+=`var id = ${ve}; `;ve="id"}ae.add($.moduleFactories);Ne+=`if(!${$.moduleFactories}[${ve}]) { ${this.weakError({module:P,chunkGraph:v,request:R,idExpr:ve,type:"statements"})} } `}const He=this.moduleId({module:P,chunkGraph:v,request:R,weak:K});const Qe=P.getExportsType(v.moduleGraph,q);let Je=16;switch(Qe){case"namespace":if(Ne){const I=this.moduleRaw({module:P,chunkGraph:v,request:R,weak:K,runtimeRequirements:ae});xe=`.then(${this.basicFunction("",`${Ne}return ${I};`)})`}else{ae.add($.require);xe=`.then(${$.require}.bind(${$.require}, ${Ce}${ve}))`}break;case"dynamic":Je|=4;case"default-with-named":Je|=2;case"default-only":ae.add($.createFakeNamespaceObject);if(v.moduleGraph.isAsync(P)){if(Ne){const I=this.moduleRaw({module:P,chunkGraph:v,request:R,weak:K,runtimeRequirements:ae});xe=`.then(${this.basicFunction("",`${Ne}return ${I};`)})`}else{ae.add($.require);xe=`.then(${$.require}.bind(${$.require}, ${Ce}${ve}))`}xe+=`.then(${this.returningFunction(`${$.createFakeNamespaceObject}(m, ${Je})`,"m")})`}else{Je|=1;if(Ne){const v=`${$.createFakeNamespaceObject}(${He}, ${Je})`;xe=`.then(${this.basicFunction("",`${Ne}return ${v};`)})`}else{xe=`.then(${$.createFakeNamespaceObject}.bind(${$.require}, ${Ce}${ve}, ${Je}))`}}break}return`${be||"Promise.resolve()"}${xe}`}runtimeConditionExpression({chunkGraph:v,runtimeCondition:I,runtime:P,runtimeRequirements:R}){if(I===undefined)return"true";if(typeof I==="boolean")return`${I}`;const L=new Set;ge(I,(I=>L.add(`${v.getRuntimeId(I)}`)));const q=new Set;ge(be(P,I),(I=>q.add(`${v.getRuntimeId(I)}`)));R.add($.runtimeId);return K.fromLists(Array.from(L),Array.from(q))($.runtimeId)}importStatement({update:v,module:I,chunkGraph:P,request:R,importVar:L,originModule:q,weak:K,runtimeRequirements:ae}){if(!I){return[this.missingModuleStatement({request:R}),""]}if(P.getModuleId(I)===null){if(K){return[this.weakError({module:I,chunkGraph:P,request:R,type:"statements"}),""]}throw new Error(`RuntimeTemplate.importStatement(): ${noModuleIdErrorMessage(I,P)}`)}const ge=this.moduleId({module:I,chunkGraph:P,request:R,weak:K});const be=v?"":"var ";const xe=I.getExportsType(P.moduleGraph,q.buildMeta.strictHarmonyModule);ae.add($.require);const ve=`/* harmony import */ ${be}${L} = ${$.require}(${ge});\n`;if(xe==="dynamic"){ae.add($.compatGetDefaultExport);return[ve,`/* harmony import */ ${be}${L}_default = /*#__PURE__*/${$.compatGetDefaultExport}(${L});\n`]}return[ve,""]}exportFromImport({moduleGraph:v,module:I,request:P,exportName:K,originModule:ge,asiSafe:be,isCall:xe,callContext:ve,defaultInterop:Ce,importVar:Ne,initFragments:He,runtime:Qe,runtimeRequirements:Je}){if(!I){return this.missingModule({request:P})}if(!Array.isArray(K)){K=K?[K]:[]}const Ve=I.getExportsType(v,ge.buildMeta.strictHarmonyModule);if(Ce){if(K.length>0&&K[0]==="default"){switch(Ve){case"dynamic":if(xe){return`${Ne}_default()${ae(K,1)}`}return be?`(${Ne}_default()${ae(K,1)})`:be===false?`;(${Ne}_default()${ae(K,1)})`:`${Ne}_default.a${ae(K,1)}`;case"default-only":case"default-with-named":K=K.slice(1);break}}else if(K.length>0){if(Ve==="default-only"){return`/* non-default import from non-esm module */undefined${ae(K,1)}`}else if(Ve!=="namespace"&&K[0]==="__esModule"){return"/* __esModule */true"}}else if(Ve==="default-only"||Ve==="default-with-named"){Je.add($.createFakeNamespaceObject);He.push(new R(`var ${Ne}_namespace_cache;\n`,R.STAGE_CONSTANTS,-1,`${Ne}_namespace_cache`));return`/*#__PURE__*/ ${be?"":be===false?";":"Object"}(${Ne}_namespace_cache || (${Ne}_namespace_cache = ${$.createFakeNamespaceObject}(${Ne}${Ve==="default-only"?"":", 2"})))`}}if(K.length>0){const P=v.getExportsInfo(I);const R=P.getUsedName(K,Qe);if(!R){const v=L.toNormalComment(`unused export ${ae(K)}`);return`${v} undefined`}const $=q(R,K)?"":`${L.toNormalComment(ae(K))} `;const ge=`${Ne}${$}${ae(R)}`;if(xe&&ve===false){return be?`(0,${ge})`:be===false?`;(0,${ge})`:`/*#__PURE__*/Object(${ge})`}return ge}return Ne}blockPromise({block:v,message:I,chunkGraph:P,runtimeRequirements:R}){if(!v){const v=this.comment({message:I});return`Promise.resolve(${v.trim()})`}const L=P.getBlockChunkGroup(v);if(!L||L.chunks.length===0){const v=this.comment({message:I});return`Promise.resolve(${v.trim()})`}const q=L.chunks.filter((v=>!v.hasRuntime()&&v.id!==null));const K=this.comment({message:I,chunkName:v.chunkName});if(q.length===1){const v=JSON.stringify(q[0].id);R.add($.ensureChunk);const I=L.options.fetchPriority;if(I){R.add($.hasFetchPriority)}return`${$.ensureChunk}(${K}${v}${I?`, ${JSON.stringify(I)}`:""})`}else if(q.length>0){R.add($.ensureChunk);const v=L.options.fetchPriority;if(v){R.add($.hasFetchPriority)}const requireChunkId=I=>`${$.ensureChunk}(${JSON.stringify(I.id)}${v?`, ${JSON.stringify(v)}`:""})`;return`Promise.all(${K.trim()}[${q.map(requireChunkId).join(", ")}])`}return`Promise.resolve(${K.trim()})`}asyncModuleFactory({block:v,chunkGraph:I,runtimeRequirements:P,request:R}){const $=v.dependencies[0];const L=I.moduleGraph.getModule($);const q=this.blockPromise({block:v,message:"",chunkGraph:I,runtimeRequirements:P});const K=this.returningFunction(this.moduleRaw({module:L,chunkGraph:I,request:R,runtimeRequirements:P}));return this.returningFunction(q.startsWith("Promise.resolve(")?`${K}`:`${q}.then(${this.returningFunction(K)})`)}syncModuleFactory({dependency:v,chunkGraph:I,runtimeRequirements:P,request:R}){const $=I.moduleGraph.getModule(v);const L=this.returningFunction(this.moduleRaw({module:$,chunkGraph:I,request:R,runtimeRequirements:P}));return this.returningFunction(L)}defineEsModuleFlagStatement({exportsArgument:v,runtimeRequirements:I}){I.add($.makeNamespaceObject);I.add($.exports);return`${$.makeNamespaceObject}(${v});\n`}}v.exports=RuntimeTemplate},48700:function(v){"use strict";class SelfModuleFactory{constructor(v){this.moduleGraph=v}create(v,I){const P=this.moduleGraph.getParentModule(v.dependencies[0]);I(null,{module:P})}}v.exports=SelfModuleFactory},26338:function(v,I,P){"use strict";v.exports=P(80142)},58709:function(v){"use strict";v.exports.formatSize=v=>{if(typeof v!=="number"||Number.isNaN(v)===true){return"unknown size"}if(v<=0){return"0 bytes"}const I=["bytes","KiB","MiB","GiB"];const P=Math.floor(Math.log(v)/Math.log(1024));return`${Number((v/1024**P).toPrecision(3))} ${I[P]}`}},99379:function(v,I,P){"use strict";const R=P(36926);class SourceMapDevToolModuleOptionsPlugin{constructor(v){this.options=v}apply(v){const I=this.options;if(I.module!==false){v.hooks.buildModule.tap("SourceMapDevToolModuleOptionsPlugin",(v=>{v.useSourceMap=true}));v.hooks.runtimeModule.tap("SourceMapDevToolModuleOptionsPlugin",(v=>{v.useSourceMap=true}))}else{v.hooks.buildModule.tap("SourceMapDevToolModuleOptionsPlugin",(v=>{v.useSimpleSourceMap=true}));v.hooks.runtimeModule.tap("SourceMapDevToolModuleOptionsPlugin",(v=>{v.useSimpleSourceMap=true}))}R.getCompilationHooks(v).useSourceMap.tap("SourceMapDevToolModuleOptionsPlugin",(()=>true))}}v.exports=SourceMapDevToolModuleOptionsPlugin},58425:function(v,I,P){"use strict";const R=P(78175);const{ConcatSource:$,RawSource:L}=P(51255);const q=P(29327);const K=P(20610);const ae=P(17531);const ge=P(99379);const be=P(86750);const xe=P(12471);const{relative:ve,dirname:Ce}=P(80749);const Ne=P(84634);const{makePathsAbsolute:He}=P(46579);const Qe=be(P(78331),(()=>P(89773)),{name:"SourceMap DevTool Plugin",baseDataPath:"options"});const Je=/[-[\]\\/{}()*+?.^$|]/g;const Ve=/\[contenthash(:\w+)?\]/;const Ke=/\.((c|m)?js|css)($|\?)/i;const Ye=/\.css($|\?)/i;const Xe=/\[map\]/g;const Ze=/\[url\]/g;const et=/^\n\/\/(.*)$/;const resetRegexpState=v=>{v.lastIndex=-1};const quoteMeta=v=>v.replace(Je,"\\$&");const getTaskForFile=(v,I,P,R,$,L)=>{let q;let K;if(I.sourceAndMap){const v=I.sourceAndMap(R);K=v.map;q=v.source}else{K=I.map(R);q=I.source()}if(!K||typeof q!=="string")return;const ae=$.options.context;const ge=$.compiler.root;const be=He.bindContextCache(ae,ge);const xe=K.sources.map((v=>{if(!v.startsWith("webpack://"))return v;v=be(v.slice(10));const I=$.findModule(v);return I||v}));return{file:v,asset:I,source:q,assetInfo:P,sourceMap:K,modules:xe,cacheItem:L}};class SourceMapDevToolPlugin{constructor(v={}){Qe(v);this.sourceMapFilename=v.filename;this.sourceMappingURLComment=v.append===false?false:v.append||"\n//# source"+"MappingURL=[url]";this.moduleFilenameTemplate=v.moduleFilenameTemplate||"webpack://[namespace]/[resourcePath]";this.fallbackModuleFilenameTemplate=v.fallbackModuleFilenameTemplate||"webpack://[namespace]/[resourcePath]?[hash]";this.namespace=v.namespace||"";this.options=v}apply(v){const I=v.outputFileSystem;const P=this.sourceMapFilename;const be=this.sourceMappingURLComment;const He=this.moduleFilenameTemplate;const Qe=this.namespace;const Je=this.fallbackModuleFilenameTemplate;const tt=v.requestShortener;const nt=this.options;nt.test=nt.test||Ke;const st=K.matchObject.bind(undefined,nt);v.hooks.compilation.tap("SourceMapDevToolPlugin",(v=>{new ge(nt).apply(v);v.hooks.processAssets.tapAsync({name:"SourceMapDevToolPlugin",stage:q.PROCESS_ASSETS_STAGE_DEV_TOOLING,additionalAssets:true},((q,ge)=>{const Ke=v.chunkGraph;const rt=v.getCache("SourceMapDevToolPlugin");const ot=new Map;const it=ae.getReporter(v.compiler)||(()=>{});const at=new Map;for(const I of v.chunks){for(const v of I.files){at.set(v,I)}for(const v of I.auxiliaryFiles){at.set(v,I)}}const ct=[];for(const v of Object.keys(q)){if(st(v)){ct.push(v)}}it(0);const lt=[];let ut=0;R.each(ct,((I,P)=>{const R=v.getAsset(I);if(R.info.related&&R.info.related.sourceMap){ut++;return P()}const $=at.get(I);const L=v.getPath(this.namespace,{chunk:$});const q=rt.getItemCache(I,rt.mergeEtags(rt.getLazyHashedEtag(R.source),L));q.get(((ae,ge)=>{if(ae){return P(ae)}if(ge){const{assets:R,assetsInfo:L}=ge;for(const P of Object.keys(R)){if(P===I){v.updateAsset(P,R[P],L[P])}else{v.emitAsset(P,R[P],L[P])}if(P!==I&&$!==undefined)$.auxiliaryFiles.add(P)}it(.5*++ut/ct.length,I,"restored cached SourceMap");return P()}it(.5*ut/ct.length,I,"generate SourceMap");const be=getTaskForFile(I,R.source,R.info,{module:nt.module,columns:nt.columns},v,q);if(be){const I=be.modules;for(let P=0;P<I.length;P++){const R=I[P];if(typeof R==="string"&&/^(data|https?):/.test(R)){ot.set(R,R);continue}if(!ot.get(R)){ot.set(R,K.createFilename(R,{moduleFilenameTemplate:He,namespace:L},{requestShortener:tt,chunkGraph:Ke,hashFunction:v.outputOptions.hashFunction}))}}lt.push(be)}it(.5*++ut/ct.length,I,"generated SourceMap");P()}))}),(q=>{if(q){return ge(q)}it(.5,"resolve sources");const ae=new Set(ot.values());const He=new Set;const st=Array.from(ot.keys()).sort(((v,I)=>{const P=typeof v==="string"?v:v.identifier();const R=typeof I==="string"?I:I.identifier();return P.length-R.length}));for(let I=0;I<st.length;I++){const P=st[I];let R=ot.get(P);let $=He.has(R);if(!$){He.add(R);continue}R=K.createFilename(P,{moduleFilenameTemplate:Je,namespace:Qe},{requestShortener:tt,chunkGraph:Ke,hashFunction:v.outputOptions.hashFunction});$=ae.has(R);if(!$){ot.set(P,R);ae.add(R);continue}while($){R+="*";$=ae.has(R)}ot.set(P,R);ae.add(R)}let rt=0;R.each(lt,((R,q)=>{const K=Object.create(null);const ae=Object.create(null);const ge=R.file;const He=at.get(ge);const Qe=R.sourceMap;const Je=R.source;const Ke=R.modules;it(.5+.5*rt/lt.length,ge,"attach SourceMap");const tt=Ke.map((v=>ot.get(v)));Qe.sources=tt;if(nt.noSources){Qe.sourcesContent=undefined}Qe.sourceRoot=nt.sourceRoot||"";Qe.file=ge;const st=P&&Ve.test(P);resetRegexpState(Ve);if(st&&R.assetInfo.contenthash){const v=R.assetInfo.contenthash;const I=Array.isArray(v)?v.map(quoteMeta).join("|"):quoteMeta(v);Qe.file=Qe.file.replace(new RegExp(I,"g"),(v=>"x".repeat(v.length)))}let ct=be;const ut=Ye.test(ge);resetRegexpState(Ye);if(ct!==false&&typeof ct!=="function"&&ut){ct=ct.replace(et,"\n/*$1*/")}if(nt.debugIds){const v=Ne(Je,Qe.file);Qe.debugId=v;ct=`\n//# debugId=${v}${ct}`}const pt=JSON.stringify(Qe);if(P){const R=ge;const q=st&&xe(v.outputOptions.hashFunction).update(pt).digest("hex");const be={chunk:He,filename:nt.fileContext?ve(I,`/${nt.fileContext}`,`/${R}`):R,contentHash:q};const{path:Ne,info:Qe}=v.getPathWithInfo(P,be);const Ve=nt.publicPath?nt.publicPath+Ne:ve(I,Ce(I,`/${ge}`),`/${Ne}`);let Ke=new L(Je);if(ct!==false){Ke=new $(Ke,v.getPath(ct,{url:Ve,...be}))}const Ye={related:{sourceMap:Ne}};K[ge]=Ke;ae[ge]=Ye;v.updateAsset(ge,Ke,Ye);const Xe=new L(pt);const Ze={...Qe,development:true};K[Ne]=Xe;ae[Ne]=Ze;v.emitAsset(Ne,Xe,Ze);if(He!==undefined)He.auxiliaryFiles.add(Ne)}else{if(ct===false){throw new Error("SourceMapDevToolPlugin: append can't be false when no filename is provided")}if(typeof ct==="function"){throw new Error("SourceMapDevToolPlugin: append can't be a function when no filename is provided")}const I=new $(new L(Je),ct.replace(Xe,(()=>pt)).replace(Ze,(()=>`data:application/json;charset=utf-8;base64,${Buffer.from(pt,"utf-8").toString("base64")}`)));K[ge]=I;ae[ge]=undefined;v.updateAsset(ge,I)}R.cacheItem.store({assets:K,assetsInfo:ae},(v=>{it(.5+.5*++rt/lt.length,R.file,"attached SourceMap");if(v){return q(v)}q()}))}),(v=>{it(1);ge(v)}))}))}))}))}}v.exports=SourceMapDevToolPlugin},74951:function(v){"use strict";class Stats{constructor(v){this.compilation=v}get hash(){return this.compilation.hash}get startTime(){return this.compilation.startTime}get endTime(){return this.compilation.endTime}hasWarnings(){return this.compilation.getWarnings().length>0||this.compilation.children.some((v=>v.getStats().hasWarnings()))}hasErrors(){return this.compilation.errors.length>0||this.compilation.children.some((v=>v.getStats().hasErrors()))}toJson(v){const I=this.compilation.createStatsOptions(v,{forToString:false});const P=this.compilation.createStatsFactory(I);return P.create("compilation",this.compilation,{compilation:this.compilation})}toString(v){const I=this.compilation.createStatsOptions(v,{forToString:true});const P=this.compilation.createStatsFactory(I);const R=this.compilation.createStatsPrinter(I);const $=P.create("compilation",this.compilation,{compilation:this.compilation});const L=R.print("compilation",$);return L===undefined?"":L}}v.exports=Stats},57227:function(v,I,P){"use strict";const{ConcatSource:R,PrefixSource:$}=P(51255);const{WEBPACK_MODULE_TYPE_RUNTIME:L}=P(6041);const q=P(5205);const K="a".charCodeAt(0);const ae="A".charCodeAt(0);const ge="z".charCodeAt(0)-K+1;const be=ge*2+2;const xe=be+10;const ve=/^function\s?\(\)\s?\{\r?\n?|\r?\n?\}$/g;const Ce=/^\t/gm;const Ne=/\r?\n/g;const He=/^([^a-zA-Z$_])/;const Qe=/[^a-zA-Z0-9$]+/g;const Je=/\*\//g;const Ve=/[^a-zA-Z0-9_!Â§$()=\-^Â°]+/g;const Ke=/^-|-$/g;class Template{static getFunctionContent(v){return v.toString().replace(ve,"").replace(Ce,"").replace(Ne,"\n")}static toIdentifier(v){if(typeof v!=="string")return"";return v.replace(He,"_$1").replace(Qe,"_")}static toComment(v){if(!v)return"";return`/*! ${v.replace(Je,"* /")} */`}static toNormalComment(v){if(!v)return"";return`/* ${v.replace(Je,"* /")} */`}static toPath(v){if(typeof v!=="string")return"";return v.replace(Ve,"-").replace(Ke,"")}static numberToIdentifier(v){if(v>=be){return Template.numberToIdentifier(v%be)+Template.numberToIdentifierContinuation(Math.floor(v/be))}if(v<ge){return String.fromCharCode(K+v)}v-=ge;if(v<ge){return String.fromCharCode(ae+v)}if(v===ge)return"_";return"$"}static numberToIdentifierContinuation(v){if(v>=xe){return Template.numberToIdentifierContinuation(v%xe)+Template.numberToIdentifierContinuation(Math.floor(v/xe))}if(v<ge){return String.fromCharCode(K+v)}v-=ge;if(v<ge){return String.fromCharCode(ae+v)}v-=ge;if(v<10){return`${v}`}if(v===10)return"_";return"$"}static indent(v){if(Array.isArray(v)){return v.map(Template.indent).join("\n")}const I=v.trimEnd();if(!I)return"";const P=I[0]==="\n"?"":"\t";return P+I.replace(/\n([^\n])/g,"\n\t$1")}static prefix(v,I){const P=Template.asString(v).trim();if(!P)return"";const R=P[0]==="\n"?"":I;return R+P.replace(/\n([^\n])/g,`\n${I}$1`)}static asString(v){if(Array.isArray(v)){return v.join("\n")}return v}static getModulesArrayBounds(v){let I=-Infinity;let P=Infinity;for(const R of v){const v=R.id;if(typeof v!=="number")return false;if(I<v)I=v;if(P>v)P=v}if(P<16+String(P).length){P=0}let R=-1;for(const I of v){R+=`${I.id}`.length+2}const $=P===0?I:16+`${P}`.length+I;return $<R?[P,I]:false}static renderChunkModules(v,I,P,$=""){const{chunkGraph:L}=v;const q=new R;if(I.length===0){return null}const K=I.map((v=>({id:L.getModuleId(v),source:P(v)||"false"})));const ae=Template.getModulesArrayBounds(K);if(ae){const v=ae[0];const I=ae[1];if(v!==0){q.add(`Array(${v}).concat(`)}q.add("[\n");const P=new Map;for(const v of K){P.set(v.id,v)}for(let R=v;R<=I;R++){const I=P.get(R);if(R!==v){q.add(",\n")}q.add(`/* ${R} */`);if(I){q.add("\n");q.add(I.source)}}q.add(`\n${$}]`);if(v!==0){q.add(")")}}else{q.add("{\n");for(let v=0;v<K.length;v++){const I=K[v];if(v!==0){q.add(",\n")}q.add(`\n/***/ ${JSON.stringify(I.id)}:\n`);q.add(I.source)}q.add(`\n\n${$}}`)}return q}static renderRuntimeModules(v,I){const P=new R;for(const R of v){const v=I.codeGenerationResults;let q;if(v){q=v.getSource(R,I.chunk.runtime,L)}else{const P=R.codeGeneration({chunkGraph:I.chunkGraph,dependencyTemplates:I.dependencyTemplates,moduleGraph:I.moduleGraph,runtimeTemplate:I.runtimeTemplate,runtime:I.chunk.runtime,codeGenerationResults:v});if(!P)continue;q=P.sources.get("runtime")}if(q){P.add(`${Template.toNormalComment(R.identifier())}\n`);if(!R.shouldIsolate()){P.add(q);P.add("\n\n")}else if(I.runtimeTemplate.supportsArrowFunction()){P.add("(() => {\n");P.add(new $("\t",q));P.add("\n})();\n\n")}else{P.add("!function() {\n");P.add(new $("\t",q));P.add("\n}();\n\n")}}}return P}static renderChunkRuntimeModules(v,I){return new $("/******/ ",new R(`function(${q.require}) { // webpackRuntimeModules\n`,this.renderRuntimeModules(v,I),"}\n"))}}v.exports=Template;v.exports.NUMBER_OF_IDENTIFIER_START_CHARS=be;v.exports.NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS=xe},38780:function(v,I,P){"use strict";const R=P(52759);const{basename:$,extname:L}=P(71017);const q=P(73837);const K=P(56754);const ae=P(34803);const{parseResource:ge}=P(46579);const be=/\[\\*([\w:]+)\\*\]/gi;const prepareId=v=>{if(typeof v!=="string")return v;if(/^"\s\+*.*\+\s*"$/.test(v)){const I=/^"\s\+*\s*(.*)\s*\+\s*"$/.exec(v);return`" + (${I[1]} + "").replace(/(^[.-]|[^a-zA-Z0-9_-])+/g, "_") + "`}return v.replace(/(^[.-]|[^a-zA-Z0-9_-])+/g,"_")};const hashLength=(v,I,P,R)=>{const fn=($,L,q)=>{let K;const ae=L&&Number.parseInt(L,10);if(ae&&I){K=I(ae)}else{const I=v($,L,q);K=ae?I.slice(0,ae):I}if(P){P.immutable=true;if(Array.isArray(P[R])){P[R]=[...P[R],K]}else if(P[R]){P[R]=[P[R],K]}else{P[R]=K}}return K};return fn};const replacer=(v,I)=>{const fn=(P,R,$)=>{if(typeof v==="function"){v=v()}if(v===null||v===undefined){if(!I){throw new Error(`Path variable ${P} not implemented in this context: ${$}`)}return""}return`${v}`};return fn};const xe=new Map;const ve=(()=>()=>{})();const deprecated=(v,I,P)=>{let R=xe.get(I);if(R===undefined){R=q.deprecate(ve,I,P);xe.set(I,R)}return(...I)=>{R();return v(...I)}};const replacePathVariables=(v,I,P)=>{const q=I.chunkGraph;const xe=new Map;if(typeof I.filename==="string"){const v=I.filename.match(/^data:([^;,]+)/);if(v){const P=R.extension(v[1]);const $=replacer("",true);const L=I.contentHash&&!/X+/.test(I.contentHash)?I.contentHash:false;const q=L?replacer(L):$;xe.set("file",$);xe.set("query",$);xe.set("fragment",$);xe.set("path",$);xe.set("base",q);xe.set("name",q);xe.set("ext",replacer(P?`.${P}`:"",true));xe.set("filebase",deprecated(q,"[filebase] is now [base]","DEP_WEBPACK_TEMPLATE_PATH_PLUGIN_REPLACE_PATH_VARIABLES_FILENAME"))}else{const{path:v,query:P,fragment:R}=ge(I.filename);const q=L(v);const K=$(v);const ae=K.slice(0,K.length-q.length);const be=v.slice(0,v.length-K.length);xe.set("file",replacer(v));xe.set("query",replacer(P,true));xe.set("fragment",replacer(R,true));xe.set("path",replacer(be,true));xe.set("base",replacer(K));xe.set("name",replacer(ae));xe.set("ext",replacer(q,true));xe.set("filebase",deprecated(replacer(K),"[filebase] is now [base]","DEP_WEBPACK_TEMPLATE_PATH_PLUGIN_REPLACE_PATH_VARIABLES_FILENAME"))}}if(I.hash){const v=hashLength(replacer(I.hash),I.hashWithLength,P,"fullhash");xe.set("fullhash",v);xe.set("hash",deprecated(v,"[hash] is now [fullhash] (also consider using [chunkhash] or [contenthash], see documentation for details)","DEP_WEBPACK_TEMPLATE_PATH_PLUGIN_REPLACE_PATH_VARIABLES_HASH"))}if(I.chunk){const v=I.chunk;const R=I.contentHashType;const $=replacer(v.id);const L=replacer(v.name||v.id);const q=hashLength(replacer(v instanceof K?v.renderedHash:v.hash),"hashWithLength"in v?v.hashWithLength:undefined,P,"chunkhash");const ae=hashLength(replacer(I.contentHash||R&&v.contentHash&&v.contentHash[R]),I.contentHashWithLength||("contentHashWithLength"in v&&v.contentHashWithLength?v.contentHashWithLength[R]:undefined),P,"contenthash");xe.set("id",$);xe.set("name",L);xe.set("chunkhash",q);xe.set("contenthash",ae)}if(I.module){const v=I.module;const R=replacer((()=>prepareId(v instanceof ae?q.getModuleId(v):v.id)));const $=hashLength(replacer((()=>v instanceof ae?q.getRenderedModuleHash(v,I.runtime):v.hash)),"hashWithLength"in v?v.hashWithLength:undefined,P,"modulehash");const L=hashLength(replacer(I.contentHash),undefined,P,"contenthash");xe.set("id",R);xe.set("modulehash",$);xe.set("contenthash",L);xe.set("hash",I.contentHash?L:$);xe.set("moduleid",deprecated(R,"[moduleid] is now [id]","DEP_WEBPACK_TEMPLATE_PATH_PLUGIN_REPLACE_PATH_VARIABLES_MODULE_ID"))}if(I.url){xe.set("url",replacer(I.url))}if(typeof I.runtime==="string"){xe.set("runtime",replacer((()=>prepareId(I.runtime))))}else{xe.set("runtime",replacer("_"))}if(typeof v==="function"){v=v(I,P)}v=v.replace(be,((I,P)=>{if(P.length+2===I.length){const R=/^(\w+)(?::(\w+))?$/.exec(P);if(!R)return I;const[,$,L]=R;const q=xe.get($);if(q!==undefined){return q(I,L,v)}}else if(I.startsWith("[\\")&&I.endsWith("\\]")){return`[${I.slice(2,-2)}]`}return I}));return v};const Ce="TemplatedPathPlugin";class TemplatedPathPlugin{apply(v){v.hooks.compilation.tap(Ce,(v=>{v.hooks.assetPath.tap(Ce,replacePathVariables)}))}}v.exports=TemplatedPathPlugin},65754:function(v,I,P){"use strict";const R=P(94252);const $=P(65317);class UnhandledSchemeError extends R{constructor(v,I){super(`Reading from "${I}" is not handled by plugins (Unhandled scheme).`+'\nWebpack supports "data:" and "file:" URIs by default.'+`\nYou may need an additional plugin to handle "${v}:" URIs.`);this.file=I;this.name="UnhandledSchemeError"}}$(UnhandledSchemeError,"webpack/lib/UnhandledSchemeError","UnhandledSchemeError");v.exports=UnhandledSchemeError},53966:function(v,I,P){"use strict";const R=P(94252);const $=P(65317);class UnsupportedFeatureWarning extends R{constructor(v,I){super(v);this.name="UnsupportedFeatureWarning";this.loc=I;this.hideStack=true}}$(UnsupportedFeatureWarning,"webpack/lib/UnsupportedFeatureWarning");v.exports=UnsupportedFeatureWarning},42313:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$,JAVASCRIPT_MODULE_TYPE_ESM:L}=P(6041);const q=P(34022);const K="UseStrictPlugin";class UseStrictPlugin{apply(v){v.hooks.compilation.tap(K,((v,{normalModuleFactory:I})=>{const handler=(v,I)=>{v.hooks.program.tap(K,(P=>{const R=P.body[0];if(R&&R.type==="ExpressionStatement"&&R.expression.type==="Literal"&&R.expression.value==="use strict"){const I=new q("",R.range);I.loc=R.loc;v.state.module.addPresentationalDependency(I);v.state.module.buildInfo.strict=true}if(I.overrideStrict){v.state.module.buildInfo.strict=I.overrideStrict==="strict"}}))};I.hooks.parser.for(R).tap(K,handler);I.hooks.parser.for($).tap(K,handler);I.hooks.parser.for(L).tap(K,handler)}))}}v.exports=UseStrictPlugin},23910:function(v,I,P){"use strict";const R=P(76649);class WarnCaseSensitiveModulesPlugin{apply(v){v.hooks.compilation.tap("WarnCaseSensitiveModulesPlugin",(v=>{v.hooks.seal.tap("WarnCaseSensitiveModulesPlugin",(()=>{const I=new Map;for(const P of v.modules){const v=P.identifier();if(P.resourceResolveData!==undefined&&P.resourceResolveData.encodedContent!==undefined){continue}const R=v.toLowerCase();let $=I.get(R);if($===undefined){$=new Map;I.set(R,$)}$.set(v,P)}for(const P of I){const I=P[1];if(I.size>1){v.warnings.push(new R(I.values(),v.moduleGraph))}}}))}))}}v.exports=WarnCaseSensitiveModulesPlugin},2077:function(v,I,P){"use strict";const R=P(94252);class WarnDeprecatedOptionPlugin{constructor(v,I,P){this.option=v;this.value=I;this.suggestion=P}apply(v){v.hooks.thisCompilation.tap("WarnDeprecatedOptionPlugin",(v=>{v.warnings.push(new DeprecatedOptionWarning(this.option,this.value,this.suggestion))}))}}class DeprecatedOptionWarning extends R{constructor(v,I,P){super();this.name="DeprecatedOptionWarning";this.message="configuration\n"+`The value '${I}' for option '${v}' is deprecated. `+`Use '${P}' instead.`}}v.exports=WarnDeprecatedOptionPlugin},92297:function(v,I,P){"use strict";const R=P(20798);class WarnNoModeSetPlugin{apply(v){v.hooks.thisCompilation.tap("WarnNoModeSetPlugin",(v=>{v.warnings.push(new R)}))}}v.exports=WarnNoModeSetPlugin},80488:function(v,I,P){"use strict";const{groupBy:R}=P(29179);const $=P(86750);const L=$(P(6238),(()=>P(66161)),{name:"Watch Ignore Plugin",baseDataPath:"options"});const q="ignore";class IgnoringWatchFileSystem{constructor(v,I){this.wfs=v;this.paths=I}watch(v,I,P,$,L,K,ae){v=Array.from(v);I=Array.from(I);const ignored=v=>this.paths.some((I=>I instanceof RegExp?I.test(v):v.indexOf(I)===0));const[ge,be]=R(v,ignored);const[xe,ve]=R(I,ignored);const Ce=this.wfs.watch(be,ve,P,$,L,((v,I,P,R,$)=>{if(v)return K(v);for(const v of ge){I.set(v,q)}for(const v of xe){P.set(v,q)}K(null,I,P,R,$)}),ae);return{close:()=>Ce.close(),pause:()=>Ce.pause(),getContextTimeInfoEntries:()=>{const v=Ce.getContextTimeInfoEntries();for(const I of xe){v.set(I,q)}return v},getFileTimeInfoEntries:()=>{const v=Ce.getFileTimeInfoEntries();for(const I of ge){v.set(I,q)}return v},getInfo:Ce.getInfo&&(()=>{const v=Ce.getInfo();const{fileTimeInfoEntries:I,contextTimeInfoEntries:P}=v;for(const v of ge){I.set(v,q)}for(const v of xe){P.set(v,q)}return v})}}}class WatchIgnorePlugin{constructor(v){L(v);this.paths=v.paths}apply(v){v.hooks.afterEnvironment.tap("WatchIgnorePlugin",(()=>{v.watchFileSystem=new IgnoringWatchFileSystem(v.watchFileSystem,this.paths)}))}}v.exports=WatchIgnorePlugin},87370:function(v,I,P){"use strict";const R=P(74951);class Watching{constructor(v,I,P){this.startTime=null;this.invalid=false;this.handler=P;this.callbacks=[];this._closeCallbacks=undefined;this.closed=false;this.suspended=false;this.blocked=false;this._isBlocked=()=>false;this._onChange=()=>{};this._onInvalid=()=>{};if(typeof I==="number"){this.watchOptions={aggregateTimeout:I}}else if(I&&typeof I==="object"){this.watchOptions={...I}}else{this.watchOptions={}}if(typeof this.watchOptions.aggregateTimeout!=="number"){this.watchOptions.aggregateTimeout=20}this.compiler=v;this.running=false;this._initial=true;this._invalidReported=true;this._needRecords=true;this.watcher=undefined;this.pausedWatcher=undefined;this._collectedChangedFiles=undefined;this._collectedRemovedFiles=undefined;this._done=this._done.bind(this);process.nextTick((()=>{if(this._initial)this._invalidate()}))}_mergeWithCollected(v,I){if(!v)return;if(!this._collectedChangedFiles){this._collectedChangedFiles=new Set(v);this._collectedRemovedFiles=new Set(I)}else{for(const I of v){this._collectedChangedFiles.add(I);this._collectedRemovedFiles.delete(I)}for(const v of I){this._collectedChangedFiles.delete(v);this._collectedRemovedFiles.add(v)}}}_go(v,I,P,$){this._initial=false;if(this.startTime===null)this.startTime=Date.now();this.running=true;if(this.watcher){this.pausedWatcher=this.watcher;this.lastWatcherStartTime=Date.now();this.watcher.pause();this.watcher=null}else if(!this.lastWatcherStartTime){this.lastWatcherStartTime=Date.now()}this.compiler.fsStartTime=Date.now();if(P&&$&&v&&I){this._mergeWithCollected(P,$);this.compiler.fileTimestamps=v;this.compiler.contextTimestamps=I}else if(this.pausedWatcher){if(this.pausedWatcher.getInfo){const{changes:v,removals:I,fileTimeInfoEntries:P,contextTimeInfoEntries:R}=this.pausedWatcher.getInfo();this._mergeWithCollected(v,I);this.compiler.fileTimestamps=P;this.compiler.contextTimestamps=R}else{this._mergeWithCollected(this.pausedWatcher.getAggregatedChanges&&this.pausedWatcher.getAggregatedChanges(),this.pausedWatcher.getAggregatedRemovals&&this.pausedWatcher.getAggregatedRemovals());this.compiler.fileTimestamps=this.pausedWatcher.getFileTimeInfoEntries();this.compiler.contextTimestamps=this.pausedWatcher.getContextTimeInfoEntries()}}this.compiler.modifiedFiles=this._collectedChangedFiles;this._collectedChangedFiles=undefined;this.compiler.removedFiles=this._collectedRemovedFiles;this._collectedRemovedFiles=undefined;const run=()=>{if(this.compiler.idle){return this.compiler.cache.endIdle((v=>{if(v)return this._done(v);this.compiler.idle=false;run()}))}if(this._needRecords){return this.compiler.readRecords((v=>{if(v)return this._done(v);this._needRecords=false;run()}))}this.invalid=false;this._invalidReported=false;this.compiler.hooks.watchRun.callAsync(this.compiler,(v=>{if(v)return this._done(v);const onCompiled=(v,I)=>{if(v)return this._done(v,I);const P=I;if(this.invalid)return this._done(null,P);if(this.compiler.hooks.shouldEmit.call(P)===false){return this._done(null,P)}process.nextTick((()=>{const v=P.getLogger("webpack.Compiler");v.time("emitAssets");this.compiler.emitAssets(P,(I=>{v.timeEnd("emitAssets");if(I)return this._done(I,P);if(this.invalid)return this._done(null,P);v.time("emitRecords");this.compiler.emitRecords((I=>{v.timeEnd("emitRecords");if(I)return this._done(I,P);if(P.hooks.needAdditionalPass.call()){P.needAdditionalPass=true;P.startTime=this.startTime;P.endTime=Date.now();v.time("done hook");const I=new R(P);this.compiler.hooks.done.callAsync(I,(I=>{v.timeEnd("done hook");if(I)return this._done(I,P);this.compiler.hooks.additionalPass.callAsync((v=>{if(v)return this._done(v,P);this.compiler.compile(onCompiled)}))}));return}return this._done(null,P)}))}))}))};this.compiler.compile(onCompiled)}))};run()}_getStats(v){const I=new R(v);return I}_done(v,I){this.running=false;const P=I&&I.getLogger("webpack.Watching");let $;const handleError=(v,I)=>{this.compiler.hooks.failed.call(v);this.compiler.cache.beginIdle();this.compiler.idle=true;this.handler(v,$);if(!I){I=this.callbacks;this.callbacks=[]}for(const P of I)P(v)};if(this.invalid&&!this.suspended&&!this.blocked&&!(this._isBlocked()&&(this.blocked=true))){if(I){P.time("storeBuildDependencies");this.compiler.cache.storeBuildDependencies(I.buildDependencies,(v=>{P.timeEnd("storeBuildDependencies");if(v)return handleError(v);this._go()}))}else{this._go()}return}if(I){I.startTime=this.startTime;I.endTime=Date.now();$=new R(I)}this.startTime=null;if(v)return handleError(v);const L=this.callbacks;this.callbacks=[];P.time("done hook");this.compiler.hooks.done.callAsync($,(v=>{P.timeEnd("done hook");if(v)return handleError(v,L);this.handler(null,$);P.time("storeBuildDependencies");this.compiler.cache.storeBuildDependencies(I.buildDependencies,(v=>{P.timeEnd("storeBuildDependencies");if(v)return handleError(v,L);P.time("beginIdle");this.compiler.cache.beginIdle();this.compiler.idle=true;P.timeEnd("beginIdle");process.nextTick((()=>{if(!this.closed){this.watch(I.fileDependencies,I.contextDependencies,I.missingDependencies)}}));for(const v of L)v(null);this.compiler.hooks.afterDone.call($)}))}))}watch(v,I,P){this.pausedWatcher=null;this.watcher=this.compiler.watchFileSystem.watch(v,I,P,this.lastWatcherStartTime,this.watchOptions,((v,I,P,R,$)=>{if(v){this.compiler.modifiedFiles=undefined;this.compiler.removedFiles=undefined;this.compiler.fileTimestamps=undefined;this.compiler.contextTimestamps=undefined;this.compiler.fsStartTime=undefined;return this.handler(v)}this._invalidate(I,P,R,$);this._onChange()}),((v,I)=>{if(!this._invalidReported){this._invalidReported=true;this.compiler.hooks.invalid.call(v,I)}this._onInvalid()}))}invalidate(v){if(v){this.callbacks.push(v)}if(!this._invalidReported){this._invalidReported=true;this.compiler.hooks.invalid.call(null,Date.now())}this._onChange();this._invalidate()}_invalidate(v,I,P,R){if(this.suspended||this._isBlocked()&&(this.blocked=true)){this._mergeWithCollected(P,R);return}if(this.running){this._mergeWithCollected(P,R);this.invalid=true}else{this._go(v,I,P,R)}}suspend(){this.suspended=true}resume(){if(this.suspended){this.suspended=false;this._invalidate()}}close(v){if(this._closeCallbacks){if(v){this._closeCallbacks.push(v)}return}const finalCallback=(v,I)=>{this.running=false;this.compiler.running=false;this.compiler.watching=undefined;this.compiler.watchMode=false;this.compiler.modifiedFiles=undefined;this.compiler.removedFiles=undefined;this.compiler.fileTimestamps=undefined;this.compiler.contextTimestamps=undefined;this.compiler.fsStartTime=undefined;const shutdown=v=>{this.compiler.hooks.watchClose.call();const I=this._closeCallbacks;this._closeCallbacks=undefined;for(const P of I)P(v)};if(I){const P=I.getLogger("webpack.Watching");P.time("storeBuildDependencies");this.compiler.cache.storeBuildDependencies(I.buildDependencies,(I=>{P.timeEnd("storeBuildDependencies");shutdown(v||I)}))}else{shutdown(v)}};this.closed=true;if(this.watcher){this.watcher.close();this.watcher=null}if(this.pausedWatcher){this.pausedWatcher.close();this.pausedWatcher=null}this._closeCallbacks=[];if(v){this._closeCallbacks.push(v)}if(this.running){this.invalid=true;this._done=finalCallback}else{finalCallback(null)}}}v.exports=Watching},94252:function(v,I,P){"use strict";const R=P(73837).inspect.custom;const $=P(65317);class WebpackError extends Error{constructor(v){super(v);this.details=undefined;this.module=undefined;this.loc=undefined;this.hideStack=undefined;this.chunk=undefined;this.file=undefined}[R](){return this.stack+(this.details?`\n${this.details}`:"")}serialize({write:v}){v(this.name);v(this.message);v(this.stack);v(this.details);v(this.loc);v(this.hideStack)}deserialize({read:v}){this.name=v();this.message=v();this.stack=v();this.details=v();this.loc=v();this.hideStack=v()}}$(WebpackError,"webpack/lib/WebpackError");v.exports=WebpackError},89382:function(v,I,P){"use strict";const R=P(30033);const{JAVASCRIPT_MODULE_TYPE_AUTO:$,JAVASCRIPT_MODULE_TYPE_DYNAMIC:L,JAVASCRIPT_MODULE_TYPE_ESM:q}=P(6041);const K=P(33170);const{toConstantDependency:ae}=P(59932);const ge="WebpackIsIncludedPlugin";class WebpackIsIncludedPlugin{apply(v){v.hooks.compilation.tap(ge,((v,{normalModuleFactory:I})=>{v.dependencyFactories.set(K,new R(I));v.dependencyTemplates.set(K,new K.Template);const handler=v=>{v.hooks.call.for("__webpack_is_included__").tap(ge,(I=>{if(I.type!=="CallExpression"||I.arguments.length!==1||I.arguments[0].type==="SpreadElement")return;const P=v.evaluateExpression(I.arguments[0]);if(!P.isString())return;const R=new K(P.string,I.range);R.loc=I.loc;v.state.module.addDependency(R);return true}));v.hooks.typeof.for("__webpack_is_included__").tap(ge,ae(v,JSON.stringify("function")))};I.hooks.parser.for($).tap(ge,handler);I.hooks.parser.for(L).tap(ge,handler);I.hooks.parser.for(q).tap(ge,handler)}))}}v.exports=WebpackIsIncludedPlugin},41569:function(v,I,P){"use strict";const R=P(51572);const $=P(44109);const L=P(36926);const q=P(36200);const K=P(36514);const ae=P(77529);const ge=P(71801);const be=P(28252);const xe=P(22733);const ve=P(72812);const Ce=P(26086);const Ne=P(98791);const He=P(89382);const Qe=P(38780);const Je=P(42313);const Ve=P(23910);const Ke=P(65487);const Ye=P(77936);const Xe=P(27779);const Ze=P(54256);const et=P(26539);const tt=P(2306);const nt=P(34216);const st=P(59882);const rt=P(84816);const ot=P(31782);const it=P(69987);const at=P(90325);const ct=P(39648);const lt=P(65954);const ut=P(10160);const pt=P(79752);const dt=P(127);const ft=P(15465);const ht=P(6382);const mt=P(34456);const{cleverMerge:gt}=P(22298);class WebpackOptionsApply extends R{constructor(){super()}process(v,I){I.outputPath=v.output.path;I.recordsInputPath=v.recordsInputPath||null;I.recordsOutputPath=v.recordsOutputPath||null;I.name=v.name;if(v.externals){const R=P(52925);new R(v.externalsType,v.externals).apply(I)}if(v.externalsPresets.node){const v=P(26076);(new v).apply(I)}if(v.externalsPresets.electronMain){const v=P(17191);new v("main").apply(I)}if(v.externalsPresets.electronPreload){const v=P(17191);new v("preload").apply(I)}if(v.externalsPresets.electronRenderer){const v=P(17191);new v("renderer").apply(I)}if(v.externalsPresets.electron&&!v.externalsPresets.electronMain&&!v.externalsPresets.electronPreload&&!v.externalsPresets.electronRenderer){const v=P(17191);(new v).apply(I)}if(v.externalsPresets.nwjs){const v=P(52925);new v("node-commonjs","nw.gui").apply(I)}if(v.externalsPresets.webAsync){const R=P(52925);new R("import",(({request:I,dependencyType:P},R)=>{if(P==="url"){if(/^(\/\/|https?:\/\/|#)/.test(I))return R(null,`asset ${I}`)}else if(v.experiments.css&&P==="css-import"){if(/^(\/\/|https?:\/\/|#)/.test(I))return R(null,`css-import ${I}`)}else if(v.experiments.css&&/^(\/\/|https?:\/\/|std:)/.test(I)){if(/^\.css(\?|$)/.test(I))return R(null,`css-import ${I}`);return R(null,`import ${I}`)}R()})).apply(I)}else if(v.externalsPresets.web){const R=P(52925);new R("module",(({request:I,dependencyType:P},R)=>{if(P==="url"){if(/^(\/\/|https?:\/\/|#)/.test(I))return R(null,`asset ${I}`)}else if(v.experiments.css&&P==="css-import"){if(/^(\/\/|https?:\/\/|#)/.test(I))return R(null,`css-import ${I}`)}else if(/^(\/\/|https?:\/\/|std:)/.test(I)){if(v.experiments.css&&/^\.css((\?)|$)/.test(I))return R(null,`css-import ${I}`);return R(null,`module ${I}`)}R()})).apply(I)}else if(v.externalsPresets.node&&v.experiments.css){const v=P(52925);new v("module",(({request:v,dependencyType:I},P)=>{if(I==="url"){if(/^(\/\/|https?:\/\/|#)/.test(v))return P(null,`asset ${v}`)}else if(I==="css-import"){if(/^(\/\/|https?:\/\/|#)/.test(v))return P(null,`css-import ${v}`)}else if(/^(\/\/|https?:\/\/|std:)/.test(v)){if(/^\.css(\?|$)/.test(v))return P(null,`css-import ${v}`);return P(null,`module ${v}`)}P()})).apply(I)}(new K).apply(I);if(typeof v.output.chunkFormat==="string"){switch(v.output.chunkFormat){case"array-push":{const v=P(7131);(new v).apply(I);break}case"commonjs":{const v=P(7947);(new v).apply(I);break}case"module":{const v=P(3636);(new v).apply(I);break}default:throw new Error(`Unsupported chunk format '${v.output.chunkFormat}'.`)}}const R=v.output.enabledChunkLoadingTypes;if(R.length>0){for(const v of R){const R=P(19353);new R(v).apply(I)}}const yt=v.output.enabledWasmLoadingTypes;if(yt.length>0){for(const v of yt){const R=P(13872);new R(v).apply(I)}}const bt=v.output.enabledLibraryTypes;if(bt.length>0){for(const v of bt){const R=P(48296);new R(v).apply(I)}}if(v.output.pathinfo){const R=P(52394);new R(v.output.pathinfo!==true).apply(I)}if(v.output.clean){const R=P(26075);new R(v.output.clean===true?{}:v.output.clean).apply(I)}if(v.devtool){if(v.devtool.includes("source-map")){const R=v.devtool.includes("hidden");const $=v.devtool.includes("inline");const L=v.devtool.includes("eval");const q=v.devtool.includes("cheap");const K=v.devtool.includes("module");const ae=v.devtool.includes("nosources");const ge=v.devtool.includes("debugids");const be=L?P(22202):P(58425);new be({filename:$?null:v.output.sourceMapFilename,moduleFilenameTemplate:v.output.devtoolModuleFilenameTemplate,fallbackModuleFilenameTemplate:v.output.devtoolFallbackModuleFilenameTemplate,append:R?false:undefined,module:K?true:!q,columns:!q,noSources:ae,namespace:v.output.devtoolNamespace,debugIds:ge}).apply(I)}else if(v.devtool.includes("eval")){const R=P(56625);new R({moduleFilenameTemplate:v.output.devtoolModuleFilenameTemplate,namespace:v.output.devtoolNamespace}).apply(I)}}(new L).apply(I);(new q).apply(I);(new $).apply(I);if(!v.experiments.outputModule){if(v.output.module){throw new Error("'output.module: true' is only allowed when 'experiments.outputModule' is enabled")}if(v.output.enabledLibraryTypes.includes("module")){throw new Error("library type \"module\" is only allowed when 'experiments.outputModule' is enabled")}if(v.output.enabledLibraryTypes.includes("modern-module")){throw new Error("library type \"modern-module\" is only allowed when 'experiments.outputModule' is enabled")}if(v.externalsType==="module"||v.externalsType==="module-import"){throw new Error("'externalsType: \"module\"' is only allowed when 'experiments.outputModule' is enabled")}}if(v.experiments.syncWebAssembly){const R=P(27767);new R({mangleImports:v.optimization.mangleWasmImports}).apply(I)}if(v.experiments.asyncWebAssembly){const R=P(26302);new R({mangleImports:v.optimization.mangleWasmImports}).apply(I)}if(v.experiments.css){const v=P(53296);(new v).apply(I)}if(v.experiments.lazyCompilation){const R=P(72035);const $=typeof v.experiments.lazyCompilation==="object"?v.experiments.lazyCompilation:{};new R({backend:typeof $.backend==="function"?$.backend:P(3102)({...$.backend,client:$.backend&&$.backend.client||v.externalsPresets.node?P.ab+"lazy-compilation-node.js":P.ab+"lazy-compilation-web.js"}),entries:!$||$.entries!==false,imports:!$||$.imports!==false,test:$&&$.test||undefined}).apply(I)}if(v.experiments.buildHttp){const R=P(55495);const $=v.experiments.buildHttp;new R($).apply(I)}(new ae).apply(I);I.hooks.entryOption.call(v.context,v.entry);(new be).apply(I);(new pt).apply(I);(new Ke).apply(I);(new Ye).apply(I);(new ve).apply(I);new et({topLevelAwait:v.experiments.topLevelAwait}).apply(I);if(v.amd!==false){const R=P(99947);const $=P(95907);new R(v.amd||{}).apply(I);(new $).apply(I)}(new Ze).apply(I);new rt({}).apply(I);if(v.node!==false){const R=P(93438);new R(v.node).apply(I)}new xe({module:v.output.module}).apply(I);(new Ne).apply(I);(new He).apply(I);(new Ce).apply(I);(new Je).apply(I);(new at).apply(I);(new it).apply(I);(new ot).apply(I);(new st).apply(I);(new tt).apply(I);(new ct).apply(I);(new nt).apply(I);(new lt).apply(I);new ut(v.output.workerChunkLoading,v.output.workerWasmLoading,v.output.module,v.output.workerPublicPath).apply(I);(new ft).apply(I);(new ht).apply(I);(new mt).apply(I);(new dt).apply(I);if(typeof v.mode!=="string"){const v=P(92297);(new v).apply(I)}const xt=P(20895);(new xt).apply(I);if(v.optimization.removeAvailableModules){const v=P(20363);(new v).apply(I)}if(v.optimization.removeEmptyChunks){const v=P(59291);(new v).apply(I)}if(v.optimization.mergeDuplicateChunks){const v=P(28688);(new v).apply(I)}if(v.optimization.flagIncludedChunks){const v=P(31430);(new v).apply(I)}if(v.optimization.sideEffects){const R=P(65886);new R(v.optimization.sideEffects===true).apply(I)}if(v.optimization.providedExports){const v=P(50722);(new v).apply(I)}if(v.optimization.usedExports){const R=P(66654);new R(v.optimization.usedExports==="global").apply(I)}if(v.optimization.innerGraph){const v=P(64168);(new v).apply(I)}if(v.optimization.mangleExports){const R=P(96881);new R(v.optimization.mangleExports!=="size").apply(I)}if(v.optimization.concatenateModules){const v=P(85811);(new v).apply(I)}if(v.optimization.splitChunks){const R=P(55346);new R(v.optimization.splitChunks).apply(I)}if(v.optimization.runtimeChunk){const R=P(85859);new R(v.optimization.runtimeChunk).apply(I)}if(!v.optimization.emitOnErrors){const v=P(48489);(new v).apply(I)}if(v.optimization.realContentHash){const R=P(92638);new R({hashFunction:v.output.hashFunction,hashDigest:v.output.hashDigest}).apply(I)}if(v.optimization.checkWasmTypes){const v=P(8804);(new v).apply(I)}const kt=v.optimization.moduleIds;if(kt){switch(kt){case"natural":{const v=P(43391);(new v).apply(I);break}case"named":{const v=P(45602);(new v).apply(I);break}case"hashed":{const R=P(2077);const $=P(95120);new R("optimization.moduleIds","hashed","deterministic").apply(I);new $({hashFunction:v.output.hashFunction}).apply(I);break}case"deterministic":{const v=P(55761);(new v).apply(I);break}case"size":{const v=P(47507);new v({prioritiseInitial:true}).apply(I);break}default:throw new Error(`webpack bug: moduleIds: ${kt} is not implemented`)}}const vt=v.optimization.chunkIds;if(vt){switch(vt){case"natural":{const v=P(70676);(new v).apply(I);break}case"named":{const v=P(97802);(new v).apply(I);break}case"deterministic":{const v=P(39621);(new v).apply(I);break}case"size":{const v=P(54170);new v({prioritiseInitial:true}).apply(I);break}case"total-size":{const v=P(54170);new v({prioritiseInitial:false}).apply(I);break}default:throw new Error(`webpack bug: chunkIds: ${vt} is not implemented`)}}if(v.optimization.nodeEnv){const R=P(64448);new R({"process.env.NODE_ENV":JSON.stringify(v.optimization.nodeEnv)}).apply(I)}if(v.optimization.minimize){for(const P of v.optimization.minimizer){if(typeof P==="function"){P.call(I,I)}else if(P!=="..."&&P){P.apply(I)}}}if(v.performance){const R=P(67371);new R(v.performance).apply(I)}(new Qe).apply(I);new ge({portableIds:v.optimization.portableRecords}).apply(I);(new Ve).apply(I);const wt=P(43844);new wt(v.snapshot.managedPaths,v.snapshot.immutablePaths,v.snapshot.unmanagedPaths).apply(I);if(v.cache&&typeof v.cache==="object"){const R=v.cache;switch(R.type){case"memory":{if(Number.isFinite(R.maxGenerations)){const v=P(12504);new v({maxGenerations:R.maxGenerations}).apply(I)}else{const v=P(99012);(new v).apply(I)}if(R.cacheUnaffected){if(!v.experiments.cacheUnaffected){throw new Error("'cache.cacheUnaffected: true' is only allowed when 'experiments.cacheUnaffected' is enabled")}I.moduleMemCaches=new Map}break}case"filesystem":{const $=P(96356);for(const v in R.buildDependencies){const P=R.buildDependencies[v];new $(P).apply(I)}if(!Number.isFinite(R.maxMemoryGenerations)){const v=P(99012);(new v).apply(I)}else if(R.maxMemoryGenerations!==0){const v=P(12504);new v({maxGenerations:R.maxMemoryGenerations}).apply(I)}if(R.memoryCacheUnaffected){if(!v.experiments.cacheUnaffected){throw new Error("'cache.memoryCacheUnaffected: true' is only allowed when 'experiments.cacheUnaffected' is enabled")}I.moduleMemCaches=new Map}switch(R.store){case"pack":{const $=P(75545);const L=P(75109);new $(new L({compiler:I,fs:I.intermediateFileSystem,context:v.context,cacheLocation:R.cacheLocation,version:R.version,logger:I.getInfrastructureLogger("webpack.cache.PackFileCacheStrategy"),snapshot:v.snapshot,maxAge:R.maxAge,profile:R.profile,allowCollectingMemory:R.allowCollectingMemory,compression:R.compression,readonly:R.readonly}),R.idleTimeout,R.idleTimeoutForInitialStore,R.idleTimeoutAfterLargeChanges).apply(I);break}default:throw new Error("Unhandled value for cache.store")}break}default:throw new Error(`Unknown cache type ${R.type}`)}}(new Xe).apply(I);if(v.ignoreWarnings&&v.ignoreWarnings.length>0){const R=P(37264);new R(v.ignoreWarnings).apply(I)}I.hooks.afterPlugins.call(I);if(!I.inputFileSystem){throw new Error("No input filesystem provided")}I.resolverFactory.hooks.resolveOptions.for("normal").tap("WebpackOptionsApply",(P=>{P=gt(v.resolve,P);P.fileSystem=I.inputFileSystem;return P}));I.resolverFactory.hooks.resolveOptions.for("context").tap("WebpackOptionsApply",(P=>{P=gt(v.resolve,P);P.fileSystem=I.inputFileSystem;P.resolveToContext=true;return P}));I.resolverFactory.hooks.resolveOptions.for("loader").tap("WebpackOptionsApply",(P=>{P=gt(v.resolveLoader,P);P.fileSystem=I.inputFileSystem;return P}));I.hooks.afterResolvers.call(I);return v}}v.exports=WebpackOptionsApply},81355:function(v,I,P){"use strict";const{applyWebpackOptionsDefaults:R}=P(52525);const{getNormalizedWebpackOptions:$}=P(92043);class WebpackOptionsDefaulter{process(v){const I=$(v);R(I);return I}}v.exports=WebpackOptionsDefaulter},44917:function(v,I,P){"use strict";const R=P(52759);const $=P(71017);const{RawSource:L}=P(51255);const q=P(40255);const K=P(52402);const{NO_TYPES:ae,ASSET_TYPES:ge,ASSET_AND_JS_TYPES:be,ASSET_AND_JS_AND_CSS_URL_TYPES:xe,ASSET_AND_CSS_URL_TYPES:ve,JS_TYPES:Ce,JS_AND_CSS_URL_TYPES:Ne,CSS_URL_TYPES:He}=P(30021);const{ASSET_MODULE_TYPE:Qe}=P(6041);const Je=P(5205);const Ve=P(79026);const Ke=P(12471);const{makePathsRelative:Ye}=P(46579);const Xe=P(64307);const mergeMaybeArrays=(v,I)=>{const P=new Set;if(Array.isArray(v))for(const I of v)P.add(I);else P.add(v);if(Array.isArray(I))for(const v of I)P.add(v);else P.add(I);return Array.from(P)};const mergeAssetInfo=(v,I)=>{const P={...v,...I};for(const R of Object.keys(v)){if(R in I){if(v[R]===I[R])continue;switch(R){case"fullhash":case"chunkhash":case"modulehash":case"contenthash":P[R]=mergeMaybeArrays(v[R],I[R]);break;case"immutable":case"development":case"hotModuleReplacement":case"javascriptModule":P[R]=v[R]||I[R];break;case"related":P[R]=mergeRelatedInfo(v[R],I[R]);break;default:throw new Error(`Can't handle conflicting asset info for ${R}`)}}}return P};const mergeRelatedInfo=(v,I)=>{const P={...v,...I};for(const R of Object.keys(v)){if(R in I){if(v[R]===I[R])continue;P[R]=mergeMaybeArrays(v[R],I[R])}}return P};const encodeDataUri=(v,I)=>{let P;switch(v){case"base64":{P=I.buffer().toString("base64");break}case false:{const v=I.source();if(typeof v!=="string"){P=v.toString("utf-8")}P=encodeURIComponent(P).replace(/[!'()*]/g,(v=>`%${v.codePointAt(0).toString(16)}`));break}default:throw new Error(`Unsupported encoding '${v}'`)}return P};const decodeDataUriContent=(v,I)=>{const P=v==="base64";if(P){return Buffer.from(I,"base64")}try{return Buffer.from(decodeURIComponent(I),"ascii")}catch(v){return Buffer.from(I,"ascii")}};const Ze="base64";class AssetGenerator extends K{constructor(v,I,P,R,$,L){super();this.dataUrlOptions=I;this.filename=P;this.publicPath=R;this.outputPath=$;this.emit=L;this._moduleGraph=v}getSourceFileName(v,I){return Ye(I.compilation.compiler.context,v.matchResource||v.resource,I.compilation.compiler.root).replace(/^\.\//,"")}getConcatenationBailoutReason(v,I){return undefined}getMimeType(v){if(typeof this.dataUrlOptions==="function"){throw new Error("This method must not be called when dataUrlOptions is a function")}let I=this.dataUrlOptions.mimetype;if(I===undefined){const P=$.extname(v.nameForCondition());if(v.resourceResolveData&&v.resourceResolveData.mimetype!==undefined){I=v.resourceResolveData.mimetype+v.resourceResolveData.parameters}else if(P){I=R.lookup(P);if(typeof I!=="string"){throw new Error("DataUrl can't be generated automatically, "+`because there is no mimetype for "${P}" in mimetype database. `+'Either pass a mimetype via "generator.mimetype" or '+'use type: "asset/resource" to create a resource file instead of a DataUrl')}}}if(typeof I!=="string"){throw new Error("DataUrl can't be generated automatically. "+'Either pass a mimetype via "generator.mimetype" or '+'use type: "asset/resource" to create a resource file instead of a DataUrl')}return I}generateDataUri(v){const I=v.originalSource();let P;if(typeof this.dataUrlOptions==="function"){P=this.dataUrlOptions.call(null,I.source(),{filename:v.matchResource||v.resource,module:v})}else{let R=this.dataUrlOptions.encoding;if(R===undefined&&v.resourceResolveData&&v.resourceResolveData.encoding!==undefined){R=v.resourceResolveData.encoding}if(R===undefined){R=Ze}const $=this.getMimeType(v);let L;if(v.resourceResolveData&&v.resourceResolveData.encoding===R&&decodeDataUriContent(v.resourceResolveData.encoding,v.resourceResolveData.encodedContent).equals(I.buffer())){L=v.resourceResolveData.encodedContent}else{L=encodeDataUri(R,I)}P=`data:${$}${R?`;${R}`:""},${L}`}return P}_getFilenameWithInfo(v,{runtime:I,runtimeTemplate:P,chunkGraph:R},L){const q=this.filename||P.outputOptions.assetModuleFilename;const K=this.getSourceFileName(v,P);let{path:ae,info:ge}=P.compilation.getAssetPathWithInfo(q,{module:v,runtime:I,filename:K,chunkGraph:R,contentHash:L});const be=ae;if(this.outputPath){const{path:q,info:be}=P.compilation.getAssetPathWithInfo(this.outputPath,{module:v,runtime:I,filename:K,chunkGraph:R,contentHash:L});ae=$.posix.join(q,ae);ge=mergeAssetInfo(ge,be)}return{originalFilename:be,filename:ae,assetInfo:ge}}_getAssetPathWithInfo(v,{runtimeTemplate:I,runtime:P,chunkGraph:R,type:$,runtimeRequirements:L},q,K,ae){const ge=this.getSourceFileName(v,I);let be;if(this.publicPath!==undefined&&$==="javascript"){const{path:$,info:L}=I.compilation.getAssetPathWithInfo(this.publicPath,{module:v,runtime:P,filename:ge,chunkGraph:R,contentHash:ae});K=mergeAssetInfo(K,L);be=JSON.stringify($+q)}else if(this.publicPath!==undefined&&$==="css-url"){const{path:$,info:L}=I.compilation.getAssetPathWithInfo(this.publicPath,{module:v,runtime:P,filename:ge,chunkGraph:R,contentHash:ae});K=mergeAssetInfo(K,L);be=$+q}else if($==="javascript"){L.add(Je.publicPath);be=I.concatenation({expr:Je.publicPath},q)}else if($==="css-url"){const v=I.compilation;const P=v.outputOptions.publicPath==="auto"?Ve.PUBLIC_PATH_AUTO:v.getAssetPath(v.outputOptions.publicPath,{hash:v.hash});be=P+q}return{assetPath:be,assetInfo:{sourceFilename:ge,...K}}}generate(v,I){const{type:P,getData:R,runtimeTemplate:$,runtimeRequirements:K,concatenationScope:ae}=I;let ge;const be=P==="javascript"||P==="css-url";const xe=R?R():undefined;if(v.buildInfo.dataUrl&&be){const I=this.generateDataUri(v);ge=P==="javascript"?JSON.stringify(I):I;if(xe){xe.set("url",{[P]:ge,...xe.get("url")})}}else{const R=Ke($.outputOptions.hashFunction);if($.outputOptions.hashSalt){R.update($.outputOptions.hashSalt)}R.update(v.originalSource().buffer());const L=R.digest($.outputOptions.hashDigest);if(xe){xe.set("fullContentHash",L)}v.buildInfo.fullContentHash=L;const q=Xe(L,I.runtimeTemplate.outputOptions.hashDigestLength);if(xe){xe.set("contentHash",q)}const{originalFilename:K,filename:ae,assetInfo:be}=this._getFilenameWithInfo(v,I,q);if(xe){xe.set("filename",ae)}let{assetPath:ve,assetInfo:Ce}=this._getAssetPathWithInfo(v,I,K,be,q);if(xe&&(P==="javascript"||P==="css-url")){xe.set("url",{[P]:ve,...xe.get("url")})}if(xe&&xe.get("assetInfo")){Ce=mergeAssetInfo(xe.get("assetInfo"),Ce)}if(xe){xe.set("assetInfo",Ce)}v.buildInfo.filename=ae;v.buildInfo.assetInfo=Ce;ge=ve}if(P==="javascript"){if(ae){ae.registerNamespaceExport(q.NAMESPACE_OBJECT_EXPORT);return new L(`${$.supportsConst()?"const":"var"} ${q.NAMESPACE_OBJECT_EXPORT} = ${ge};`)}K.add(Je.module);return new L(`${Je.module}.exports = ${ge};`)}else if(P==="css-url"){return null}return v.originalSource()}getTypes(v){const I=new Set;const P=this._moduleGraph.getIncomingConnections(v);for(const v of P){if(!v.originModule){continue}I.add(v.originModule.type.split("/")[0])}if(v.buildInfo&&v.buildInfo.dataUrl||this.emit===false){if(I){if(I.has("javascript")&&I.has("css")){return Ne}else if(I.has("javascript")){return Ce}else if(I.has("css")){return He}}return ae}if(I){if(I.has("javascript")&&I.has("css")){return xe}else if(I.has("javascript")){return be}else if(I.has("css")){return ve}}return ge}getSize(v,I){switch(I){case Qe:{const I=v.originalSource();if(!I){return 0}return I.size()}default:if(v.buildInfo&&v.buildInfo.dataUrl){const I=v.originalSource();if(!I){return 0}return I.size()*1.34+36}return 42}}updateHash(v,I){const{module:P}=I;if(P.buildInfo.dataUrl){v.update("data-url");if(typeof this.dataUrlOptions==="function"){const I=this.dataUrlOptions.ident;if(I)v.update(I)}else{const I=this.dataUrlOptions;if(I.encoding&&I.encoding!==Ze){v.update(I.encoding)}if(I.mimetype)v.update(I.mimetype)}}else{v.update("resource");const{module:P,chunkGraph:R,runtime:$}=I;const L=I.runtimeTemplate;const q={module:P,runtime:$,filename:this.getSourceFileName(P,L),chunkGraph:R,contentHash:L.contentHashReplacement};if(typeof this.publicPath==="function"){v.update("path");const I={};v.update(this.publicPath(q,I));v.update(JSON.stringify(I))}else if(this.publicPath){v.update("path");v.update(this.publicPath)}else{v.update("no-path")}const K=this.filename||L.outputOptions.assetModuleFilename;const{path:ae,info:ge}=L.compilation.getAssetPathWithInfo(K,q);v.update(ae);v.update(JSON.stringify(ge))}}}v.exports=AssetGenerator},44109:function(v,I,P){"use strict";const{ASSET_MODULE_TYPE_RESOURCE:R,ASSET_MODULE_TYPE_INLINE:$,ASSET_MODULE_TYPE:L,ASSET_MODULE_TYPE_SOURCE:q}=P(6041);const{cleverMerge:K}=P(22298);const{compareModulesByIdOrIdentifier:ae}=P(21398);const ge=P(86750);const be=P(13594);const getSchema=v=>{const{definitions:I}=P(59992);return{definitions:I,oneOf:[{$ref:`#/definitions/${v}`}]}};const xe={name:"Asset Modules Plugin",baseDataPath:"generator"};const ve={asset:ge(P(22373),(()=>getSchema("AssetGeneratorOptions")),xe),"asset/resource":ge(P(86754),(()=>getSchema("AssetResourceGeneratorOptions")),xe),"asset/inline":ge(P(4374),(()=>getSchema("AssetInlineGeneratorOptions")),xe)};const Ce=ge(P(65611),(()=>getSchema("AssetParserOptions")),{name:"Asset Modules Plugin",baseDataPath:"parser"});const Ne=be((()=>P(44917)));const He=be((()=>P(61250)));const Qe=be((()=>P(5936)));const Je=be((()=>P(23424)));const Ve=L;const Ke="AssetModulesPlugin";class AssetModulesPlugin{apply(v){v.hooks.compilation.tap(Ke,((I,{normalModuleFactory:P})=>{P.hooks.createParser.for(L).tap(Ke,(I=>{Ce(I);I=K(v.options.module.parser.asset,I);let P=I.dataUrlCondition;if(!P||typeof P==="object"){P={maxSize:8096,...P}}const R=He();return new R(P)}));P.hooks.createParser.for($).tap(Ke,(v=>{const I=He();return new I(true)}));P.hooks.createParser.for(R).tap(Ke,(v=>{const I=He();return new I(false)}));P.hooks.createParser.for(q).tap(Ke,(v=>{const I=Qe();return new I}));for(const v of[L,$,R]){P.hooks.createGenerator.for(v).tap(Ke,(P=>{ve[v](P);let L;if(v!==R){L=P.dataUrl;if(!L||typeof L==="object"){L={encoding:undefined,mimetype:undefined,...L}}}let q;let K;let ae;if(v!==$){q=P.filename;K=P.publicPath;ae=P.outputPath}const ge=Ne();return new ge(I.moduleGraph,L,q,K,ae,P.emit!==false)}))}P.hooks.createGenerator.for(q).tap(Ke,(()=>{const v=Je();return new v(I.moduleGraph)}));I.hooks.renderManifest.tap(Ke,((v,P)=>{const{chunkGraph:R}=I;const{chunk:$,codeGenerationResults:q}=P;const K=R.getOrderedChunkModulesIterableBySourceType($,L,ae(R));if(K){for(const I of K){try{const P=q.get(I,$.runtime);const L=I.buildInfo;const K=P.data;const ae=I.getNumberOfErrors()>0;v.push({render:()=>P.sources.get(Ve),filename:ae?I.nameForCondition():L.filename||K.get("filename"),info:L.assetInfo||K.get("assetInfo"),auxiliary:true,identifier:`assetModule${R.getModuleId(I)}`,hash:ae?R.getModuleHash(I,$.runtime):L.fullContentHash||K.get("fullContentHash")})}catch(v){v.message+=`\nduring rendering of asset ${I.identifier()}`;throw v}}}return v}));I.hooks.prepareModuleExecution.tap("AssetModulesPlugin",((v,I)=>{const{codeGenerationResult:P}=v;const R=P.sources.get(L);if(R===undefined)return;const $=P.data;I.assets.set($.get("filename"),{source:R,info:$.get("assetInfo")})}))}))}}v.exports=AssetModulesPlugin},61250:function(v,I,P){"use strict";const R=P(33157);class AssetParser extends R{constructor(v){super();this.dataUrlCondition=v}parse(v,I){if(typeof v==="object"&&!Buffer.isBuffer(v)){throw new Error("AssetParser doesn't accept preparsed AST")}const P=I.module.buildInfo;P.strict=true;const R=I.module.buildMeta;R.exportsType="default";R.defaultObject=false;if(typeof this.dataUrlCondition==="function"){P.dataUrl=this.dataUrlCondition(v,{filename:I.module.matchResource||I.module.resource,module:I.module})}else if(typeof this.dataUrlCondition==="boolean"){P.dataUrl=this.dataUrlCondition}else if(this.dataUrlCondition&&typeof this.dataUrlCondition==="object"){P.dataUrl=Buffer.byteLength(v)<=this.dataUrlCondition.maxSize}else{throw new Error("Unexpected dataUrlCondition type")}return I}}v.exports=AssetParser},23424:function(v,I,P){"use strict";const{RawSource:R}=P(51255);const $=P(40255);const L=P(52402);const{NO_TYPES:q,CSS_URL_TYPES:K,JS_TYPES:ae,JS_AND_CSS_URL_TYPES:ge}=P(30021);const be=P(5205);class AssetSourceGenerator extends L{constructor(v){super();this._moduleGraph=v}generate(v,{type:I,concatenationScope:P,getData:L,runtimeTemplate:q,runtimeRequirements:K}){const ae=v.originalSource();const ge=L?L():undefined;switch(I){case"javascript":{if(!ae){return new R("")}const v=ae.source();const I=typeof v==="string"?v:v.toString("utf-8");let L;if(P){P.registerNamespaceExport($.NAMESPACE_OBJECT_EXPORT);L=`${q.supportsConst()?"const":"var"} ${$.NAMESPACE_OBJECT_EXPORT} = ${JSON.stringify(I)};`}else{K.add(be.module);L=`${be.module}.exports = ${JSON.stringify(I)};`}return new R(L)}case"css-url":{if(!ae){return null}const v=ae.source();const P=typeof v==="string"?v:v.toString("utf-8");if(ge){ge.set("url",{[I]:P})}return null}default:return null}}getConcatenationBailoutReason(v,I){return undefined}getTypes(v){const I=new Set;const P=this._moduleGraph.getIncomingConnections(v);for(const v of P){if(!v.originModule){continue}I.add(v.originModule.type.split("/")[0])}if(I.has("javascript")&&I.has("css")){return ge}else if(I.has("javascript")){return ae}else if(I.has("css")){return K}return q}getSize(v,I){const P=v.originalSource();if(!P){return 0}return P.size()+12}}v.exports=AssetSourceGenerator},5936:function(v,I,P){"use strict";const R=P(33157);class AssetSourceParser extends R{parse(v,I){if(typeof v==="object"&&!Buffer.isBuffer(v)){throw new Error("AssetSourceParser doesn't accept preparsed AST")}const{module:P}=I;P.buildInfo.strict=true;P.buildMeta.exportsType="default";I.module.buildMeta.defaultObject=false;return I}}v.exports=AssetSourceParser},18966:function(v,I,P){"use strict";const{RawSource:R}=P(51255);const $=P(34803);const{JS_TYPES:L}=P(30021);const{ASSET_MODULE_TYPE_RAW_DATA_URL:q}=P(6041);const K=P(5205);const ae=P(65317);class RawDataUrlModule extends ${constructor(v,I,P){super(q,null);this.url=v;this.urlBuffer=v?Buffer.from(v):undefined;this.identifierStr=I||this.url;this.readableIdentifierStr=P||this.identifierStr}getSourceTypes(){return L}identifier(){return this.identifierStr}size(v){if(this.url===undefined)this.url=this.urlBuffer.toString();return Math.max(1,this.url.length)}readableIdentifier(v){return v.shorten(this.readableIdentifierStr)}needBuild(v,I){return I(null,!this.buildMeta)}build(v,I,P,R,$){this.buildMeta={};this.buildInfo={cacheable:true};$()}codeGeneration(v){if(this.url===undefined)this.url=this.urlBuffer.toString();const I=new Map;I.set("javascript",new R(`module.exports = ${JSON.stringify(this.url)};`));const P=new Map;P.set("url",{javascript:this.url});const $=new Set;$.add(K.module);return{sources:I,runtimeRequirements:$,data:P}}updateHash(v,I){v.update(this.urlBuffer);super.updateHash(v,I)}serialize(v){const{write:I}=v;I(this.urlBuffer);I(this.identifierStr);I(this.readableIdentifierStr);super.serialize(v)}deserialize(v){const{read:I}=v;this.urlBuffer=I();this.identifierStr=I();this.readableIdentifierStr=I();super.deserialize(v)}}ae(RawDataUrlModule,"webpack/lib/asset/RawDataUrlModule");v.exports=RawDataUrlModule},79524:function(v,I,P){"use strict";const R=P(89959);const $=P(5205);const L=P(57227);class AwaitDependenciesInitFragment extends R{constructor(v){super(undefined,R.STAGE_ASYNC_DEPENDENCIES,0,"await-dependencies");this.promises=v}merge(v){const I=new Set(v.promises);for(const v of this.promises){I.add(v)}return new AwaitDependenciesInitFragment(I)}getContent({runtimeRequirements:v}){v.add($.module);const I=this.promises;if(I.size===0){return""}if(I.size===1){const[v]=I;return L.asString([`var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([${v}]);`,`${v} = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];`,""])}const P=Array.from(I).join(", ");return L.asString([`var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([${P}]);`,`([${P}] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);`,""])}}v.exports=AwaitDependenciesInitFragment},79752:function(v,I,P){"use strict";const R=P(33643);class InferAsyncModulesPlugin{apply(v){v.hooks.compilation.tap("InferAsyncModulesPlugin",(v=>{const{moduleGraph:I}=v;v.hooks.finishModules.tap("InferAsyncModulesPlugin",(v=>{const P=new Set;for(const I of v){if(I.buildMeta&&I.buildMeta.async){P.add(I)}}for(const v of P){I.setAsync(v);for(const[$,L]of I.getIncomingConnectionsByOriginModule(v)){if(L.some((v=>v.dependency instanceof R&&v.isTargetActive(undefined)))){P.add($)}}}}))}))}}v.exports=InferAsyncModulesPlugin},44718:function(v,I,P){"use strict";const R=P(61993);const{connectChunkGroupParentAndChild:$}=P(84017);const L=P(73418);const{getEntryRuntime:q,mergeRuntime:K}=P(86620);const ae=BigInt(0);const ge=BigInt(1);const isOrdinalSetInMask=(v,I)=>BigInt.asUintN(1,v>>BigInt(I))!==ae;const getActiveStateOfConnections=(v,I)=>{let P=v[0].getActiveState(I);if(P===true)return true;for(let R=1;R<v.length;R++){const $=v[R];P=L.addConnectionStates(P,$.getActiveState(I));if(P===true)return true}return P};const extractBlockModules=(v,I,P,R)=>{let $;let q;const K=[];const ae=[v];while(ae.length>0){const v=ae.pop();const I=[];K.push(I);R.set(v,I);for(const I of v.blocks){ae.push(I)}}for(const L of I.getOutgoingConnections(v)){const v=L.dependency;if(!v)continue;const K=L.module;if(!K)continue;if(L.weak)continue;const ae=I.getParentBlock(v);let ge=I.getParentBlockIndex(v);if(ge<0){ge=ae.dependencies.indexOf(v)}if($!==ae){q=R.get($=ae)}const be=ge*3;q[be]=K;q[be+1]=L.getActiveState(P);q[be+2]=L}for(const v of K){if(v.length===0)continue;let I;let P=0;e:for(let R=0;R<v.length;R+=3){const $=v[R];if($===undefined)continue;const q=v[R+1];const K=v[R+2];if(I===undefined){let R=0;for(;R<P;R+=3){if(v[R]===$){const I=v[R+1];v[R+2].push(K);if(I===true)continue e;v[R+1]=L.addConnectionStates(I,q);continue e}}v[P]=$;P++;v[P]=q;P++;v[P]=[K];P++;if(P>30){I=new Map;for(let R=0;R<P;R+=3){I.set(v[R],R+1)}}}else{const R=I.get($);if(R!==undefined){const I=v[R];v[R+1].push(K);if(I===true)continue;v[R]=L.addConnectionStates(I,q)}else{v[P]=$;P++;v[P]=q;I.set($,P);P++;v[P]=[K];P++}}}v.length=P}};const visitModules=(v,I,P,$,L,be,xe,ve)=>{const{moduleGraph:Ce,chunkGraph:Ne,moduleMemCaches:He}=I;const Qe=new Map;let Je;const Ve=new Map;const getModuleOrdinal=v=>{let I=Ve.get(v);if(I===undefined){I=Ve.size;Ve.set(v,I)}return I};for(const v of I.chunks){let I=ae;for(const P of Ne.getChunkModulesIterable(v)){I|=ge<<BigInt(getModuleOrdinal(P))}ve.set(v,I)}const getBlockModules=(I,P)=>{Je=Qe.get(P);if(Je===undefined){Je=new Map;Qe.set(P,Je)}let R=Je.get(I);if(R!==undefined)return R;const $=I.getRootBlock();const L=He&&He.get($);if(L!==undefined){const R=L.provide("bundleChunkGraph.blockModules",P,(()=>{v.time("visitModules: prepare");const I=new Map;extractBlockModules($,Ce,P,I);v.timeAggregate("visitModules: prepare");return I}));for(const[v,I]of R)Je.set(v,I);return R.get(I)}v.time("visitModules: prepare");extractBlockModules($,Ce,P,Je);R=Je.get(I);v.timeAggregate("visitModules: prepare");return R};let Ke=0;let Ye=0;let Xe=0;let Ze=0;let et=0;const tt=0;const nt=0;const st=0;const rt=0;const ot=0;const it=0;let at=0;let ct=0;let lt=0;let ut=0;let pt=0;const dt=new Map;const ft=new Map;const ht=new Map;const mt=new Map;const gt=new Set;const yt=0;const bt=1;const xt=2;const kt=3;const vt=4;const wt=5;let Ct=[];const Et=new Map;const At=new Set;for(const[v,R]of P){const P=q(I,v.name,v.options);const L={initialized:false,chunkGroup:v,runtime:P,minAvailableModules:undefined,availableModulesToBeMerged:[],skippedItems:undefined,resultingAvailableModules:undefined,children:undefined,availableSources:undefined,availableChildren:undefined,preOrderIndex:0,postOrderIndex:0,chunkLoading:v.options.chunkLoading!==undefined?v.options.chunkLoading!==false:I.outputOptions.chunkLoading!==false,asyncChunks:v.options.asyncChunks!==undefined?v.options.asyncChunks:I.outputOptions.asyncChunks!==false};v.index=lt++;if(v.getNumberOfParents()>0){const v=new Set(R);L.skippedItems=v;At.add(L)}else{L.minAvailableModules=ae;const I=v.getEntrypointChunk();for(const P of R){Ct.push({action:bt,block:P,module:P,chunk:I,chunkGroup:v,chunkGroupInfo:L})}}$.set(v,L);if(v.name){ht.set(v.name,L)}}for(const v of At){const{chunkGroup:I}=v;v.availableSources=new Set;for(const P of I.parentsIterable){const I=$.get(P);v.availableSources.add(I);if(I.availableChildren===undefined){I.availableChildren=new Set}I.availableChildren.add(v)}}Ct.reverse();const St=new Set;const _t=new Set;let It=[];const Pt=[];const Mt=[];const Ot=[];let Dt;let Rt;let Tt;let $t;let Ft;const iteratorBlock=v=>{let P=dt.get(v);let q;let K;const ge=v.groupOptions&&v.groupOptions.entryOptions;if(P===undefined){const be=v.groupOptions&&v.groupOptions.name||v.chunkName;if(ge){P=mt.get(be);if(!P){K=I.addAsyncEntrypoint(ge,Dt,v.loc,v.request);ve.set(K.chunks[0],ae);K.index=lt++;P={chunkGroup:K,initialized:false,runtime:K.options.runtime||K.name,minAvailableModules:ae,availableModulesToBeMerged:[],skippedItems:undefined,resultingAvailableModules:undefined,children:undefined,availableSources:undefined,availableChildren:undefined,preOrderIndex:0,postOrderIndex:0,chunkLoading:ge.chunkLoading!==undefined?ge.chunkLoading!==false:Ft.chunkLoading,asyncChunks:ge.asyncChunks!==undefined?ge.asyncChunks:Ft.asyncChunks};$.set(K,P);Ne.connectBlockAndChunkGroup(v,K);if(be){mt.set(be,P)}}else{K=P.chunkGroup;K.addOrigin(Dt,v.loc,v.request);Ne.connectBlockAndChunkGroup(v,K)}It.push({action:vt,block:v,module:Dt,chunk:K.chunks[0],chunkGroup:K,chunkGroupInfo:P})}else if(!Ft.asyncChunks||!Ft.chunkLoading){Ct.push({action:kt,block:v,module:Dt,chunk:Rt,chunkGroup:Tt,chunkGroupInfo:Ft})}else{P=be?ht.get(be):undefined;if(!P){q=I.addChunkInGroup(v.groupOptions||v.chunkName,Dt,v.loc,v.request);ve.set(q.chunks[0],ae);q.index=lt++;P={initialized:false,chunkGroup:q,runtime:Ft.runtime,minAvailableModules:undefined,availableModulesToBeMerged:[],skippedItems:undefined,resultingAvailableModules:undefined,children:undefined,availableSources:undefined,availableChildren:undefined,preOrderIndex:0,postOrderIndex:0,chunkLoading:Ft.chunkLoading,asyncChunks:Ft.asyncChunks};xe.add(q);$.set(q,P);if(be){ht.set(be,P)}}else{q=P.chunkGroup;if(q.isInitial()){I.errors.push(new R(be,Dt,v.loc));q=Tt}else{q.addOptions(v.groupOptions)}q.addOrigin(Dt,v.loc,v.request)}L.set(v,[])}dt.set(v,P)}else if(ge){K=P.chunkGroup}else{q=P.chunkGroup}if(q!==undefined){L.get(v).push({originChunkGroupInfo:Ft,chunkGroup:q});let I=Et.get(Ft);if(I===undefined){I=new Set;Et.set(Ft,I)}I.add([P,{action:kt,block:v,module:Dt,chunk:q.chunks[0],chunkGroup:q,chunkGroupInfo:P}])}else if(K!==undefined){Ft.chunkGroup.addAsyncEntrypoint(K)}};const processBlock=v=>{Ye++;const I=getBlockModules(v,Ft.runtime);if(I!==undefined){const v=Ft.minAvailableModules;for(let P=0,R=I.length;P<R;P+=3){const R=I[P];const $=Ne.isModuleInChunk(R,Rt);if($){continue}const L=getModuleOrdinal(R);const q=I[P+1];if(q!==true){const v=I[P+2];Pt.push([R,v]);if(q===false)continue}else if(isOrdinalSetInMask(v,L)){Mt.push(R);continue}Ot.push({action:q===true?bt:kt,block:R,module:R,chunk:Rt,chunkGroup:Tt,chunkGroupInfo:Ft})}if(Pt.length>0){let{skippedModuleConnections:v}=Ft;if(v===undefined){Ft.skippedModuleConnections=v=new Set}for(let I=Pt.length-1;I>=0;I--){v.add(Pt[I])}Pt.length=0}if(Mt.length>0){let{skippedItems:v}=Ft;if(v===undefined){Ft.skippedItems=v=new Set}for(let I=Mt.length-1;I>=0;I--){v.add(Mt[I])}Mt.length=0}if(Ot.length>0){for(let v=Ot.length-1;v>=0;v--){Ct.push(Ot[v])}Ot.length=0}}for(const I of v.blocks){iteratorBlock(I)}if(v.blocks.length>0&&Dt!==v){be.add(v)}};const processEntryBlock=v=>{Ye++;const I=getBlockModules(v,Ft.runtime);if(I!==undefined){for(let v=I.length-3;v>=0;v-=3){const P=I[v];const R=I[v+1];Ct.push({action:R===true?yt:kt,block:P,module:P,chunk:Rt,chunkGroup:Tt,chunkGroupInfo:Ft})}}for(const I of v.blocks){iteratorBlock(I)}if(v.blocks.length>0&&Dt!==v){be.add(v)}};const processQueue=()=>{while(Ct.length){Ke++;const v=Ct.pop();Dt=v.module;$t=v.block;Rt=v.chunk;Tt=v.chunkGroup;Ft=v.chunkGroupInfo;switch(v.action){case yt:Ne.connectChunkAndEntryModule(Rt,Dt,Tt);case bt:{const v=Ne.isModuleInChunk(Dt,Rt);if(v){break}Ne.connectChunkAndModule(Rt,Dt);const I=getModuleOrdinal(Dt);let P=ve.get(Rt);P|=ge<<BigInt(I);ve.set(Rt,P)}case xt:{const I=Tt.getModulePreOrderIndex(Dt);if(I===undefined){Tt.setModulePreOrderIndex(Dt,Ft.preOrderIndex++)}if(Ce.setPreOrderIndexIfUnset(Dt,ut)){ut++}v.action=wt;Ct.push(v)}case kt:{processBlock($t);break}case vt:{processEntryBlock($t);break}case wt:{const v=Tt.getModulePostOrderIndex(Dt);if(v===undefined){Tt.setModulePostOrderIndex(Dt,Ft.postOrderIndex++)}if(Ce.setPostOrderIndexIfUnset(Dt,pt)){pt++}break}}}};const calculateResultingAvailableModules=v=>{if(v.resultingAvailableModules!==undefined)return v.resultingAvailableModules;let I=v.minAvailableModules;for(const P of v.chunkGroup.chunks){const v=ve.get(P);I|=v}return v.resultingAvailableModules=I};const processConnectQueue=()=>{for(const[v,I]of Et){if(v.children===undefined){v.children=new Set}for(const[P]of I){v.children.add(P)}const P=calculateResultingAvailableModules(v);const R=v.runtime;for(const[v,$]of I){v.availableModulesToBeMerged.push(P);_t.add([v,$]);const I=v.runtime;const L=K(I,R);if(I!==L){v.runtime=L;St.add(v)}}Xe+=I.size}Et.clear()};const processChunkGroupsForMerging=()=>{Ze+=_t.size;for(const[v,I]of _t){const P=v.availableModulesToBeMerged;const R=v.minAvailableModules;let $=R;et+=P.length;for(const v of P){if($===undefined){$=v}else{$&=v}}const L=$!==R;P.length=0;if(L){v.minAvailableModules=$;v.resultingAvailableModules=undefined;St.add(v)}if(I){let P=ft.get(v);if(!P){ft.set(v,P=new Set)}let R=!v.initialized||L;if(!P.has(I.block)){R=true;P.add(I.block)}if(R){v.initialized=true;It.push(I)}}}_t.clear()};const processChunkGroupsForCombining=()=>{for(const v of At){for(const I of v.availableSources){if(I.minAvailableModules===undefined){At.delete(v);break}}}for(const v of At){let I=ae;for(const P of v.availableSources){const v=calculateResultingAvailableModules(P);I|=v}v.minAvailableModules=I;v.resultingAvailableModules=undefined;St.add(v)}At.clear()};const processOutdatedChunkGroupInfo=()=>{at+=St.size;for(const v of St){if(v.skippedItems!==undefined){const I=v.minAvailableModules;for(const P of v.skippedItems){const R=getModuleOrdinal(P);if(!isOrdinalSetInMask(I,R)){Ct.push({action:bt,block:P,module:P,chunk:v.chunkGroup.chunks[0],chunkGroup:v.chunkGroup,chunkGroupInfo:v});v.skippedItems.delete(P)}}}if(v.skippedModuleConnections!==undefined){const I=v.minAvailableModules;for(const P of v.skippedModuleConnections){const[R,$]=P;const L=getActiveStateOfConnections($,v.runtime);if(L===false)continue;if(L===true){const $=getModuleOrdinal(R);v.skippedModuleConnections.delete(P);if(isOrdinalSetInMask(I,$)){v.skippedItems.add(R);continue}}Ct.push({action:L===true?bt:kt,block:R,module:R,chunk:v.chunkGroup.chunks[0],chunkGroup:v.chunkGroup,chunkGroupInfo:v})}}if(v.children!==undefined){ct+=v.children.size;for(const I of v.children){let P=Et.get(v);if(P===undefined){P=new Set;Et.set(v,P)}P.add([I,null])}}if(v.availableChildren!==undefined){for(const I of v.availableChildren){At.add(I)}}gt.add(v)}St.clear()};while(Ct.length||Et.size){v.time("visitModules: visiting");processQueue();v.timeAggregateEnd("visitModules: prepare");v.timeEnd("visitModules: visiting");if(At.size>0){v.time("visitModules: combine available modules");processChunkGroupsForCombining();v.timeEnd("visitModules: combine available modules")}if(Et.size>0){v.time("visitModules: calculating available modules");processConnectQueue();v.timeEnd("visitModules: calculating available modules");if(_t.size>0){v.time("visitModules: merging available modules");processChunkGroupsForMerging();v.timeEnd("visitModules: merging available modules")}}if(St.size>0){v.time("visitModules: check modules for revisit");processOutdatedChunkGroupInfo();v.timeEnd("visitModules: check modules for revisit")}if(Ct.length===0){const v=Ct;Ct=It.reverse();It=v}}for(const v of gt){const{chunkGroup:I,runtime:P}=v;const R=ft.get(v);if(!R){continue}for(const v of R){let R=0;let $=0;const process=(v,L)=>{const q=getBlockModules(v,P);for(let v=0,P=q.length;v<P;v+=3){const P=q[v+1];if(P===false){continue}const K=q[v];if(L.has(K)){continue}L.add(K);if(K){I.setModulePreOrderIndex(K,R++);process(K,L);I.setModulePostOrderIndex(K,$++)}}};process(v,new Set)}}gt.clear();Ve.clear();v.log(`${Ke} queue items processed (${Ye} blocks)`);v.log(`${Xe} chunk groups connected`);v.log(`${Ze} chunk groups processed for merging (${et} module sets, ${tt} forked, ${nt} + ${st} modules forked, ${rt} + ${ot} modules merged into fork, ${it} resulting modules)`);v.log(`${at} chunk group info updated (${ct} already connected chunk groups reconnected)`)};const connectChunkGroups=(v,I,P,R)=>{const{chunkGraph:L}=v;const areModulesAvailable=(v,I)=>{for(const P of v.chunks){const v=R.get(P);if((v&I)!==v)return false}return true};for(const[v,R]of P){if(!I.has(v)&&R.every((({chunkGroup:v,originChunkGroupInfo:I})=>areModulesAvailable(v,I.resultingAvailableModules)))){continue}for(let I=0;I<R.length;I++){const{chunkGroup:P,originChunkGroupInfo:q}=R[I];L.connectBlockAndChunkGroup(v,P);$(q.chunkGroup,P)}}};const cleanupUnconnectedGroups=(v,I)=>{const{chunkGraph:P}=v;for(const R of I){if(R.getNumberOfParents()===0){for(const I of R.chunks){v.chunks.delete(I);P.disconnectChunk(I)}P.disconnectChunkGroup(R);R.remove()}}};const buildChunkGraph=(v,I)=>{const P=v.getLogger("webpack.buildChunkGraph");const R=new Map;const $=new Set;const L=new Map;const q=new Set;const ae=new Map;P.time("visitModules");visitModules(P,v,I,L,R,q,$,ae);P.timeEnd("visitModules");P.time("connectChunkGroups");connectChunkGroups(v,q,R,ae);P.timeEnd("connectChunkGroups");for(const[v,I]of L){for(const P of v.chunks)P.runtime=K(P.runtime,I.runtime)}P.time("cleanup");cleanupUnconnectedGroups(v,$);P.timeEnd("cleanup")};v.exports=buildChunkGraph},96356:function(v){"use strict";class AddBuildDependenciesPlugin{constructor(v){this.buildDependencies=new Set(v)}apply(v){v.hooks.compilation.tap("AddBuildDependenciesPlugin",(v=>{v.buildDependencies.addAll(this.buildDependencies)}))}}v.exports=AddBuildDependenciesPlugin},43844:function(v){"use strict";class AddManagedPathsPlugin{constructor(v,I,P){this.managedPaths=new Set(v);this.immutablePaths=new Set(I);this.unmanagedPaths=new Set(P)}apply(v){for(const I of this.managedPaths){v.managedPaths.add(I)}for(const I of this.immutablePaths){v.immutablePaths.add(I)}for(const I of this.unmanagedPaths){v.unmanagedPaths.add(I)}}}v.exports=AddManagedPathsPlugin},75545:function(v,I,P){"use strict";const R=P(37292);const $=P(17531);const L=Symbol("build dependencies key");class IdleFileCachePlugin{constructor(v,I,P,R){this.strategy=v;this.idleTimeout=I;this.idleTimeoutForInitialStore=P;this.idleTimeoutAfterLargeChanges=R}apply(v){const I=this.strategy;const P=this.idleTimeout;const q=Math.min(P,this.idleTimeoutForInitialStore);const K=this.idleTimeoutAfterLargeChanges;const ae=Promise.resolve();let ge=0;let be=0;let xe=0;const ve=new Map;v.cache.hooks.store.tap({name:"IdleFileCachePlugin",stage:R.STAGE_DISK},((v,P,R)=>{ve.set(v,(()=>I.store(v,P,R)))}));v.cache.hooks.get.tapPromise({name:"IdleFileCachePlugin",stage:R.STAGE_DISK},((v,P,R)=>{const restore=()=>I.restore(v,P).then(($=>{if($===undefined){R.push(((R,$)=>{if(R!==undefined){ve.set(v,(()=>I.store(v,P,R)))}$()}))}else{return $}}));const $=ve.get(v);if($!==undefined){ve.delete(v);return $().then(restore)}return restore()}));v.cache.hooks.storeBuildDependencies.tap({name:"IdleFileCachePlugin",stage:R.STAGE_DISK},(v=>{ve.set(L,(()=>Promise.resolve().then((()=>I.storeBuildDependencies(v)))))}));v.cache.hooks.shutdown.tapPromise({name:"IdleFileCachePlugin",stage:R.STAGE_DISK},(()=>{if(Qe){clearTimeout(Qe);Qe=undefined}Ne=false;const P=$.getReporter(v);const R=Array.from(ve.values());if(P)P(0,"process pending cache items");const L=R.map((v=>v()));ve.clear();L.push(Ce);const q=Promise.all(L);Ce=q.then((()=>I.afterAllStored()));if(P){Ce=Ce.then((()=>{P(1,"stored")}))}return Ce.then((()=>{if(I.clear)I.clear()}))}));let Ce=ae;let Ne=false;let He=true;const processIdleTasks=()=>{if(Ne){const P=Date.now();if(ve.size>0){const v=[Ce];const I=P+100;let R=100;for(const[P,$]of ve){ve.delete(P);v.push($());if(R--<=0||Date.now()>I)break}Ce=Promise.all(v);Ce.then((()=>{be+=Date.now()-P;Qe=setTimeout(processIdleTasks,0);Qe.unref()}));return}Ce=Ce.then((async()=>{await I.afterAllStored();be+=Date.now()-P;xe=Math.max(xe,be)*.9+be*.1;be=0;ge=0})).catch((I=>{const P=v.getInfrastructureLogger("IdleFileCachePlugin");P.warn(`Background tasks during idle failed: ${I.message}`);P.debug(I.stack)}));He=false}};let Qe;v.cache.hooks.beginIdle.tap({name:"IdleFileCachePlugin",stage:R.STAGE_DISK},(()=>{const I=ge>xe*2;if(He&&q<P){v.getInfrastructureLogger("IdleFileCachePlugin").log(`Initial cache was generated and cache will be persisted in ${q/1e3}s.`)}else if(I&&K<P){v.getInfrastructureLogger("IdleFileCachePlugin").log(`Spend ${Math.round(ge)/1e3}s in build and ${Math.round(xe)/1e3}s in average in cache store. This is considered as large change and cache will be persisted in ${K/1e3}s.`)}Qe=setTimeout((()=>{Qe=undefined;Ne=true;ae.then(processIdleTasks)}),Math.min(He?q:Infinity,I?K:Infinity,P));Qe.unref()}));v.cache.hooks.endIdle.tap({name:"IdleFileCachePlugin",stage:R.STAGE_DISK},(()=>{if(Qe){clearTimeout(Qe);Qe=undefined}Ne=false}));v.hooks.done.tap("IdleFileCachePlugin",(v=>{ge*=.9;ge+=v.endTime-v.startTime}))}}v.exports=IdleFileCachePlugin},99012:function(v,I,P){"use strict";const R=P(37292);class MemoryCachePlugin{apply(v){const I=new Map;v.cache.hooks.store.tap({name:"MemoryCachePlugin",stage:R.STAGE_MEMORY},((v,P,R)=>{I.set(v,{etag:P,data:R})}));v.cache.hooks.get.tap({name:"MemoryCachePlugin",stage:R.STAGE_MEMORY},((v,P,R)=>{const $=I.get(v);if($===null){return null}else if($!==undefined){return $.etag===P?$.data:null}R.push(((R,$)=>{if(R===undefined){I.set(v,null)}else{I.set(v,{etag:P,data:R})}return $()}))}));v.cache.hooks.shutdown.tap({name:"MemoryCachePlugin",stage:R.STAGE_MEMORY},(()=>{I.clear()}))}}v.exports=MemoryCachePlugin},12504:function(v,I,P){"use strict";const R=P(37292);class MemoryWithGcCachePlugin{constructor({maxGenerations:v}){this._maxGenerations=v}apply(v){const I=this._maxGenerations;const P=new Map;const $=new Map;let L=0;let q=0;const K=v.getInfrastructureLogger("MemoryWithGcCachePlugin");v.hooks.afterDone.tap("MemoryWithGcCachePlugin",(()=>{L++;let v=0;let R;for(const[I,q]of $){if(q.until>L)break;$.delete(I);if(P.get(I)===undefined){P.delete(I);v++;R=I}}if(v>0||$.size>0){K.log(`${P.size-$.size} active entries, ${$.size} recently unused cached entries${v>0?`, ${v} old unused cache entries removed e. g. ${R}`:""}`)}let ae=P.size/I|0;let ge=q>=P.size?0:q;q=ge+ae;for(const[v,R]of P){if(ge!==0){ge--;continue}if(R!==undefined){P.set(v,undefined);$.delete(v);$.set(v,{entry:R,until:L+I});if(ae--===0)break}}}));v.cache.hooks.store.tap({name:"MemoryWithGcCachePlugin",stage:R.STAGE_MEMORY},((v,I,R)=>{P.set(v,{etag:I,data:R})}));v.cache.hooks.get.tap({name:"MemoryWithGcCachePlugin",stage:R.STAGE_MEMORY},((v,I,R)=>{const L=P.get(v);if(L===null){return null}else if(L!==undefined){return L.etag===I?L.data:null}const q=$.get(v);if(q!==undefined){const R=q.entry;if(R===null){$.delete(v);P.set(v,R);return null}if(R.etag!==I)return null;$.delete(v);P.set(v,R);return R.data}R.push(((R,$)=>{if(R===undefined){P.set(v,null)}else{P.set(v,{etag:I,data:R})}return $()}))}));v.cache.hooks.shutdown.tap({name:"MemoryWithGcCachePlugin",stage:R.STAGE_MEMORY},(()=>{P.clear();$.clear()}))}}v.exports=MemoryWithGcCachePlugin},75109:function(v,I,P){"use strict";const R=P(67222);const $=P(17531);const{formatSize:L}=P(58709);const q=P(8313);const K=P(11584);const ae=P(65317);const ge=P(13594);const{createFileSerializer:be,NOT_SERIALIZABLE:xe}=P(32589);class PackContainer{constructor(v,I,P,R,$,L){this.data=v;this.version=I;this.buildSnapshot=P;this.buildDependencies=R;this.resolveResults=$;this.resolveBuildDependenciesSnapshot=L}serialize({write:v,writeLazy:I}){v(this.version);v(this.buildSnapshot);v(this.buildDependencies);v(this.resolveResults);v(this.resolveBuildDependenciesSnapshot);I(this.data)}deserialize({read:v}){this.version=v();this.buildSnapshot=v();this.buildDependencies=v();this.resolveResults=v();this.resolveBuildDependenciesSnapshot=v();this.data=v()}}ae(PackContainer,"webpack/lib/cache/PackFileCacheStrategy","PackContainer");const ve=1024*1024;const Ce=10;const Ne=100;const He=5e4;const Qe=1*60*1e3;class PackItemInfo{constructor(v,I,P){this.identifier=v;this.etag=I;this.location=-1;this.lastAccess=Date.now();this.freshValue=P}}class Pack{constructor(v,I){this.itemInfo=new Map;this.requests=[];this.requestsTimeout=undefined;this.freshContent=new Map;this.content=[];this.invalid=false;this.logger=v;this.maxAge=I}_addRequest(v){this.requests.push(v);if(this.requestsTimeout===undefined){this.requestsTimeout=setTimeout((()=>{this.requests.push(undefined);this.requestsTimeout=undefined}),Qe);if(this.requestsTimeout.unref)this.requestsTimeout.unref()}}stopCapturingRequests(){if(this.requestsTimeout!==undefined){clearTimeout(this.requestsTimeout);this.requestsTimeout=undefined}}get(v,I){const P=this.itemInfo.get(v);this._addRequest(v);if(P===undefined){return}if(P.etag!==I)return null;P.lastAccess=Date.now();const R=P.location;if(R===-1){return P.freshValue}if(!this.content[R]){return}return this.content[R].get(v)}set(v,I,P){if(!this.invalid){this.invalid=true;this.logger.log(`Pack got invalid because of write to: ${v}`)}const R=this.itemInfo.get(v);if(R===undefined){const R=new PackItemInfo(v,I,P);this.itemInfo.set(v,R);this._addRequest(v);this.freshContent.set(v,R)}else{const $=R.location;if($>=0){this._addRequest(v);this.freshContent.set(v,R);const I=this.content[$];I.delete(v);if(I.items.size===0){this.content[$]=undefined;this.logger.debug("Pack %d got empty and is removed",$)}}R.freshValue=P;R.lastAccess=Date.now();R.etag=I;R.location=-1}}getContentStats(){let v=0;let I=0;for(const P of this.content){if(P!==undefined){v++;const R=P.getSize();if(R>0){I+=R}}}return{count:v,size:I}}_findLocation(){let v;for(v=0;v<this.content.length&&this.content[v]!==undefined;v++);return v}_gcAndUpdateLocation(v,I,P){let R=0;let $;const L=Date.now();for(const q of v){const K=this.itemInfo.get(q);if(L-K.lastAccess>this.maxAge){this.itemInfo.delete(q);v.delete(q);I.delete(q);R++;$=q}else{K.location=P}}if(R>0){this.logger.log("Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s",R,P,v.size,$)}}_persistFreshContent(){const v=this.freshContent.size;if(v>0){const I=Math.ceil(v/He);const P=Math.ceil(v/I);const R=[];let $=0;let L=false;const createNextPack=()=>{const v=this._findLocation();this.content[v]=null;const I={items:new Set,map:new Map,loc:v};R.push(I);return I};let q=createNextPack();if(this.requestsTimeout!==undefined)clearTimeout(this.requestsTimeout);for(const v of this.requests){if(v===undefined){if(L){L=false}else if(q.items.size>=Ne){$=0;q=createNextPack()}continue}const I=this.freshContent.get(v);if(I===undefined)continue;q.items.add(v);q.map.set(v,I.freshValue);I.location=q.loc;I.freshValue=undefined;this.freshContent.delete(v);if(++$>P){$=0;q=createNextPack();L=true}}this.requests.length=0;for(const v of R){this.content[v.loc]=new PackContent(v.items,new Set(v.items),new PackContentItems(v.map))}this.logger.log(`${v} fresh items in cache put into pack ${R.length>1?R.map((v=>`${v.loc} (${v.items.size} items)`)).join(", "):R[0].loc}`)}}_optimizeSmallContent(){const v=[];let I=0;const P=[];let R=0;for(let $=0;$<this.content.length;$++){const L=this.content[$];if(L===undefined)continue;if(L.outdated)continue;const q=L.getSize();if(q<0||q>ve)continue;if(L.used.size>0){v.push($);I+=q}else{P.push($);R+=q}}let $;if(v.length>=Ce||I>ve){$=v}else if(P.length>=Ce||R>ve){$=P}else return;const L=[];for(const v of $){L.push(this.content[v]);this.content[v]=undefined}const q=new Set;const K=new Set;const ae=[];for(const v of L){for(const I of v.items){q.add(I)}for(const I of v.used){K.add(I)}ae.push((async I=>{await v.unpack("it should be merged with other small pack contents");for(const[P,R]of v.content){I.set(P,R)}}))}const be=this._findLocation();this._gcAndUpdateLocation(q,K,be);if(q.size>0){this.content[be]=new PackContent(q,K,ge((async()=>{const v=new Map;await Promise.all(ae.map((I=>I(v))));return new PackContentItems(v)})));this.logger.log("Merged %d small files with %d cache items into pack %d",L.length,q.size,be)}}_optimizeUnusedContent(){for(let v=0;v<this.content.length;v++){const I=this.content[v];if(I===undefined)continue;const P=I.getSize();if(P<ve)continue;const R=I.used.size;const $=I.items.size;if(R>0&&R<$){this.content[v]=undefined;const P=new Set(I.used);const R=this._findLocation();this._gcAndUpdateLocation(P,P,R);if(P.size>0){this.content[R]=new PackContent(P,new Set(P),(async()=>{await I.unpack("it should be splitted into used and unused items");const v=new Map;for(const R of P){v.set(R,I.content.get(R))}return new PackContentItems(v)}))}const $=new Set(I.items);const L=new Set;for(const v of P){$.delete(v)}const q=this._findLocation();this._gcAndUpdateLocation($,L,q);if($.size>0){this.content[q]=new PackContent($,L,(async()=>{await I.unpack("it should be splitted into used and unused items");const v=new Map;for(const P of $){v.set(P,I.content.get(P))}return new PackContentItems(v)}))}this.logger.log("Split pack %d into pack %d with %d used items and pack %d with %d unused items",v,R,P.size,q,$.size);return}}}_gcOldestContent(){let v;for(const I of this.itemInfo.values()){if(v===undefined||I.lastAccess<v.lastAccess){v=I}}if(Date.now()-v.lastAccess>this.maxAge){const I=v.location;if(I<0)return;const P=this.content[I];const R=new Set(P.items);const $=new Set(P.used);this._gcAndUpdateLocation(R,$,I);this.content[I]=R.size>0?new PackContent(R,$,(async()=>{await P.unpack("it contains old items that should be garbage collected");const v=new Map;for(const I of R){v.set(I,P.content.get(I))}return new PackContentItems(v)})):undefined}}serialize({write:v,writeSeparate:I}){this._persistFreshContent();this._optimizeSmallContent();this._optimizeUnusedContent();this._gcOldestContent();for(const I of this.itemInfo.keys()){v(I)}v(null);for(const I of this.itemInfo.values()){v(I.etag)}for(const I of this.itemInfo.values()){v(I.lastAccess)}for(let P=0;P<this.content.length;P++){const R=this.content[P];if(R!==undefined){v(R.items);R.writeLazy((v=>I(v,{name:`${P}`})))}else{v(undefined)}}v(null)}deserialize({read:v,logger:I}){this.logger=I;{const I=[];let P=v();while(P!==null){I.push(P);P=v()}this.itemInfo.clear();const R=I.map((v=>{const I=new PackItemInfo(v,undefined,undefined);this.itemInfo.set(v,I);return I}));for(const I of R){I.etag=v()}for(const I of R){I.lastAccess=v()}}this.content.length=0;let P=v();while(P!==null){if(P===undefined){this.content.push(P)}else{const R=this.content.length;const $=v();this.content.push(new PackContent(P,new Set,$,I,`${this.content.length}`));for(const v of P){this.itemInfo.get(v).location=R}}P=v()}}}ae(Pack,"webpack/lib/cache/PackFileCacheStrategy","Pack");class PackContentItems{constructor(v){this.map=v}serialize({write:v,snapshot:I,rollback:P,logger:R,profile:$}){if($){v(false);for(const[$,L]of this.map){const q=I();try{v($);const I=process.hrtime();v(L);const P=process.hrtime(I);const q=P[0]*1e3+P[1]/1e6;if(q>1){if(q>500)R.error(`Serialization of '${$}': ${q} ms`);else if(q>50)R.warn(`Serialization of '${$}': ${q} ms`);else if(q>10)R.info(`Serialization of '${$}': ${q} ms`);else if(q>5)R.log(`Serialization of '${$}': ${q} ms`);else R.debug(`Serialization of '${$}': ${q} ms`)}}catch(v){P(q);if(v===xe)continue;const I="Skipped not serializable cache item";const L=v;if(L.message.includes("ModuleBuildError")){R.log(`${I} (in build error): ${L.message}`);R.debug(`${I} '${$}' (in build error): ${L.stack}`)}else{R.warn(`${I}: ${L.message}`);R.debug(`${I} '${$}': ${L.stack}`)}}}v(null);return}const L=I();try{v(true);v(this.map)}catch($){P(L);v(false);for(const[$,L]of this.map){const q=I();try{v($);v(L)}catch(v){P(q);if(v===xe)continue;const I=v;R.warn(`Skipped not serializable cache item '${$}': ${I.message}`);R.debug(I.stack)}}v(null)}}deserialize({read:v,logger:I,profile:P}){if(v()){this.map=v()}else if(P){const P=new Map;let R=v();while(R!==null){const $=process.hrtime();const L=v();const q=process.hrtime($);const K=q[0]*1e3+q[1]/1e6;if(K>1){if(K>100)I.error(`Deserialization of '${R}': ${K} ms`);else if(K>20)I.warn(`Deserialization of '${R}': ${K} ms`);else if(K>5)I.info(`Deserialization of '${R}': ${K} ms`);else if(K>2)I.log(`Deserialization of '${R}': ${K} ms`);else I.debug(`Deserialization of '${R}': ${K} ms`)}P.set(R,L);R=v()}this.map=P}else{const I=new Map;let P=v();while(P!==null){I.set(P,v());P=v()}this.map=I}}}ae(PackContentItems,"webpack/lib/cache/PackFileCacheStrategy","PackContentItems");class PackContent{constructor(v,I,P,R,$){this.items=v;this.lazy=typeof P==="function"?P:undefined;this.content=typeof P==="function"?undefined:P.map;this.outdated=false;this.used=I;this.logger=R;this.lazyName=$}get(v){this.used.add(v);if(this.content){return this.content.get(v)}const I=this.logger;const{lazyName:P}=this;let R;if(P){this.lazyName=undefined;R=`restore cache content ${P} (${L(this.getSize())})`;I.log(`starting to restore cache content ${P} (${L(this.getSize())}) because of request to: ${v}`);I.time(R)}const $=this.lazy();if("then"in $){return $.then((P=>{const $=P.map;if(R){I.timeEnd(R)}this.content=$;this.lazy=q.unMemoizeLazy(this.lazy);return $.get(v)}))}const K=$.map;if(R){I.timeEnd(R)}this.content=K;this.lazy=q.unMemoizeLazy(this.lazy);return K.get(v)}unpack(v){if(this.content)return;const I=this.logger;if(this.lazy){const{lazyName:P}=this;let R;if(P){this.lazyName=undefined;R=`unpack cache content ${P} (${L(this.getSize())})`;I.log(`starting to unpack cache content ${P} (${L(this.getSize())}) because ${v}`);I.time(R)}const $=this.lazy();if("then"in $){return $.then((v=>{if(R){I.timeEnd(R)}this.content=v.map}))}if(R){I.timeEnd(R)}this.content=$.map}}getSize(){if(!this.lazy)return-1;const v=this.lazy.options;if(!v)return-1;const I=v.size;if(typeof I!=="number")return-1;return I}delete(v){this.items.delete(v);this.used.delete(v);this.outdated=true}writeLazy(v){if(!this.outdated&&this.lazy){v(this.lazy);return}if(!this.outdated&&this.content){const I=new Map(this.content);this.lazy=q.unMemoizeLazy(v((()=>new PackContentItems(I))));return}if(this.content){const I=new Map;for(const v of this.items){I.set(v,this.content.get(v))}this.outdated=false;this.content=I;this.lazy=q.unMemoizeLazy(v((()=>new PackContentItems(I))));return}const I=this.logger;const{lazyName:P}=this;let R;if(P){this.lazyName=undefined;R=`unpack cache content ${P} (${L(this.getSize())})`;I.log(`starting to unpack cache content ${P} (${L(this.getSize())}) because it's outdated and need to be serialized`);I.time(R)}const $=this.lazy();this.outdated=false;if("then"in $){this.lazy=v((()=>$.then((v=>{if(R){I.timeEnd(R)}const P=v.map;const $=new Map;for(const v of this.items){$.set(v,P.get(v))}this.content=$;this.lazy=q.unMemoizeLazy(this.lazy);return new PackContentItems($)}))))}else{if(R){I.timeEnd(R)}const P=$.map;const L=new Map;for(const v of this.items){L.set(v,P.get(v))}this.content=L;this.lazy=v((()=>new PackContentItems(L)))}}}const allowCollectingMemory=v=>{const I=v.buffer.byteLength-v.byteLength;if(I>8192&&(I>1048576||I>v.byteLength)){return Buffer.from(v)}return v};class PackFileCacheStrategy{constructor({compiler:v,fs:I,context:P,cacheLocation:$,version:L,logger:q,snapshot:ae,maxAge:ge,profile:xe,allowCollectingMemory:ve,compression:Ce,readonly:Ne}){this.fileSerializer=be(I,v.options.output.hashFunction);this.fileSystemInfo=new R(I,{managedPaths:ae.managedPaths,immutablePaths:ae.immutablePaths,logger:q.getChildLogger("webpack.FileSystemInfo"),hashFunction:v.options.output.hashFunction});this.compiler=v;this.context=P;this.cacheLocation=$;this.version=L;this.logger=q;this.maxAge=ge;this.profile=xe;this.readonly=Ne;this.allowCollectingMemory=ve;this.compression=Ce;this._extension=Ce==="brotli"?".pack.br":Ce==="gzip"?".pack.gz":".pack";this.snapshot=ae;this.buildDependencies=new Set;this.newBuildDependencies=new K;this.resolveBuildDependenciesSnapshot=undefined;this.resolveResults=undefined;this.buildSnapshot=undefined;this.packPromise=this._openPack();this.storePromise=Promise.resolve()}_getPack(){if(this.packPromise===undefined){this.packPromise=this.storePromise.then((()=>this._openPack()))}return this.packPromise}_openPack(){const{logger:v,profile:I,cacheLocation:P,version:R}=this;let $;let L;let q;let K;let ae;v.time("restore cache container");return this.fileSerializer.deserialize(null,{filename:`${P}/index${this._extension}`,extension:`${this._extension}`,logger:v,profile:I,retainedBuffer:this.allowCollectingMemory?allowCollectingMemory:undefined}).catch((I=>{if(I.code!=="ENOENT"){v.warn(`Restoring pack failed from ${P}${this._extension}: ${I}`);v.debug(I.stack)}else{v.debug(`No pack exists at ${P}${this._extension}: ${I}`)}return undefined})).then((I=>{v.timeEnd("restore cache container");if(!I)return;if(!(I instanceof PackContainer)){v.warn(`Restored pack from ${P}${this._extension}, but contained content is unexpected.`,I);return}if(I.version!==R){v.log(`Restored pack from ${P}${this._extension}, but version doesn't match.`);return}v.time("check build dependencies");return Promise.all([new Promise(((R,L)=>{this.fileSystemInfo.checkSnapshotValid(I.buildSnapshot,((L,q)=>{if(L){v.log(`Restored pack from ${P}${this._extension}, but checking snapshot of build dependencies errored: ${L}.`);v.debug(L.stack);return R(false)}if(!q){v.log(`Restored pack from ${P}${this._extension}, but build dependencies have changed.`);return R(false)}$=I.buildSnapshot;return R(true)}))})),new Promise(((R,$)=>{this.fileSystemInfo.checkSnapshotValid(I.resolveBuildDependenciesSnapshot,(($,ge)=>{if($){v.log(`Restored pack from ${P}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${$}.`);v.debug($.stack);return R(false)}if(ge){K=I.resolveBuildDependenciesSnapshot;L=I.buildDependencies;ae=I.resolveResults;return R(true)}v.log("resolving of build dependencies is invalid, will re-resolve build dependencies");this.fileSystemInfo.checkResolveResultsValid(I.resolveResults,(($,L)=>{if($){v.log(`Restored pack from ${P}${this._extension}, but resolving of build dependencies errored: ${$}.`);v.debug($.stack);return R(false)}if(L){q=I.buildDependencies;ae=I.resolveResults;return R(true)}v.log(`Restored pack from ${P}${this._extension}, but build dependencies resolve to different locations.`);return R(false)}))}))}))]).catch((I=>{v.timeEnd("check build dependencies");throw I})).then((([P,R])=>{v.timeEnd("check build dependencies");if(P&&R){v.time("restore cache content metadata");const P=I.data();v.timeEnd("restore cache content metadata");return P}return undefined}))})).then((I=>{if(I){I.maxAge=this.maxAge;this.buildSnapshot=$;if(L)this.buildDependencies=L;if(q)this.newBuildDependencies.addAll(q);this.resolveResults=ae;this.resolveBuildDependenciesSnapshot=K;return I}return new Pack(v,this.maxAge)})).catch((I=>{this.logger.warn(`Restoring pack from ${P}${this._extension} failed: ${I}`);this.logger.debug(I.stack);return new Pack(v,this.maxAge)}))}store(v,I,P){if(this.readonly)return Promise.resolve();return this._getPack().then((R=>{R.set(v,I===null?null:I.toString(),P)}))}restore(v,I){return this._getPack().then((P=>P.get(v,I===null?null:I.toString()))).catch((I=>{if(I&&I.code!=="ENOENT"){this.logger.warn(`Restoring failed for ${v} from pack: ${I}`);this.logger.debug(I.stack)}}))}storeBuildDependencies(v){if(this.readonly)return;this.newBuildDependencies.addAll(v)}afterAllStored(){const v=this.packPromise;if(v===undefined)return Promise.resolve();const I=$.getReporter(this.compiler);return this.storePromise=v.then((v=>{v.stopCapturingRequests();if(!v.invalid)return;this.packPromise=undefined;this.logger.log("Storing pack...");let P;const R=new Set;for(const v of this.newBuildDependencies){if(!this.buildDependencies.has(v)){R.add(v)}}if(R.size>0||!this.buildSnapshot){if(I)I(.5,"resolve build dependencies");this.logger.debug(`Capturing build dependencies... (${Array.from(R).join(", ")})`);P=new Promise(((v,P)=>{this.logger.time("resolve build dependencies");this.fileSystemInfo.resolveBuildDependencies(this.context,R,((R,$)=>{this.logger.timeEnd("resolve build dependencies");if(R)return P(R);this.logger.time("snapshot build dependencies");const{files:L,directories:q,missing:K,resolveResults:ae,resolveDependencies:ge}=$;if(this.resolveResults){for(const[v,I]of ae){this.resolveResults.set(v,I)}}else{this.resolveResults=ae}if(I){I(.6,"snapshot build dependencies","resolving")}this.fileSystemInfo.createSnapshot(undefined,ge.files,ge.directories,ge.missing,this.snapshot.resolveBuildDependencies,((R,$)=>{if(R){this.logger.timeEnd("snapshot build dependencies");return P(R)}if(!$){this.logger.timeEnd("snapshot build dependencies");return P(new Error("Unable to snapshot resolve dependencies"))}if(this.resolveBuildDependenciesSnapshot){this.resolveBuildDependenciesSnapshot=this.fileSystemInfo.mergeSnapshots(this.resolveBuildDependenciesSnapshot,$)}else{this.resolveBuildDependenciesSnapshot=$}if(I){I(.7,"snapshot build dependencies","modules")}this.fileSystemInfo.createSnapshot(undefined,L,q,K,this.snapshot.buildDependencies,((I,R)=>{this.logger.timeEnd("snapshot build dependencies");if(I)return P(I);if(!R){return P(new Error("Unable to snapshot build dependencies"))}this.logger.debug("Captured build dependencies");if(this.buildSnapshot){this.buildSnapshot=this.fileSystemInfo.mergeSnapshots(this.buildSnapshot,R)}else{this.buildSnapshot=R}v()}))}))}))}))}else{P=Promise.resolve()}return P.then((()=>{if(I)I(.8,"serialize pack");this.logger.time("store pack");const P=new Set(this.buildDependencies);for(const v of R){P.add(v)}const $=new PackContainer(v,this.version,this.buildSnapshot,P,this.resolveResults,this.resolveBuildDependenciesSnapshot);return this.fileSerializer.serialize($,{filename:`${this.cacheLocation}/index${this._extension}`,extension:`${this._extension}`,logger:this.logger,profile:this.profile}).then((()=>{for(const v of R){this.buildDependencies.add(v)}this.newBuildDependencies.clear();this.logger.timeEnd("store pack");const I=v.getContentStats();this.logger.log("Stored pack (%d items, %d files, %d MiB)",v.itemInfo.size,I.count,Math.round(I.size/1024/1024))})).catch((v=>{this.logger.timeEnd("store pack");this.logger.warn(`Caching failed for pack: ${v}`);this.logger.debug(v.stack)}))}))})).catch((v=>{this.logger.warn(`Caching failed for pack: ${v}`);this.logger.debug(v.stack)}))}clear(){this.fileSystemInfo.clear();this.buildDependencies.clear();this.newBuildDependencies.clear();this.resolveBuildDependenciesSnapshot=undefined;this.resolveResults=undefined;this.buildSnapshot=undefined;this.packPromise=undefined}}v.exports=PackFileCacheStrategy},27779:function(v,I,P){"use strict";const R=P(11584);const $=P(65317);class CacheEntry{constructor(v,I){this.result=v;this.snapshot=I}serialize({write:v}){v(this.result);v(this.snapshot)}deserialize({read:v}){this.result=v();this.snapshot=v()}}$(CacheEntry,"webpack/lib/cache/ResolverCachePlugin");const addAllToSet=(v,I)=>{if(v instanceof R){v.addAll(I)}else{for(const P of I){v.add(P)}}};const objectToString=(v,I)=>{let P="";for(const R in v){if(I&&R==="context")continue;const $=v[R];P+=typeof $==="object"&&$!==null?`|${R}=[${objectToString($,false)}|]`:`|${R}=|${$}`}return P};class ResolverCachePlugin{apply(v){const I=v.getCache("ResolverCachePlugin");let P;let $;let L=0;let q=0;let K=0;let ae=0;v.hooks.thisCompilation.tap("ResolverCachePlugin",(v=>{$=v.options.snapshot.resolve;P=v.fileSystemInfo;v.hooks.finishModules.tap("ResolverCachePlugin",(()=>{if(L+q>0){const I=v.getLogger("webpack.ResolverCachePlugin");I.log(`${Math.round(100*L/(L+q))}% really resolved (${L} real resolves with ${K} cached but invalid, ${q} cached valid, ${ae} concurrent)`);L=0;q=0;K=0;ae=0}}))}));const doRealResolve=(v,I,q,K,ae)=>{L++;const ge={_ResolverCachePluginCacheMiss:true,...K};const be={...q,stack:new Set,missingDependencies:new R,fileDependencies:new R,contextDependencies:new R};let xe;let ve=false;if(typeof be.yield==="function"){xe=[];ve=true;be.yield=v=>xe.push(v)}const propagate=v=>{if(q[v]){addAllToSet(q[v],be[v])}};const Ce=Date.now();I.doResolve(I.hooks.resolve,ge,"Cache miss",be,((I,R)=>{propagate("fileDependencies");propagate("contextDependencies");propagate("missingDependencies");if(I)return ae(I);const L=be.fileDependencies;const q=be.contextDependencies;const K=be.missingDependencies;P.createSnapshot(Ce,L,q,K,$,((I,P)=>{if(I)return ae(I);const $=ve?xe:R;if(ve&&R)xe.push(R);if(!P){if($)return ae(null,$);return ae()}v.store(new CacheEntry($,P),(v=>{if(v)return ae(v);if($)return ae(null,$);ae()}))}))}))};v.resolverFactory.hooks.resolver.intercept({factory(v,R){const $=new Map;const L=new Map;R.tap("ResolverCachePlugin",((R,ae,ge)=>{if(ae.cache!==true)return;const be=objectToString(ge,false);const xe=ae.cacheWithContext!==undefined?ae.cacheWithContext:false;R.hooks.resolve.tapAsync({name:"ResolverCachePlugin",stage:-100},((ae,ge,ve)=>{if(ae._ResolverCachePluginCacheMiss||!P){return ve()}const Ce=typeof ge.yield==="function";const Ne=`${v}${Ce?"|yield":"|default"}${be}${objectToString(ae,!xe)}`;if(Ce){const v=L.get(Ne);if(v){v[0].push(ve);v[1].push(ge.yield);return}}else{const v=$.get(Ne);if(v){v.push(ve);return}}const He=I.getItemCache(Ne,null);let Qe;let Je;const Ve=Ce?(v,I)=>{if(Qe===undefined){if(v){ve(v)}else{if(I)for(const v of I){ge.yield(v)}ve(null,null)}Je=undefined;Qe=false}else{const P=Qe;if(v){for(const I of P)I(v)}else{for(let v=0;v<P.length;v++){const R=P[v];const $=Je[v];if(I)for(const v of I)$(v);R(null,null)}}L.delete(Ne);Je=undefined;Qe=false}}:(v,I)=>{if(Qe===undefined){ve(v,I);Qe=false}else{for(const P of Qe){P(v,I)}$.delete(Ne);Qe=false}};const processCacheResult=(v,I)=>{if(v)return Ve(v);if(I){const{snapshot:v,result:$}=I;P.checkSnapshotValid(v,((I,P)=>{if(I||!P){K++;return doRealResolve(He,R,ge,ae,Ve)}q++;if(ge.missingDependencies){addAllToSet(ge.missingDependencies,v.getMissingIterable())}if(ge.fileDependencies){addAllToSet(ge.fileDependencies,v.getFileIterable())}if(ge.contextDependencies){addAllToSet(ge.contextDependencies,v.getContextIterable())}Ve(null,$)}))}else{doRealResolve(He,R,ge,ae,Ve)}};He.get(processCacheResult);if(Ce&&Qe===undefined){Qe=[ve];Je=[ge.yield];L.set(Ne,[Qe,Je])}else if(Qe===undefined){Qe=[ve];$.set(Ne,Qe)}}))}));return R}})}}v.exports=ResolverCachePlugin},95399:function(v,I,P){"use strict";const R=P(12471);class LazyHashedEtag{constructor(v,I="md4"){this._obj=v;this._hash=undefined;this._hashFunction=I}toString(){if(this._hash===undefined){const v=R(this._hashFunction);this._obj.updateHash(v);this._hash=v.digest("base64")}return this._hash}}const $=new Map;const L=new WeakMap;const getter=(v,I="md4")=>{let P;if(typeof I==="string"){P=$.get(I);if(P===undefined){const R=new LazyHashedEtag(v,I);P=new WeakMap;P.set(v,R);$.set(I,P);return R}}else{P=L.get(I);if(P===undefined){const R=new LazyHashedEtag(v,I);P=new WeakMap;P.set(v,R);L.set(I,P);return R}}const R=P.get(v);if(R!==undefined)return R;const q=new LazyHashedEtag(v,I);P.set(v,q);return q};v.exports=getter},67792:function(v){"use strict";class MergedEtag{constructor(v,I){this.a=v;this.b=I}toString(){return`${this.a.toString()}|${this.b.toString()}`}}const I=new WeakMap;const P=new WeakMap;const mergeEtags=(v,R)=>{if(typeof v==="string"){if(typeof R==="string"){return`${v}|${R}`}const I=R;R=v;v=I}else if(typeof R!=="string"){let P=I.get(v);if(P===undefined){I.set(v,P=new WeakMap)}const $=P.get(R);if($===undefined){const I=new MergedEtag(v,R);P.set(R,I);return I}return $}let $=P.get(v);if($===undefined){P.set(v,$=new Map)}const L=$.get(R);if(L===undefined){const I=new MergedEtag(v,R);$.set(R,I);return I}return L};v.exports=mergeEtags},53305:function(v,I,P){"use strict";const R=P(71017);const $=P(59992);const getArguments=(v=$)=>{const I={};const pathToArgumentName=v=>v.replace(/\./g,"-").replace(/\[\]/g,"").replace(/(\p{Uppercase_Letter}+|\p{Lowercase_Letter}|\d)(\p{Uppercase_Letter}+)/gu,"$1-$2").replace(/-?[^\p{Uppercase_Letter}\p{Lowercase_Letter}\d]+/gu,"-").toLowerCase();const getSchemaPart=I=>{const P=I.split("/");let R=v;for(let v=1;v<P.length;v++){const I=R[P[v]];if(!I){break}R=I}return R};const getDescription=v=>{for(const{schema:I}of v){if(I.cli){if(I.cli.helper)continue;if(I.cli.description)return I.cli.description}if(I.description)return I.description}};const getNegatedDescription=v=>{for(const{schema:I}of v){if(I.cli){if(I.cli.helper)continue;if(I.cli.negatedDescription)return I.cli.negatedDescription}}};const getResetDescription=v=>{for(const{schema:I}of v){if(I.cli){if(I.cli.helper)continue;if(I.cli.resetDescription)return I.cli.resetDescription}}};const schemaToArgumentConfig=v=>{if(v.enum){return{type:"enum",values:v.enum}}switch(v.type){case"number":return{type:"number"};case"string":return{type:v.absolutePath?"path":"string"};case"boolean":return{type:"boolean"}}if(v.instanceof==="RegExp"){return{type:"RegExp"}}return undefined};const addResetFlag=v=>{const P=v[0].path;const R=pathToArgumentName(`${P}.reset`);const $=getResetDescription(v)||`Clear all items provided in '${P}' configuration. ${getDescription(v)}`;I[R]={configs:[{type:"reset",multiple:false,description:$,path:P}],description:undefined,simpleType:undefined,multiple:undefined}};const addFlag=(v,P)=>{const R=schemaToArgumentConfig(v[0].schema);if(!R)return 0;const $=getNegatedDescription(v);const L=pathToArgumentName(v[0].path);const q={...R,multiple:P,description:getDescription(v),path:v[0].path};if($){q.negatedDescription=$}if(!I[L]){I[L]={configs:[],description:undefined,simpleType:undefined,multiple:undefined}}if(I[L].configs.some((v=>JSON.stringify(v)===JSON.stringify(q)))){return 0}if(I[L].configs.some((v=>v.type===q.type&&v.multiple!==P))){if(P){throw new Error(`Conflicting schema for ${v[0].path} with ${q.type} type (array type must be before single item type)`)}return 0}I[L].configs.push(q);return 1};const traverse=(v,I="",P=[],R=null)=>{while(v.$ref){v=getSchemaPart(v.$ref)}const $=P.filter((({schema:I})=>I===v));if($.length>=2||$.some((({path:v})=>v===I))){return 0}if(v.cli&&v.cli.exclude)return 0;const L=[{schema:v,path:I},...P];let q=0;q+=addFlag(L,Boolean(R));if(v.type==="object"){if(v.properties){for(const P of Object.keys(v.properties)){q+=traverse(v.properties[P],I?`${I}.${P}`:P,L,R)}}return q}if(v.type==="array"){if(R){return 0}if(Array.isArray(v.items)){const P=0;for(const R of v.items){q+=traverse(R,`${I}.${P}`,L,I)}return q}q+=traverse(v.items,`${I}[]`,L,I);if(q>0){addResetFlag(L);q++}return q}const K=v.oneOf||v.anyOf||v.allOf;if(K){const v=K;for(let P=0;P<v.length;P++){q+=traverse(v[P],I,L,R)}return q}return q};traverse(v);for(const v of Object.keys(I)){const P=I[v];P.description=P.configs.reduce(((v,{description:I})=>{if(!v)return I;if(!I)return v;if(v.includes(I))return v;return`${v} ${I}`}),undefined);P.simpleType=P.configs.reduce(((v,I)=>{let P="string";switch(I.type){case"number":P="number";break;case"reset":case"boolean":P="boolean";break;case"enum":{const v=I.values;if(v.every((v=>typeof v==="boolean")))P="boolean";if(v.every((v=>typeof v==="number")))P="number";break}}if(v===undefined)return P;return v===P?v:"string"}),undefined);P.multiple=P.configs.some((v=>v.multiple))}return I};const L=new WeakMap;const getObjectAndProperty=(v,I,P=0)=>{if(!I)return{value:v};const R=I.split(".");const $=R.pop();let q=v;let K=0;for(const v of R){const I=v.endsWith("[]");const $=I?v.slice(0,-2):v;let ae=q[$];if(I){if(ae===undefined){ae={};q[$]=[...Array.from({length:P}),ae];L.set(q[$],P+1)}else if(!Array.isArray(ae)){return{problem:{type:"unexpected-non-array-in-path",path:R.slice(0,K).join(".")}}}else{let v=L.get(ae)||0;while(v<=P){ae.push(undefined);v++}L.set(ae,v);const I=ae.length-v+P;if(ae[I]===undefined){ae[I]={}}else if(ae[I]===null||typeof ae[I]!=="object"){return{problem:{type:"unexpected-non-object-in-path",path:R.slice(0,K).join(".")}}}ae=ae[I]}}else if(ae===undefined){ae=q[$]={}}else if(ae===null||typeof ae!=="object"){return{problem:{type:"unexpected-non-object-in-path",path:R.slice(0,K).join(".")}}}q=ae;K++}const ae=q[$];if($.endsWith("[]")){const v=$.slice(0,-2);const R=q[v];if(R===undefined){q[v]=[...Array.from({length:P}),undefined];L.set(q[v],P+1);return{object:q[v],property:P,value:undefined}}else if(!Array.isArray(R)){q[v]=[R,...Array.from({length:P}),undefined];L.set(q[v],P+1);return{object:q[v],property:P+1,value:undefined}}let K=L.get(R)||0;while(K<=P){R.push(undefined);K++}L.set(R,K);const ae=R.length-K+P;if(R[ae]===undefined){R[ae]={}}else if(R[ae]===null||typeof R[ae]!=="object"){return{problem:{type:"unexpected-non-object-in-path",path:I}}}return{object:R,property:ae,value:R[ae]}}return{object:q,property:$,value:ae}};const setValue=(v,I,P,R)=>{const{problem:$,object:L,property:q}=getObjectAndProperty(v,I,R);if($)return $;L[q]=P;return null};const processArgumentConfig=(v,I,P,R)=>{if(R!==undefined&&!v.multiple){return{type:"multiple-values-unexpected",path:v.path}}const $=parseValueForArgumentConfig(v,P);if($===undefined){return{type:"invalid-value",path:v.path,expected:getExpectedValue(v)}}const L=setValue(I,v.path,$,R);if(L)return L;return null};const getExpectedValue=v=>{switch(v.type){case"boolean":return"true | false";case"RegExp":return"regular expression (example: /ab?c*/)";case"enum":return v.values.map((v=>`${v}`)).join(" | ");case"reset":return"true (will reset the previous value to an empty array)";default:return v.type}};const parseValueForArgumentConfig=(v,I)=>{switch(v.type){case"string":if(typeof I==="string"){return I}break;case"path":if(typeof I==="string"){return R.resolve(I)}break;case"number":if(typeof I==="number")return I;if(typeof I==="string"&&/^[+-]?\d*(\.\d*)[eE]\d+$/){const v=Number(I);if(!Number.isNaN(v))return v}break;case"boolean":if(typeof I==="boolean")return I;if(I==="true")return true;if(I==="false")return false;break;case"RegExp":if(I instanceof RegExp)return I;if(typeof I==="string"){const v=/^\/(.*)\/([yugi]*)$/.exec(I);if(v&&!/[^\\]\//.test(v[1]))return new RegExp(v[1],v[2])}break;case"enum":{const P=v.values;if(P.includes(I))return I;for(const v of P){if(`${v}`===I)return v}break}case"reset":if(I===true)return[];break}};const processArguments=(v,I,P)=>{const R=[];for(const $ of Object.keys(P)){const L=v[$];if(!L){R.push({type:"unknown-argument",path:"",argument:$});continue}const processValue=(v,P)=>{const q=[];for(const R of L.configs){const L=processArgumentConfig(R,I,v,P);if(!L){return}q.push({...L,argument:$,value:v,index:P})}R.push(...q)};const q=P[$];if(Array.isArray(q)){for(let v=0;v<q.length;v++){processValue(q[v],v)}}else{processValue(q,undefined)}}if(R.length===0)return null;return R};v.exports.getArguments=getArguments;v.exports.processArguments=processArguments},30684:function(v,I,P){"use strict";const R=P(14907);const $=P(71017);const L=/^(?:((?:[A-Z]:)?[/\\].*?))?(?::(.+?))?$/i;const parse=(v,I)=>{if(!v){return{}}if($.isAbsolute(v)){const[,I,P]=L.exec(v)||[];return{configPath:I,env:P}}const P=R.findConfig(I);if(P&&Object.keys(P).includes(v)){return{env:v}}return{query:v}};const load=(v,I)=>{const{configPath:P,env:$,query:L}=parse(v,I);const q=L||(P?R.loadConfig({config:P,env:$}):R.loadConfig({path:I,env:$}));if(!q)return;return R(q)};const resolve=v=>{const rawChecker=I=>v.every((v=>{const[P,R]=v.split(" ");if(!P)return false;const $=I[P];if(!$)return false;const[L,q]=R==="TP"?[Infinity,Infinity]:R.includes("-")?R.split("-")[0].split("."):R.split(".");if(typeof $==="number"){return Number(L)>=$}return $[0]===Number(L)?Number(q)>=$[1]:Number(L)>$[0]}));const I=v.some((v=>v.startsWith("node ")));const P=v.some((v=>/^(?!node)/.test(v)));const R=!P?false:I?null:true;const $=!I?false:P?null:true;const L=rawChecker({chrome:63,and_chr:63,edge:79,firefox:67,and_ff:67,opera:50,op_mob:46,safari:[11,1],ios_saf:[11,3],samsung:[8,2],android:63,and_qq:[10,4],baidu:[13,18],and_uc:[15,5],kaios:[3,0],node:[12,17]});return{const:rawChecker({chrome:49,and_chr:49,edge:12,firefox:36,and_ff:36,opera:36,op_mob:36,safari:[10,0],ios_saf:[10,0],samsung:[5,0],android:37,and_qq:[10,4],baidu:[13,18],and_uc:[12,12],kaios:[2,5],node:[6,0]}),arrowFunction:rawChecker({chrome:45,and_chr:45,edge:12,firefox:39,and_ff:39,opera:32,op_mob:32,safari:10,ios_saf:10,samsung:[5,0],android:45,and_qq:[10,4],baidu:[7,12],and_uc:[12,12],kaios:[2,5],node:[6,0]}),forOf:rawChecker({chrome:38,and_chr:38,edge:12,firefox:51,and_ff:51,opera:25,op_mob:25,safari:7,ios_saf:7,samsung:[3,0],android:38,kaios:[3,0],node:[0,12]}),destructuring:rawChecker({chrome:49,and_chr:49,edge:14,firefox:41,and_ff:41,opera:36,op_mob:36,safari:8,ios_saf:8,samsung:[5,0],android:49,kaios:[2,5],node:[6,0]}),bigIntLiteral:rawChecker({chrome:67,and_chr:67,edge:79,firefox:68,and_ff:68,opera:54,op_mob:48,safari:14,ios_saf:14,samsung:[9,2],android:67,and_qq:[13,1],baidu:[13,18],and_uc:[15,5],kaios:[3,0],node:[10,4]}),module:rawChecker({chrome:61,and_chr:61,edge:16,firefox:60,and_ff:60,opera:48,op_mob:45,safari:[10,1],ios_saf:[10,3],samsung:[8,0],android:61,and_qq:[10,4],baidu:[13,18],and_uc:[15,5],kaios:[3,0],node:[12,17]}),dynamicImport:L,dynamicImportInWorker:L&&!I,globalThis:rawChecker({chrome:71,and_chr:71,edge:79,firefox:65,and_ff:65,opera:58,op_mob:50,safari:[12,1],ios_saf:[12,2],samsung:[10,1],android:71,kaios:[3,0],node:12}),optionalChaining:rawChecker({chrome:80,and_chr:80,edge:80,firefox:74,and_ff:79,opera:67,op_mob:64,safari:[13,1],ios_saf:[13,4],samsung:13,android:80,kaios:[3,0],node:14}),templateLiteral:rawChecker({chrome:41,and_chr:41,edge:13,firefox:34,and_ff:34,opera:29,op_mob:64,safari:[9,1],ios_saf:9,samsung:4,android:41,and_qq:[10,4],baidu:[7,12],and_uc:[12,12],kaios:[2,5],node:4}),asyncFunction:rawChecker({chrome:55,and_chr:55,edge:15,firefox:52,and_ff:52,opera:42,op_mob:42,safari:11,ios_saf:11,samsung:[6,2],android:55,and_qq:[13,1],baidu:[13,18],and_uc:[15,5],kaios:3,node:[7,6]}),browser:R,electron:false,node:$,nwjs:false,web:R,webworker:false,document:R,fetchWasm:R,global:$,importScripts:false,importScriptsInWorker:true,nodeBuiltins:$,nodePrefixForCoreModules:$&&!v.some((v=>v.startsWith("node 15")))&&rawChecker({node:[14,18]}),require:$}};v.exports={resolve:resolve,load:load}},52525:function(v,I,P){"use strict";const R=P(57147);const $=P(71017);const{JAVASCRIPT_MODULE_TYPE_AUTO:L,JAVASCRIPT_MODULE_TYPE_ESM:q,JAVASCRIPT_MODULE_TYPE_DYNAMIC:K,JSON_MODULE_TYPE:ae,WEBASSEMBLY_MODULE_TYPE_ASYNC:ge,WEBASSEMBLY_MODULE_TYPE_SYNC:be,ASSET_MODULE_TYPE:xe,ASSET_MODULE_TYPE_INLINE:ve,ASSET_MODULE_TYPE_RESOURCE:Ce,CSS_MODULE_TYPE_AUTO:Ne,CSS_MODULE_TYPE:He,CSS_MODULE_TYPE_MODULE:Qe,CSS_MODULE_TYPE_GLOBAL:Je}=P(6041);const Ve=P(57227);const{cleverMerge:Ke}=P(22298);const{getTargetsProperties:Ye,getTargetProperties:Xe,getDefaultTarget:Ze}=P(23381);const et=/[\\/]node_modules[\\/]/i;const tt="default";const D=(v,I,P)=>{if(v[I]===undefined){v[I]=P}};const F=(v,I,P)=>{if(v[I]===undefined){v[I]=P()}};const A=(v,I,P)=>{const R=v[I];if(R===undefined){v[I]=P()}else if(Array.isArray(R)){let $;for(let L=0;L<R.length;L++){const q=R[L];if(q==="..."){if($===undefined){$=R.slice(0,L);v[I]=$}const q=P();if(q!==undefined){for(const v of q){$.push(v)}}}else if($!==undefined){$.push(q)}}}};const applyWebpackOptionsBaseDefaults=v=>{F(v,"context",(()=>process.cwd()));applyInfrastructureLoggingDefaults(v.infrastructureLogging)};const applyWebpackOptionsDefaults=(v,I)=>{F(v,"context",(()=>process.cwd()));F(v,"target",(()=>Ze(v.context)));const{mode:R,name:$,target:L}=v;const q=L===false?false:typeof L==="string"?Xe(L,v.context):Ye(L,v.context);const K=R==="development";const ae=R==="production"||!R;if(typeof v.entry!=="function"){for(const I of Object.keys(v.entry)){F(v.entry[I],"import",(()=>["./src"]))}}F(v,"devtool",(()=>K?"eval":false));D(v,"watch",false);D(v,"profile",false);D(v,"parallelism",100);D(v,"recordsInputPath",false);D(v,"recordsOutputPath",false);applyExperimentsDefaults(v.experiments,{production:ae,development:K,targetProperties:q});const ge=v.experiments.futureDefaults;F(v,"cache",(()=>K?{type:"memory"}:false));applyCacheDefaults(v.cache,{name:$||tt,mode:R||"production",development:K,cacheUnaffected:v.experiments.cacheUnaffected,compilerIndex:I});const be=Boolean(v.cache);applySnapshotDefaults(v.snapshot,{production:ae,futureDefaults:ge});applyOutputDefaults(v.output,{context:v.context,targetProperties:q,isAffectedByBrowserslist:L===undefined||typeof L==="string"&&L.startsWith("browserslist")||Array.isArray(L)&&L.some((v=>v.startsWith("browserslist"))),outputModule:v.experiments.outputModule,development:K,entry:v.entry,futureDefaults:ge,asyncWebAssembly:v.experiments.asyncWebAssembly});applyModuleDefaults(v.module,{cache:be,syncWebAssembly:v.experiments.syncWebAssembly,asyncWebAssembly:v.experiments.asyncWebAssembly,css:v.experiments.css,futureDefaults:ge,isNode:q&&q.node===true,uniqueName:v.output.uniqueName,targetProperties:q,mode:v.mode});applyExternalsPresetsDefaults(v.externalsPresets,{targetProperties:q,buildHttp:Boolean(v.experiments.buildHttp)});applyLoaderDefaults(v.loader,{targetProperties:q,environment:v.output.environment});F(v,"externalsType",(()=>{const I=P(59992).definitions.ExternalsType["enum"];return v.output.library&&I.includes(v.output.library.type)?v.output.library.type:v.output.module?"module-import":"var"}));applyNodeDefaults(v.node,{futureDefaults:v.experiments.futureDefaults,outputModule:v.output.module,targetProperties:q});F(v,"performance",(()=>ae&&q&&(q.browser||q.browser===null)?{}:false));applyPerformanceDefaults(v.performance,{production:ae});applyOptimizationDefaults(v.optimization,{development:K,production:ae,css:v.experiments.css,records:Boolean(v.recordsInputPath||v.recordsOutputPath)});v.resolve=Ke(getResolveDefaults({cache:be,context:v.context,targetProperties:q,mode:v.mode,css:v.experiments.css}),v.resolve);v.resolveLoader=Ke(getResolveLoaderDefaults({cache:be}),v.resolveLoader);return{platform:q===false?q:{web:q.web,browser:q.browser,webworker:q.webworker,node:q.node,nwjs:q.nwjs,electron:q.electron}}};const applyExperimentsDefaults=(v,{production:I,development:P,targetProperties:R})=>{D(v,"futureDefaults",false);D(v,"backCompat",!v.futureDefaults);D(v,"syncWebAssembly",false);D(v,"asyncWebAssembly",v.futureDefaults);D(v,"outputModule",false);D(v,"layers",false);D(v,"lazyCompilation",undefined);D(v,"buildHttp",undefined);D(v,"cacheUnaffected",v.futureDefaults);F(v,"css",(()=>v.futureDefaults?true:undefined));let $=true;if(typeof v.topLevelAwait==="boolean"){$=v.topLevelAwait}D(v,"topLevelAwait",$);if(typeof v.buildHttp==="object"){D(v.buildHttp,"frozen",I);D(v.buildHttp,"upgrade",false)}};const applyCacheDefaults=(v,{name:I,mode:P,development:L,cacheUnaffected:q,compilerIndex:K})=>{if(v===false)return;switch(v.type){case"filesystem":F(v,"name",(()=>K!==undefined?`${`${I}-${P}`}__compiler${K+1}__`:`${I}-${P}`));D(v,"version","");F(v,"cacheDirectory",(()=>{const v=process.cwd();let I=v;for(;;){try{if(R.statSync($.join(I,"package.json")).isFile())break}catch(v){}const v=$.dirname(I);if(I===v){I=undefined;break}I=v}if(!I){return $.resolve(v,".cache/webpack")}else if(process.versions.pnp==="1"){return $.resolve(I,".pnp/.cache/webpack")}else if(process.versions.pnp==="3"){return $.resolve(I,".yarn/.cache/webpack")}return $.resolve(I,"node_modules/.cache/webpack")}));F(v,"cacheLocation",(()=>$.resolve(v.cacheDirectory,v.name)));D(v,"hashAlgorithm","md4");D(v,"store","pack");D(v,"compression",false);D(v,"profile",false);D(v,"idleTimeout",6e4);D(v,"idleTimeoutForInitialStore",5e3);D(v,"idleTimeoutAfterLargeChanges",1e3);D(v,"maxMemoryGenerations",L?5:Infinity);D(v,"maxAge",1e3*60*60*24*60);D(v,"allowCollectingMemory",L);D(v,"memoryCacheUnaffected",L&&q);D(v,"readonly",false);D(v.buildDependencies,"defaultWebpack",[$.resolve(__dirname,"..")+$.sep]);break;case"memory":D(v,"maxGenerations",Infinity);D(v,"cacheUnaffected",L&&q);break}};const applySnapshotDefaults=(v,{production:I,futureDefaults:P})=>{if(P){F(v,"managedPaths",(()=>process.versions.pnp==="3"?[/^(.+?(?:[\\/]\.yarn[\\/]unplugged[\\/][^\\/]+)?[\\/]node_modules[\\/])/]:[/^(.+?[\\/]node_modules[\\/])/]));F(v,"immutablePaths",(()=>process.versions.pnp==="3"?[/^(.+?[\\/]cache[\\/][^\\/]+\.zip[\\/]node_modules[\\/])/]:[]))}else{A(v,"managedPaths",(()=>{if(process.versions.pnp==="3"){const v=/^(.+?)[\\/]cache[\\/]watchpack-npm-[^\\/]+\.zip[\\/]node_modules[\\/]/.exec(36871);if(v){return[$.resolve(v[1],"unplugged")]}}else{const v=/^(.+?[\\/]node_modules[\\/])/.exec(36871);if(v){return[v[1]]}}return[]}));A(v,"immutablePaths",(()=>{if(process.versions.pnp==="1"){const v=/^(.+?[\\/]v4)[\\/]npm-watchpack-[^\\/]+-[\da-f]{40}[\\/]node_modules[\\/]/.exec(36871);if(v){return[v[1]]}}else if(process.versions.pnp==="3"){const v=/^(.+?)[\\/]watchpack-npm-[^\\/]+\.zip[\\/]node_modules[\\/]/.exec(36871);if(v){return[v[1]]}}return[]}))}F(v,"unmanagedPaths",(()=>[]));F(v,"resolveBuildDependencies",(()=>({timestamp:true,hash:true})));F(v,"buildDependencies",(()=>({timestamp:true,hash:true})));F(v,"module",(()=>I?{timestamp:true,hash:true}:{timestamp:true}));F(v,"resolve",(()=>I?{timestamp:true,hash:true}:{timestamp:true}))};const applyJavascriptParserOptionsDefaults=(v,{futureDefaults:I,isNode:P})=>{D(v,"unknownContextRequest",".");D(v,"unknownContextRegExp",false);D(v,"unknownContextRecursive",true);D(v,"unknownContextCritical",true);D(v,"exprContextRequest",".");D(v,"exprContextRegExp",false);D(v,"exprContextRecursive",true);D(v,"exprContextCritical",true);D(v,"wrappedContextRegExp",/.*/);D(v,"wrappedContextRecursive",true);D(v,"wrappedContextCritical",false);D(v,"strictThisContextOnImports",false);D(v,"importMeta",true);D(v,"dynamicImportMode","lazy");D(v,"dynamicImportPrefetch",false);D(v,"dynamicImportPreload",false);D(v,"dynamicImportFetchPriority",false);D(v,"createRequire",P);if(I)D(v,"exportsPresence","error")};const applyCssGeneratorOptionsDefaults=(v,{targetProperties:I})=>{D(v,"exportsOnly",!I||I.document===false);D(v,"esModule",true)};const applyModuleDefaults=(v,{cache:I,syncWebAssembly:P,asyncWebAssembly:R,css:$,futureDefaults:Ve,isNode:Ke,uniqueName:Ye,targetProperties:Xe,mode:Ze})=>{if(I){D(v,"unsafeCache",(v=>{const I=v.nameForCondition();return I&&et.test(I)}))}else{D(v,"unsafeCache",false)}F(v.parser,xe,(()=>({})));F(v.parser[xe],"dataUrlCondition",(()=>({})));if(typeof v.parser[xe].dataUrlCondition==="object"){D(v.parser[xe].dataUrlCondition,"maxSize",8096)}F(v.parser,"javascript",(()=>({})));F(v.parser,ae,(()=>({})));D(v.parser[ae],"exportsDepth",Ze==="development"?1:Infinity);applyJavascriptParserOptionsDefaults(v.parser.javascript,{futureDefaults:Ve,isNode:Ke});if($){F(v.parser,He,(()=>({})));D(v.parser[He],"import",true);D(v.parser[He],"url",true);D(v.parser[He],"namedExports",true);F(v.generator,He,(()=>({})));applyCssGeneratorOptionsDefaults(v.generator[He],{targetProperties:Xe});const I=Ye.length>0?"[uniqueName]-[id]-[local]":"[id]-[local]";F(v.generator,Ne,(()=>({})));D(v.generator[Ne],"localIdentName",I);D(v.generator[Ne],"exportsConvention","as-is");F(v.generator,Qe,(()=>({})));D(v.generator[Qe],"localIdentName",I);D(v.generator[Qe],"exportsConvention","as-is");F(v.generator,Je,(()=>({})));D(v.generator[Je],"localIdentName",I);D(v.generator[Je],"exportsConvention","as-is")}A(v,"defaultRules",(()=>{const v={type:q,resolve:{byDependency:{esm:{fullySpecified:true}}}};const I={type:K};const xe=[{mimetype:"application/node",type:L},{test:/\.json$/i,type:ae},{mimetype:"application/json",type:ae},{test:/\.mjs$/i,...v},{test:/\.js$/i,descriptionData:{type:"module"},...v},{test:/\.cjs$/i,...I},{test:/\.js$/i,descriptionData:{type:"commonjs"},...I},{mimetype:{or:["text/javascript","application/javascript"]},...v}];if(R){const v={type:ge,rules:[{descriptionData:{type:"module"},resolve:{fullySpecified:true}}]};xe.push({test:/\.wasm$/i,...v});xe.push({mimetype:"application/wasm",...v})}else if(P){const v={type:be,rules:[{descriptionData:{type:"module"},resolve:{fullySpecified:true}}]};xe.push({test:/\.wasm$/i,...v});xe.push({mimetype:"application/wasm",...v})}if($){const v={fullySpecified:true,preferRelative:true};xe.push({test:/\.css$/i,type:Ne,resolve:v});xe.push({mimetype:"text/css+module",type:Qe,resolve:v});xe.push({mimetype:"text/css",type:He,resolve:v})}xe.push({dependency:"url",oneOf:[{scheme:/^data$/,type:ve},{type:Ce}]},{assert:{type:ae},type:ae},{with:{type:ae},type:ae});return xe}))};const applyOutputDefaults=(v,{context:I,targetProperties:P,isAffectedByBrowserslist:L,outputModule:q,development:K,entry:ae,futureDefaults:ge,asyncWebAssembly:be})=>{const getLibraryName=v=>{const I=typeof v==="object"&&v&&!Array.isArray(v)&&"type"in v?v.name:v;if(Array.isArray(I)){return I.join(".")}else if(typeof I==="object"){return getLibraryName(I.root)}else if(typeof I==="string"){return I}return""};F(v,"uniqueName",(()=>{const P=getLibraryName(v.library).replace(/^\[(\\*[\w:]+\\*)\](\.)|(\.)\[(\\*[\w:]+\\*)\](?=\.|$)|\[(\\*[\w:]+\\*)\]/g,((v,I,P,R,$,L)=>{const q=I||$||L;return q.startsWith("\\")&&q.endsWith("\\")?`${R||""}[${q.slice(1,-1)}]${P||""}`:""}));if(P)return P;const L=$.resolve(I,"package.json");try{const v=JSON.parse(R.readFileSync(L,"utf-8"));return v.name||""}catch(v){if(v.code!=="ENOENT"){v.message+=`\nwhile determining default 'output.uniqueName' from 'name' in ${L}`;throw v}return""}}));F(v,"module",(()=>Boolean(q)));const xe=v.environment;const optimistic=v=>v||v===undefined;const conditionallyOptimistic=(v,I)=>v===undefined&&I||v;F(xe,"globalThis",(()=>P&&P.globalThis));F(xe,"bigIntLiteral",(()=>P&&optimistic(P.bigIntLiteral)));F(xe,"const",(()=>P&&optimistic(P.const)));F(xe,"arrowFunction",(()=>P&&optimistic(P.arrowFunction)));F(xe,"asyncFunction",(()=>P&&optimistic(P.asyncFunction)));F(xe,"forOf",(()=>P&&optimistic(P.forOf)));F(xe,"destructuring",(()=>P&&optimistic(P.destructuring)));F(xe,"optionalChaining",(()=>P&&optimistic(P.optionalChaining)));F(xe,"nodePrefixForCoreModules",(()=>P&&optimistic(P.nodePrefixForCoreModules)));F(xe,"templateLiteral",(()=>P&&optimistic(P.templateLiteral)));F(xe,"dynamicImport",(()=>conditionallyOptimistic(P&&P.dynamicImport,v.module)));F(xe,"dynamicImportInWorker",(()=>conditionallyOptimistic(P&&P.dynamicImportInWorker,v.module)));F(xe,"module",(()=>conditionallyOptimistic(P&&P.module,v.module)));F(xe,"document",(()=>P&&optimistic(P.document)));D(v,"filename",v.module?"[name].mjs":"[name].js");F(v,"iife",(()=>!v.module));D(v,"importFunctionName","import");D(v,"importMetaName","import.meta");F(v,"chunkFilename",(()=>{const I=v.filename;if(typeof I!=="function"){const v=I.includes("[name]");const P=I.includes("[id]");const R=I.includes("[chunkhash]");const $=I.includes("[contenthash]");if(R||$||v||P)return I;return I.replace(/(^|\/)([^/]*(?:\?|$))/,"$1[id].$2")}return v.module?"[id].mjs":"[id].js"}));F(v,"cssFilename",(()=>{const I=v.filename;if(typeof I!=="function"){return I.replace(/\.[mc]?js(\?|$)/,".css$1")}return"[id].css"}));F(v,"cssChunkFilename",(()=>{const I=v.chunkFilename;if(typeof I!=="function"){return I.replace(/\.[mc]?js(\?|$)/,".css$1")}return"[id].css"}));D(v,"assetModuleFilename","[hash][ext][query]");D(v,"webassemblyModuleFilename","[hash].module.wasm");D(v,"compareBeforeEmit",true);D(v,"charset",!ge);const ve=Ve.toIdentifier(v.uniqueName);F(v,"hotUpdateGlobal",(()=>`webpackHotUpdate${ve}`));F(v,"chunkLoadingGlobal",(()=>`webpackChunk${ve}`));F(v,"globalObject",(()=>{if(P){if(P.global)return"global";if(P.globalThis)return"globalThis"}return"self"}));F(v,"chunkFormat",(()=>{if(P){const I=L?"Make sure that your 'browserslist' includes only platforms that support these features or select an appropriate 'target' to allow selecting a chunk format by default. Alternatively specify the 'output.chunkFormat' directly.":"Select an appropriate 'target' to allow selecting one by default, or specify the 'output.chunkFormat' directly.";if(v.module){if(xe.dynamicImport)return"module";if(P.document)return"array-push";throw new Error("For the selected environment is no default ESM chunk format available:\n"+"ESM exports can be chosen when 'import()' is available.\n"+`JSONP Array push can be chosen when 'document' is available.\n${I}`)}else{if(P.document)return"array-push";if(P.require)return"commonjs";if(P.nodeBuiltins)return"commonjs";if(P.importScripts)return"array-push";throw new Error("For the selected environment is no default script chunk format available:\n"+"JSONP Array push can be chosen when 'document' or 'importScripts' is available.\n"+`CommonJs exports can be chosen when 'require' or node builtins are available.\n${I}`)}}throw new Error("Chunk format can't be selected by default when no target is specified")}));D(v,"asyncChunks",true);F(v,"chunkLoading",(()=>{if(P){switch(v.chunkFormat){case"array-push":if(P.document)return"jsonp";if(P.importScripts)return"import-scripts";break;case"commonjs":if(P.require)return"require";if(P.nodeBuiltins)return"async-node";break;case"module":if(xe.dynamicImport)return"import";break}if((P.require===null||P.nodeBuiltins===null||P.document===null||P.importScripts===null)&&v.module&&xe.dynamicImport){return"universal"}}return false}));F(v,"workerChunkLoading",(()=>{if(P){switch(v.chunkFormat){case"array-push":if(P.importScriptsInWorker)return"import-scripts";break;case"commonjs":if(P.require)return"require";if(P.nodeBuiltins)return"async-node";break;case"module":if(xe.dynamicImportInWorker)return"import";break}if((P.require===null||P.nodeBuiltins===null||P.importScriptsInWorker===null)&&v.module&&xe.dynamicImport){return"universal"}}return false}));F(v,"wasmLoading",(()=>{if(P){if(P.fetchWasm)return"fetch";if(P.nodeBuiltins)return"async-node";if((P.nodeBuiltins===null||P.fetchWasm===null)&&be&&v.module&&xe.dynamicImport){return"universal"}}return false}));F(v,"workerWasmLoading",(()=>v.wasmLoading));F(v,"devtoolNamespace",(()=>v.uniqueName));if(v.library){F(v.library,"type",(()=>v.module?"module":"var"))}F(v,"path",(()=>$.join(process.cwd(),"dist")));F(v,"pathinfo",(()=>K));D(v,"sourceMapFilename","[file].map[query]");D(v,"hotUpdateChunkFilename",`[id].[fullhash].hot-update.${v.module?"mjs":"js"}`);D(v,"hotUpdateMainFilename","[runtime].[fullhash].hot-update.json");D(v,"crossOriginLoading",false);F(v,"scriptType",(()=>v.module?"module":false));D(v,"publicPath",P&&(P.document||P.importScripts)||v.scriptType==="module"?"auto":"");D(v,"workerPublicPath","");D(v,"chunkLoadTimeout",12e4);D(v,"hashFunction",ge?"xxhash64":"md4");D(v,"hashDigest","hex");D(v,"hashDigestLength",ge?16:20);D(v,"strictModuleErrorHandling",false);D(v,"strictModuleExceptionHandling",false);const{trustedTypes:Ce}=v;if(Ce){F(Ce,"policyName",(()=>v.uniqueName.replace(/[^a-zA-Z0-9\-#=_/@.%]+/g,"_")||"webpack"));D(Ce,"onPolicyCreationFailure","stop")}const forEachEntry=v=>{for(const I of Object.keys(ae)){v(ae[I])}};A(v,"enabledLibraryTypes",(()=>{const I=[];if(v.library){I.push(v.library.type)}forEachEntry((v=>{if(v.library){I.push(v.library.type)}}));return I}));A(v,"enabledChunkLoadingTypes",(()=>{const I=new Set;if(v.chunkLoading){I.add(v.chunkLoading)}if(v.workerChunkLoading){I.add(v.workerChunkLoading)}forEachEntry((v=>{if(v.chunkLoading){I.add(v.chunkLoading)}}));return Array.from(I)}));A(v,"enabledWasmLoadingTypes",(()=>{const I=new Set;if(v.wasmLoading){I.add(v.wasmLoading)}if(v.workerWasmLoading){I.add(v.workerWasmLoading)}forEachEntry((v=>{if(v.wasmLoading){I.add(v.wasmLoading)}}));return Array.from(I)}))};const applyExternalsPresetsDefaults=(v,{targetProperties:I,buildHttp:P})=>{D(v,"web",!P&&I&&I.web);D(v,"node",I&&I.node);D(v,"nwjs",I&&I.nwjs);D(v,"electron",I&&I.electron);D(v,"electronMain",I&&I.electron&&I.electronMain);D(v,"electronPreload",I&&I.electron&&I.electronPreload);D(v,"electronRenderer",I&&I.electron&&I.electronRenderer)};const applyLoaderDefaults=(v,{targetProperties:I,environment:P})=>{F(v,"target",(()=>{if(I){if(I.electron){if(I.electronMain)return"electron-main";if(I.electronPreload)return"electron-preload";if(I.electronRenderer)return"electron-renderer";return"electron"}if(I.nwjs)return"nwjs";if(I.node)return"node";if(I.web)return"web"}}));D(v,"environment",P)};const applyNodeDefaults=(v,{futureDefaults:I,outputModule:P,targetProperties:R})=>{if(v===false)return;F(v,"global",(()=>{if(R&&R.global)return false;return I?"warn":true}));const handlerForNames=()=>{if(R&&R.node)return P?"node-module":"eval-only";return I?"warn-mock":"mock"};F(v,"__filename",handlerForNames);F(v,"__dirname",handlerForNames)};const applyPerformanceDefaults=(v,{production:I})=>{if(v===false)return;D(v,"maxAssetSize",25e4);D(v,"maxEntrypointSize",25e4);F(v,"hints",(()=>I?"warning":false))};const applyOptimizationDefaults=(v,{production:I,development:R,css:$,records:L})=>{D(v,"removeAvailableModules",false);D(v,"removeEmptyChunks",true);D(v,"mergeDuplicateChunks",true);D(v,"flagIncludedChunks",I);F(v,"moduleIds",(()=>{if(I)return"deterministic";if(R)return"named";return"natural"}));F(v,"chunkIds",(()=>{if(I)return"deterministic";if(R)return"named";return"natural"}));F(v,"sideEffects",(()=>I?true:"flag"));D(v,"providedExports",true);D(v,"usedExports",I);D(v,"innerGraph",I);D(v,"mangleExports",I);D(v,"concatenateModules",I);D(v,"avoidEntryIife",I);D(v,"runtimeChunk",false);D(v,"emitOnErrors",!I);D(v,"checkWasmTypes",I);D(v,"mangleWasmImports",false);D(v,"portableRecords",L);D(v,"realContentHash",I);D(v,"minimize",I);A(v,"minimizer",(()=>[{apply:v=>{const I=P(38107);new I({terserOptions:{compress:{passes:2}}}).apply(v)}}]));F(v,"nodeEnv",(()=>{if(I)return"production";if(R)return"development";return false}));const{splitChunks:q}=v;if(q){A(q,"defaultSizeTypes",(()=>$?["javascript","css","unknown"]:["javascript","unknown"]));D(q,"hidePathInfo",I);D(q,"chunks","async");D(q,"usedExports",v.usedExports===true);D(q,"minChunks",1);F(q,"minSize",(()=>I?2e4:1e4));F(q,"minRemainingSize",(()=>R?0:undefined));F(q,"enforceSizeThreshold",(()=>I?5e4:3e4));F(q,"maxAsyncRequests",(()=>I?30:Infinity));F(q,"maxInitialRequests",(()=>I?30:Infinity));D(q,"automaticNameDelimiter","-");const P=q.cacheGroups;F(P,"default",(()=>({idHint:"",reuseExistingChunk:true,minChunks:2,priority:-20})));F(P,"defaultVendors",(()=>({idHint:"vendors",reuseExistingChunk:true,test:et,priority:-10})))}};const getResolveDefaults=({cache:v,context:I,targetProperties:P,mode:R,css:$})=>{const L=["webpack"];L.push(R==="development"?"development":"production");if(P){if(P.webworker)L.push("worker");if(P.node)L.push("node");if(P.web)L.push("browser");if(P.electron)L.push("electron");if(P.nwjs)L.push("nwjs")}const q=[".js",".json",".wasm"];const K=P;const ae=K&&K.web&&(!K.node||K.electron&&K.electronRenderer);const cjsDeps=()=>({aliasFields:ae?["browser"]:[],mainFields:ae?["browser","module","..."]:["module","..."],conditionNames:["require","module","..."],extensions:[...q]});const esmDeps=()=>({aliasFields:ae?["browser"]:[],mainFields:ae?["browser","module","..."]:["module","..."],conditionNames:["import","module","..."],extensions:[...q]});const ge={cache:v,modules:["node_modules"],conditionNames:L,mainFiles:["index"],extensions:[],aliasFields:[],exportsFields:["exports"],roots:[I],mainFields:["main"],importsFields:["imports"],byDependency:{wasm:esmDeps(),esm:esmDeps(),loaderImport:esmDeps(),url:{preferRelative:true},worker:{...esmDeps(),preferRelative:true},commonjs:cjsDeps(),amd:cjsDeps(),loader:cjsDeps(),unknown:cjsDeps(),undefined:cjsDeps()}};if($){const v=[];v.push("webpack");v.push(R==="development"?"development":"production");v.push("style");ge.byDependency["css-import"]={mainFiles:[],mainFields:["style","..."],conditionNames:v,extensions:[".css"],preferRelative:true}}return ge};const getResolveLoaderDefaults=({cache:v})=>{const I={cache:v,conditionNames:["loader","require","node"],exportsFields:["exports"],mainFields:["loader","main"],extensions:[".js"],mainFiles:["index"]};return I};const applyInfrastructureLoggingDefaults=v=>{F(v,"stream",(()=>process.stderr));const I=v.stream.isTTY&&process.env.TERM!=="dumb";D(v,"level","info");D(v,"debug",false);D(v,"colors",I);D(v,"appendOnly",!I)};v.exports.applyWebpackOptionsBaseDefaults=applyWebpackOptionsBaseDefaults;v.exports.applyWebpackOptionsDefaults=applyWebpackOptionsDefaults},92043:function(v,I,P){"use strict";const R=P(73837);const $=R.deprecate(((v,I)=>{if(I!==undefined&&!v===!I){throw new Error("Conflicting use of 'optimization.noEmitOnErrors' and 'optimization.emitOnErrors'. Remove deprecated 'optimization.noEmitOnErrors' from config.")}return!v}),"optimization.noEmitOnErrors is deprecated in favor of optimization.emitOnErrors","DEP_WEBPACK_CONFIGURATION_OPTIMIZATION_NO_EMIT_ON_ERRORS");const nestedConfig=(v,I)=>v===undefined?I({}):I(v);const cloneObject=v=>({...v});const optionalNestedConfig=(v,I)=>v===undefined?undefined:I(v);const nestedArray=(v,I)=>Array.isArray(v)?I(v):I([]);const optionalNestedArray=(v,I)=>Array.isArray(v)?I(v):undefined;const keyedNestedConfig=(v,I,P)=>{const R=v===undefined?{}:Object.keys(v).reduce(((R,$)=>(R[$]=(P&&$ in P?P[$]:I)(v[$]),R)),{});if(P){for(const v of Object.keys(P)){if(!(v in R)){R[v]=P[v]({})}}}return R};const getNormalizedWebpackOptions=v=>({amd:v.amd,bail:v.bail,cache:optionalNestedConfig(v.cache,(v=>{if(v===false)return false;if(v===true){return{type:"memory",maxGenerations:undefined}}switch(v.type){case"filesystem":return{type:"filesystem",allowCollectingMemory:v.allowCollectingMemory,maxMemoryGenerations:v.maxMemoryGenerations,maxAge:v.maxAge,profile:v.profile,buildDependencies:cloneObject(v.buildDependencies),cacheDirectory:v.cacheDirectory,cacheLocation:v.cacheLocation,hashAlgorithm:v.hashAlgorithm,compression:v.compression,idleTimeout:v.idleTimeout,idleTimeoutForInitialStore:v.idleTimeoutForInitialStore,idleTimeoutAfterLargeChanges:v.idleTimeoutAfterLargeChanges,name:v.name,store:v.store,version:v.version,readonly:v.readonly};case undefined:case"memory":return{type:"memory",maxGenerations:v.maxGenerations};default:throw new Error(`Not implemented cache.type ${v.type}`)}})),context:v.context,dependencies:v.dependencies,devServer:optionalNestedConfig(v.devServer,(v=>{if(v===false)return false;return{...v}})),devtool:v.devtool,entry:v.entry===undefined?{main:{}}:typeof v.entry==="function"?(v=>()=>Promise.resolve().then(v).then(getNormalizedEntryStatic))(v.entry):getNormalizedEntryStatic(v.entry),experiments:nestedConfig(v.experiments,(v=>({...v,buildHttp:optionalNestedConfig(v.buildHttp,(v=>Array.isArray(v)?{allowedUris:v}:v)),lazyCompilation:optionalNestedConfig(v.lazyCompilation,(v=>v===true?{}:v))}))),externals:v.externals,externalsPresets:cloneObject(v.externalsPresets),externalsType:v.externalsType,ignoreWarnings:v.ignoreWarnings?v.ignoreWarnings.map((v=>{if(typeof v==="function")return v;const I=v instanceof RegExp?{message:v}:v;return(v,{requestShortener:P})=>{if(!I.message&&!I.module&&!I.file)return false;if(I.message&&!I.message.test(v.message)){return false}if(I.module&&(!v.module||!I.module.test(v.module.readableIdentifier(P)))){return false}if(I.file&&(!v.file||!I.file.test(v.file))){return false}return true}})):undefined,infrastructureLogging:cloneObject(v.infrastructureLogging),loader:cloneObject(v.loader),mode:v.mode,module:nestedConfig(v.module,(v=>({noParse:v.noParse,unsafeCache:v.unsafeCache,parser:keyedNestedConfig(v.parser,cloneObject,{javascript:I=>({unknownContextRequest:v.unknownContextRequest,unknownContextRegExp:v.unknownContextRegExp,unknownContextRecursive:v.unknownContextRecursive,unknownContextCritical:v.unknownContextCritical,exprContextRequest:v.exprContextRequest,exprContextRegExp:v.exprContextRegExp,exprContextRecursive:v.exprContextRecursive,exprContextCritical:v.exprContextCritical,wrappedContextRegExp:v.wrappedContextRegExp,wrappedContextRecursive:v.wrappedContextRecursive,wrappedContextCritical:v.wrappedContextCritical,strictExportPresence:v.strictExportPresence,strictThisContextOnImports:v.strictThisContextOnImports,...I})}),generator:cloneObject(v.generator),defaultRules:optionalNestedArray(v.defaultRules,(v=>[...v])),rules:nestedArray(v.rules,(v=>[...v]))}))),name:v.name,node:nestedConfig(v.node,(v=>v&&{...v})),optimization:nestedConfig(v.optimization,(v=>({...v,runtimeChunk:getNormalizedOptimizationRuntimeChunk(v.runtimeChunk),splitChunks:nestedConfig(v.splitChunks,(v=>v&&{...v,defaultSizeTypes:v.defaultSizeTypes?[...v.defaultSizeTypes]:["..."],cacheGroups:cloneObject(v.cacheGroups)})),emitOnErrors:v.noEmitOnErrors!==undefined?$(v.noEmitOnErrors,v.emitOnErrors):v.emitOnErrors}))),output:nestedConfig(v.output,(v=>{const{library:I}=v;const P=I;const R=typeof I==="object"&&I&&!Array.isArray(I)&&"type"in I?I:P||v.libraryTarget?{name:P}:undefined;const $={assetModuleFilename:v.assetModuleFilename,asyncChunks:v.asyncChunks,charset:v.charset,chunkFilename:v.chunkFilename,chunkFormat:v.chunkFormat,chunkLoading:v.chunkLoading,chunkLoadingGlobal:v.chunkLoadingGlobal,chunkLoadTimeout:v.chunkLoadTimeout,cssFilename:v.cssFilename,cssChunkFilename:v.cssChunkFilename,clean:v.clean,compareBeforeEmit:v.compareBeforeEmit,crossOriginLoading:v.crossOriginLoading,devtoolFallbackModuleFilenameTemplate:v.devtoolFallbackModuleFilenameTemplate,devtoolModuleFilenameTemplate:v.devtoolModuleFilenameTemplate,devtoolNamespace:v.devtoolNamespace,environment:cloneObject(v.environment),enabledChunkLoadingTypes:v.enabledChunkLoadingTypes?[...v.enabledChunkLoadingTypes]:["..."],enabledLibraryTypes:v.enabledLibraryTypes?[...v.enabledLibraryTypes]:["..."],enabledWasmLoadingTypes:v.enabledWasmLoadingTypes?[...v.enabledWasmLoadingTypes]:["..."],filename:v.filename,globalObject:v.globalObject,hashDigest:v.hashDigest,hashDigestLength:v.hashDigestLength,hashFunction:v.hashFunction,hashSalt:v.hashSalt,hotUpdateChunkFilename:v.hotUpdateChunkFilename,hotUpdateGlobal:v.hotUpdateGlobal,hotUpdateMainFilename:v.hotUpdateMainFilename,ignoreBrowserWarnings:v.ignoreBrowserWarnings,iife:v.iife,importFunctionName:v.importFunctionName,importMetaName:v.importMetaName,scriptType:v.scriptType,library:R&&{type:v.libraryTarget!==undefined?v.libraryTarget:R.type,auxiliaryComment:v.auxiliaryComment!==undefined?v.auxiliaryComment:R.auxiliaryComment,amdContainer:v.amdContainer!==undefined?v.amdContainer:R.amdContainer,export:v.libraryExport!==undefined?v.libraryExport:R.export,name:R.name,umdNamedDefine:v.umdNamedDefine!==undefined?v.umdNamedDefine:R.umdNamedDefine},module:v.module,path:v.path,pathinfo:v.pathinfo,publicPath:v.publicPath,sourceMapFilename:v.sourceMapFilename,sourcePrefix:v.sourcePrefix,strictModuleErrorHandling:v.strictModuleErrorHandling,strictModuleExceptionHandling:v.strictModuleExceptionHandling,trustedTypes:optionalNestedConfig(v.trustedTypes,(v=>{if(v===true)return{};if(typeof v==="string")return{policyName:v};return{...v}})),uniqueName:v.uniqueName,wasmLoading:v.wasmLoading,webassemblyModuleFilename:v.webassemblyModuleFilename,workerPublicPath:v.workerPublicPath,workerChunkLoading:v.workerChunkLoading,workerWasmLoading:v.workerWasmLoading};return $})),parallelism:v.parallelism,performance:optionalNestedConfig(v.performance,(v=>{if(v===false)return false;return{...v}})),plugins:nestedArray(v.plugins,(v=>[...v])),profile:v.profile,recordsInputPath:v.recordsInputPath!==undefined?v.recordsInputPath:v.recordsPath,recordsOutputPath:v.recordsOutputPath!==undefined?v.recordsOutputPath:v.recordsPath,resolve:nestedConfig(v.resolve,(v=>({...v,byDependency:keyedNestedConfig(v.byDependency,cloneObject)}))),resolveLoader:cloneObject(v.resolveLoader),snapshot:nestedConfig(v.snapshot,(v=>({resolveBuildDependencies:optionalNestedConfig(v.resolveBuildDependencies,(v=>({timestamp:v.timestamp,hash:v.hash}))),buildDependencies:optionalNestedConfig(v.buildDependencies,(v=>({timestamp:v.timestamp,hash:v.hash}))),resolve:optionalNestedConfig(v.resolve,(v=>({timestamp:v.timestamp,hash:v.hash}))),module:optionalNestedConfig(v.module,(v=>({timestamp:v.timestamp,hash:v.hash}))),immutablePaths:optionalNestedArray(v.immutablePaths,(v=>[...v])),managedPaths:optionalNestedArray(v.managedPaths,(v=>[...v])),unmanagedPaths:optionalNestedArray(v.unmanagedPaths,(v=>[...v]))}))),stats:nestedConfig(v.stats,(v=>{if(v===false){return{preset:"none"}}if(v===true){return{preset:"normal"}}if(typeof v==="string"){return{preset:v}}return{...v}})),target:v.target,watch:v.watch,watchOptions:cloneObject(v.watchOptions)});const getNormalizedEntryStatic=v=>{if(typeof v==="string"){return{main:{import:[v]}}}if(Array.isArray(v)){return{main:{import:v}}}const I={};for(const P of Object.keys(v)){const R=v[P];if(typeof R==="string"){I[P]={import:[R]}}else if(Array.isArray(R)){I[P]={import:R}}else{I[P]={import:R.import&&(Array.isArray(R.import)?R.import:[R.import]),filename:R.filename,layer:R.layer,runtime:R.runtime,baseUri:R.baseUri,publicPath:R.publicPath,chunkLoading:R.chunkLoading,asyncChunks:R.asyncChunks,wasmLoading:R.wasmLoading,dependOn:R.dependOn&&(Array.isArray(R.dependOn)?R.dependOn:[R.dependOn]),library:R.library}}}return I};const getNormalizedOptimizationRuntimeChunk=v=>{if(v===undefined)return;if(v===false)return false;if(v==="single"){return{name:()=>"runtime"}}if(v===true||v==="multiple"){return{name:v=>`runtime~${v.name}`}}const{name:I}=v;return{name:typeof I==="function"?I:()=>I}};v.exports.getNormalizedWebpackOptions=getNormalizedWebpackOptions},23381:function(v,I,P){"use strict";const R=P(13594);const $=R((()=>P(30684)));const getDefaultTarget=v=>{const I=$().load(null,v);return I?"browserslist":"web"};const versionDependent=(v,I)=>{if(!v){return()=>undefined}const P=Number(v);const R=I?Number(I):0;return(v,I=0)=>P>v||P===v&&R>=I};const L=[["browserslist / browserslist:env / browserslist:query / browserslist:path-to-config / browserslist:path-to-config:env","Resolve features from browserslist. Will resolve browserslist config automatically. Only browser or node queries are supported (electron is not supported). Examples: 'browserslist:modern' to use 'modern' environment from browserslist config",/^browserslist(?::(.+))?$/,(v,I)=>{const P=$();const R=P.load(v?v.trim():null,I);if(!R){throw new Error(`No browserslist config found to handle the 'browserslist' target.\nSee https://github.com/browserslist/browserslist#queries for possible ways to provide a config.\nThe recommended way is to add a 'browserslist' key to your package.json and list supported browsers (resp. node.js versions).\nYou can also more options via the 'target' option: 'browserslist' / 'browserslist:env' / 'browserslist:query' / 'browserslist:path-to-config' / 'browserslist:path-to-config:env'`)}return P.resolve(R)}],["web","Web browser.",/^web$/,()=>({node:false,web:true,webworker:null,browser:true,electron:false,nwjs:false,document:true,importScriptsInWorker:true,fetchWasm:true,nodeBuiltins:false,importScripts:false,require:false,global:false})],["webworker","Web Worker, SharedWorker or Service Worker.",/^webworker$/,()=>({node:false,web:true,webworker:true,browser:true,electron:false,nwjs:false,importScripts:true,importScriptsInWorker:true,fetchWasm:true,nodeBuiltins:false,require:false,document:false,global:false})],["[async-]node[X[.Y]]","Node.js in version X.Y. The 'async-' prefix will load chunks asynchronously via 'fs' and 'vm' instead of 'require()'. Examples: node14.5, async-node10.",/^(async-)?node((\d+)(?:\.(\d+))?)?$/,(v,I,P,R)=>{const $=versionDependent(P,R);return{node:true,web:false,webworker:false,browser:false,electron:false,nwjs:false,require:!v,nodeBuiltins:true,nodePrefixForCoreModules:Number(P)<15?$(14,18):$(16),global:true,document:false,fetchWasm:false,importScripts:false,importScriptsInWorker:false,globalThis:$(12),const:$(6),templateLiteral:$(4),optionalChaining:$(14),arrowFunction:$(6),asyncFunction:$(7,6),forOf:$(5),destructuring:$(6),bigIntLiteral:$(10,4),dynamicImport:$(12,17),dynamicImportInWorker:P?false:undefined,module:$(12,17)}}],["electron[X[.Y]]-main/preload/renderer","Electron in version X.Y. Script is running in main, preload resp. renderer context.",/^electron((\d+)(?:\.(\d+))?)?-(main|preload|renderer)$/,(v,I,P,R)=>{const $=versionDependent(I,P);return{node:true,web:R!=="main",webworker:false,browser:false,electron:true,nwjs:false,electronMain:R==="main",electronPreload:R==="preload",electronRenderer:R==="renderer",global:true,nodeBuiltins:true,nodePrefixForCoreModules:$(15),require:true,document:R==="renderer",fetchWasm:R==="renderer",importScripts:false,importScriptsInWorker:true,globalThis:$(5),const:$(1,1),templateLiteral:$(1,1),optionalChaining:$(8),arrowFunction:$(1,1),asyncFunction:$(1,7),forOf:$(0,36),destructuring:$(1,1),bigIntLiteral:$(4),dynamicImport:$(11),dynamicImportInWorker:I?false:undefined,module:$(11)}}],["nwjs[X[.Y]] / node-webkit[X[.Y]]","NW.js in version X.Y.",/^(?:nwjs|node-webkit)((\d+)(?:\.(\d+))?)?$/,(v,I,P)=>{const R=versionDependent(I,P);return{node:true,web:true,webworker:null,browser:false,electron:false,nwjs:true,global:true,nodeBuiltins:true,document:false,importScriptsInWorker:false,fetchWasm:false,importScripts:false,require:false,globalThis:R(0,43),const:R(0,15),templateLiteral:R(0,13),optionalChaining:R(0,44),arrowFunction:R(0,15),asyncFunction:R(0,21),forOf:R(0,13),destructuring:R(0,15),bigIntLiteral:R(0,32),dynamicImport:R(0,43),dynamicImportInWorker:I?false:undefined,module:R(0,43)}}],["esX","EcmaScript in this version. Examples: es2020, es5.",/^es(\d+)$/,v=>{let I=Number(v);if(I<1e3)I=I+2009;return{const:I>=2015,templateLiteral:I>=2015,optionalChaining:I>=2020,arrowFunction:I>=2015,forOf:I>=2015,destructuring:I>=2015,module:I>=2015,asyncFunction:I>=2017,globalThis:I>=2020,bigIntLiteral:I>=2020,dynamicImport:I>=2020,dynamicImportInWorker:I>=2020}}]];const getTargetProperties=(v,I)=>{for(const[,,P,R]of L){const $=P.exec(v);if($){const[,...v]=$;const P=R(...v,I);if(P)return P}}throw new Error(`Unknown target '${v}'. The following targets are supported:\n${L.map((([v,I])=>`* ${v}: ${I}`)).join("\n")}`)};const mergeTargetProperties=v=>{const I=new Set;for(const P of v){for(const v of Object.keys(P)){I.add(v)}}const P={};for(const R of I){let I=false;let $=false;for(const P of v){const v=P[R];switch(v){case true:I=true;break;case false:$=true;break}}if(I||$)P[R]=$&&I?null:Boolean(I)}return P};const getTargetsProperties=(v,I)=>mergeTargetProperties(v.map((v=>getTargetProperties(v,I))));v.exports.getDefaultTarget=getDefaultTarget;v.exports.getTargetProperties=getTargetProperties;v.exports.getTargetsProperties=getTargetsProperties},30283:function(v,I,P){"use strict";const R=P(49790);const $=P(65317);class ContainerEntryDependency extends R{constructor(v,I,P){super();this.name=v;this.exposes=I;this.shareScope=P}getResourceIdentifier(){return`container-entry-${this.name}`}get type(){return"container entry"}get category(){return"esm"}}$(ContainerEntryDependency,"webpack/lib/container/ContainerEntryDependency");v.exports=ContainerEntryDependency},15633:function(v,I,P){"use strict";const{OriginalSource:R,RawSource:$}=P(51255);const L=P(67927);const q=P(34803);const{JS_TYPES:K}=P(30021);const{JAVASCRIPT_MODULE_TYPE_DYNAMIC:ae}=P(6041);const ge=P(5205);const be=P(57227);const xe=P(92296);const ve=P(65317);const Ce=P(59361);class ContainerEntryModule extends q{constructor(v,I,P){super(ae,null);this._name=v;this._exposes=I;this._shareScope=P}getSourceTypes(){return K}identifier(){return`container entry (${this._shareScope}) ${JSON.stringify(this._exposes)}`}readableIdentifier(v){return"container entry"}libIdent(v){return`${this.layer?`(${this.layer})/`:""}webpack/container/entry/${this._name}`}needBuild(v,I){return I(null,!this.buildMeta)}build(v,I,P,R,$){this.buildMeta={};this.buildInfo={strict:true,topLevelDeclarations:new Set(["moduleMap","get","init"])};this.buildMeta.exportsType="namespace";this.clearDependenciesAndBlocks();for(const[v,I]of this._exposes){const P=new L({name:I.name},{name:v},I.import[I.import.length-1]);let R=0;for(const $ of I.import){const I=new Ce(v,$);I.loc={name:v,index:R++};P.addDependency(I)}this.addBlock(P)}this.addDependency(new xe(["get","init"],false));$()}codeGeneration({moduleGraph:v,chunkGraph:I,runtimeTemplate:P}){const L=new Map;const q=new Set([ge.definePropertyGetters,ge.hasOwnProperty,ge.exports]);const K=[];for(const R of this.blocks){const{dependencies:$}=R;const L=$.map((I=>{const P=I;return{name:P.exposedName,module:v.getModule(P),request:P.userRequest}}));let ae;if(L.some((v=>!v.module))){ae=P.throwMissingModuleErrorBlock({request:L.map((v=>v.request)).join(", ")})}else{ae=`return ${P.blockPromise({block:R,message:"",chunkGraph:I,runtimeRequirements:q})}.then(${P.returningFunction(P.returningFunction(`(${L.map((({module:v,request:R})=>P.moduleRaw({module:v,chunkGraph:I,request:R,weak:false,runtimeRequirements:q}))).join(", ")})`))});`}K.push(`${JSON.stringify(L[0].name)}: ${P.basicFunction("",ae)}`)}const ae=be.asString(["var moduleMap = {",be.indent(K.join(",\n")),"};",`var get = ${P.basicFunction("module, getScope",[`${ge.currentRemoteGetScope} = getScope;`,"getScope = (",be.indent([`${ge.hasOwnProperty}(moduleMap, module)`,be.indent(["? moduleMap[module]()",`: Promise.resolve().then(${P.basicFunction("","throw new Error('Module \"' + module + '\" does not exist in container.');")})`])]),");",`${ge.currentRemoteGetScope} = undefined;`,"return getScope;"])};`,`var init = ${P.basicFunction("shareScope, initScope",[`if (!${ge.shareScopeMap}) return;`,`var name = ${JSON.stringify(this._shareScope)}`,`var oldScope = ${ge.shareScopeMap}[name];`,'if(oldScope && oldScope !== shareScope) throw new Error("Container initialization failed as it has already been initialized with a different share scope");',`${ge.shareScopeMap}[name] = shareScope;`,`return ${ge.initializeSharing}(name, initScope);`])};`,"","// This exports getters to disallow modifications",`${ge.definePropertyGetters}(exports, {`,be.indent([`get: ${P.returningFunction("get")},`,`init: ${P.returningFunction("init")}`]),"});"]);L.set("javascript",this.useSourceMap||this.useSimpleSourceMap?new R(ae,"webpack/container-entry"):new $(ae));return{sources:L,runtimeRequirements:q}}size(v){return 42}serialize(v){const{write:I}=v;I(this._name);I(this._exposes);I(this._shareScope);super.serialize(v)}static deserialize(v){const{read:I}=v;const P=new ContainerEntryModule(I(),I(),I());P.deserialize(v);return P}}ve(ContainerEntryModule,"webpack/lib/container/ContainerEntryModule");v.exports=ContainerEntryModule},12716:function(v,I,P){"use strict";const R=P(8412);const $=P(15633);v.exports=class ContainerEntryModuleFactory extends R{create({dependencies:[v]},I){const P=v;I(null,{module:new $(P.name,P.exposes,P.shareScope)})}}},59361:function(v,I,P){"use strict";const R=P(39460);const $=P(65317);class ContainerExposedDependency extends R{constructor(v,I){super(I);this.exposedName=v}get type(){return"container exposed"}get category(){return"esm"}getResourceIdentifier(){return`exposed dependency ${this.exposedName}=${this.request}`}serialize(v){v.write(this.exposedName);super.serialize(v)}deserialize(v){this.exposedName=v.read();super.deserialize(v)}}$(ContainerExposedDependency,"webpack/lib/container/ContainerExposedDependency");v.exports=ContainerExposedDependency},16258:function(v,I,P){"use strict";const R=P(86750);const $=P(13594);const L=P(30283);const q=P(12716);const K=P(59361);const{parseOptions:ae}=P(96336);const ge=$((()=>P(79533)));const be=R(P(16403),(()=>P(50241)),{name:"Container Plugin",baseDataPath:"options"});const xe="ContainerPlugin";class ContainerPlugin{constructor(v){be(v);this._options={name:v.name,shareScope:v.shareScope||"default",library:v.library||{type:"var",name:v.name},runtime:v.runtime,filename:v.filename||undefined,exposes:ae(v.exposes,(v=>({import:Array.isArray(v)?v:[v],name:undefined})),(v=>({import:Array.isArray(v.import)?v.import:[v.import],name:v.name||undefined})))}}apply(v){const{name:I,exposes:P,shareScope:R,filename:$,library:ae,runtime:be}=this._options;if(!v.options.output.enabledLibraryTypes.includes(ae.type)){v.options.output.enabledLibraryTypes.push(ae.type)}v.hooks.make.tapAsync(xe,((v,q)=>{const K=ge().getCompilationHooks(v);const xe=new L(I,P,R);xe.loc={name:I};v.addEntry(v.options.context,xe,{name:I,filename:$,runtime:be,library:ae},(v=>{if(v)return q(v);K.addContainerEntryDependency.call(xe);q()}))}));v.hooks.thisCompilation.tap(xe,((v,{normalModuleFactory:I})=>{v.dependencyFactories.set(L,new q);v.dependencyFactories.set(K,I)}))}}v.exports=ContainerPlugin},19674:function(v,I,P){"use strict";const R=P(52925);const $=P(5205);const L=P(86750);const q=P(2914);const K=P(2236);const ae=P(44929);const ge=P(14943);const be=P(83440);const xe=P(81105);const{parseOptions:ve}=P(96336);const Ce=L(P(42898),(()=>P(72989)),{name:"Container Reference Plugin",baseDataPath:"options"});const Ne="/".charCodeAt(0);class ContainerReferencePlugin{constructor(v){Ce(v);this._remoteType=v.remoteType;this._remotes=ve(v.remotes,(I=>({external:Array.isArray(I)?I:[I],shareScope:v.shareScope||"default"})),(I=>({external:Array.isArray(I.external)?I.external:[I.external],shareScope:I.shareScope||v.shareScope||"default"})))}apply(v){const{_remotes:I,_remoteType:P}=this;const L={};for(const[v,P]of I){let I=0;for(const R of P.external){if(R.startsWith("internal "))continue;L[`webpack/container/reference/${v}${I?`/fallback-${I}`:""}`]=R;I++}}new R(P,L).apply(v);v.hooks.compilation.tap("ContainerReferencePlugin",((v,{normalModuleFactory:P})=>{v.dependencyFactories.set(xe,P);v.dependencyFactories.set(K,P);v.dependencyFactories.set(q,new ae);P.hooks.factorize.tap("ContainerReferencePlugin",(v=>{if(!v.request.includes("!")){for(const[P,R]of I){if(v.request.startsWith(`${P}`)&&(v.request.length===P.length||v.request.charCodeAt(P.length)===Ne)){return new ge(v.request,R.external.map(((v,I)=>v.startsWith("internal ")?v.slice(9):`webpack/container/reference/${P}${I?`/fallback-${I}`:""}`)),`.${v.request.slice(P.length)}`,R.shareScope)}}}}));v.hooks.runtimeRequirementInTree.for($.ensureChunkHandlers).tap("ContainerReferencePlugin",((I,P)=>{P.add($.module);P.add($.moduleFactoriesAddOnly);P.add($.hasOwnProperty);P.add($.initializeSharing);P.add($.shareScopeMap);v.addRuntimeModule(I,new be)}))}))}}v.exports=ContainerReferencePlugin},2914:function(v,I,P){"use strict";const R=P(49790);const $=P(65317);class FallbackDependency extends R{constructor(v){super();this.requests=v}getResourceIdentifier(){return`fallback ${this.requests.join(" ")}`}get type(){return"fallback"}get category(){return"esm"}serialize(v){const{write:I}=v;I(this.requests);super.serialize(v)}static deserialize(v){const{read:I}=v;const P=new FallbackDependency(I());P.deserialize(v);return P}}$(FallbackDependency,"webpack/lib/container/FallbackDependency");v.exports=FallbackDependency},2236:function(v,I,P){"use strict";const R=P(39460);const $=P(65317);class FallbackItemDependency extends R{constructor(v){super(v)}get type(){return"fallback item"}get category(){return"esm"}}$(FallbackItemDependency,"webpack/lib/container/FallbackItemDependency");v.exports=FallbackItemDependency},18773:function(v,I,P){"use strict";const{RawSource:R}=P(51255);const $=P(34803);const{JS_TYPES:L}=P(30021);const{WEBPACK_MODULE_TYPE_FALLBACK:q}=P(6041);const K=P(5205);const ae=P(57227);const ge=P(65317);const be=P(2236);const xe=new Set([K.module]);class FallbackModule extends ${constructor(v){super(q);this.requests=v;this._identifier=`fallback ${this.requests.join(" ")}`}identifier(){return this._identifier}readableIdentifier(v){return this._identifier}libIdent(v){return`${this.layer?`(${this.layer})/`:""}webpack/container/fallback/${this.requests[0]}/and ${this.requests.length-1} more`}chunkCondition(v,{chunkGraph:I}){return I.getNumberOfEntryModules(v)>0}needBuild(v,I){I(null,!this.buildInfo)}build(v,I,P,R,$){this.buildMeta={};this.buildInfo={strict:true};this.clearDependenciesAndBlocks();for(const v of this.requests)this.addDependency(new be(v));$()}size(v){return this.requests.length*5+42}getSourceTypes(){return L}codeGeneration({runtimeTemplate:v,moduleGraph:I,chunkGraph:P}){const $=this.dependencies.map((v=>P.getModuleId(I.getModule(v))));const L=ae.asString([`var ids = ${JSON.stringify($)};`,"var error, result, i = 0;",`var loop = ${v.basicFunction("next",["while(i < ids.length) {",ae.indent([`try { next = ${K.require}(ids[i++]); } catch(e) { return handleError(e); }`,"if(next) return next.then ? next.then(handleResult, handleError) : handleResult(next);"]),"}","if(error) throw error;"])}`,`var handleResult = ${v.basicFunction("result",["if(result) return result;","return loop();"])};`,`var handleError = ${v.basicFunction("e",["error = e;","return loop();"])};`,"module.exports = loop();"]);const q=new Map;q.set("javascript",new R(L));return{sources:q,runtimeRequirements:xe}}serialize(v){const{write:I}=v;I(this.requests);super.serialize(v)}static deserialize(v){const{read:I}=v;const P=new FallbackModule(I());P.deserialize(v);return P}}ge(FallbackModule,"webpack/lib/container/FallbackModule");v.exports=FallbackModule},44929:function(v,I,P){"use strict";const R=P(8412);const $=P(18773);v.exports=class FallbackModuleFactory extends R{create({dependencies:[v]},I){const P=v;I(null,{module:new $(P.requests)})}}},27093:function(v,I,P){"use strict";const R=P(67927);const $=P(98138);const{STAGE_ADVANCED:L}=P(64152);const q=P(13594);const{forEachRuntime:K}=P(86620);const ae=q((()=>P(79533)));const ge="HoistContainerReferences";class HoistContainerReferences{apply(v){v.hooks.thisCompilation.tap(ge,(v=>{const I=ae().getCompilationHooks(v);const P=new Set;const R=new Set;I.addContainerEntryDependency.tap(ge,(v=>{P.add(v)}));I.addFederationRuntimeDependency.tap(ge,(v=>{P.add(v)}));v.hooks.addEntry.tap(ge,(v=>{if(v.type==="entry"){R.add(v)}}));v.hooks.optimizeChunks.tap({name:ge,stage:L+1},(I=>{this.hoistModulesInChunks(v,P,R)}))}))}hoistModulesInChunks(v,I,P){const{chunkGraph:R,moduleGraph:$}=v;for(const I of P){const P=$.getModule(I);if(!P)continue;const L=getAllReferencedModules(v,P,"external",false);const q=R.getModuleRuntimes(P);const ae=new Set;for(const v of q){K(v,(v=>{if(v){ae.add(v)}}))}for(const I of ae){const P=v.namedChunks.get(I);if(!P)continue;for(const v of L){if(!R.isModuleInChunk(v,P)){R.connectChunkAndModule(P,v)}}}this.cleanUpChunks(v,L)}for(const P of I){const I=$.getModule(P);if(!I)continue;const L=getAllReferencedModules(v,I,"initial",false);const q=getAllReferencedModules(v,I,"external",false);for(const v of q){L.add(v)}const ae=R.getModuleRuntimes(I);const ge=new Set;for(const v of ae){K(v,(v=>{if(v){ge.add(v)}}))}for(const I of ge){const P=v.namedChunks.get(I);if(!P)continue;for(const v of L){if(!R.isModuleInChunk(v,P)){R.connectChunkAndModule(P,v)}}}this.cleanUpChunks(v,L)}}cleanUpChunks(v,I){const{chunkGraph:P}=v;for(const R of I){for(const I of P.getModuleChunks(R)){if(!I.hasRuntime()){P.disconnectChunkAndModule(I,R);if(P.getNumberOfChunkModules(I)===0&&P.getNumberOfEntryModules(I)===0){P.disconnectChunk(I);v.chunks.delete(I);if(I.name){v.namedChunks.delete(I.name)}}}}}I.clear()}}function getAllReferencedModules(v,I,P,L){const q=new Set(L?[I]:[]);const K=new WeakSet([I]);const ae=[I];while(ae.length>0){const I=ae.pop();if(!I)continue;const L=v.moduleGraph.getOutgoingConnections(I);if(L){for(const I of L){const L=I.module;if(!L||K.has(L)){continue}if(P==="initial"){const P=v.moduleGraph.getParentBlock(I.dependency);if(P instanceof R){continue}}if(P==="external"){if(I.module instanceof $){q.add(L)}}else{q.add(L)}K.add(L);ae.push(L)}}}return q}v.exports=HoistContainerReferences},79533:function(v,I,P){"use strict";const{SyncHook:R}=P(84891);const $=P(8581);const L=P(29327);const q=P(15033);const K=P(86750);const ae=P(16258);const ge=P(19674);const be=P(27093);const xe=K(P(67488),(()=>P(82200)),{name:"Module Federation Plugin",baseDataPath:"options"});const ve=new WeakMap;class ModuleFederationPlugin{constructor(v){xe(v);this._options=v}static getCompilationHooks(v){if(!(v instanceof L)){throw new TypeError("The 'compilation' argument must be an instance of Compilation")}let I=ve.get(v);if(!I){I={addContainerEntryDependency:new R(["dependency"]),addFederationRuntimeDependency:new R(["dependency"])};ve.set(v,I)}return I}apply(v){const{_options:I}=this;const P=I.library||{type:"var",name:I.name};const R=I.remoteType||(I.library&&$(I.library.type)?I.library.type:"script");if(P&&!v.options.output.enabledLibraryTypes.includes(P.type)){v.options.output.enabledLibraryTypes.push(P.type)}v.hooks.afterPlugins.tap("ModuleFederationPlugin",(()=>{if(I.exposes&&(Array.isArray(I.exposes)?I.exposes.length>0:Object.keys(I.exposes).length>0)){new ae({name:I.name,library:P,filename:I.filename,runtime:I.runtime,shareScope:I.shareScope,exposes:I.exposes}).apply(v)}if(I.remotes&&(Array.isArray(I.remotes)?I.remotes.length>0:Object.keys(I.remotes).length>0)){new ge({remoteType:R,shareScope:I.shareScope,remotes:I.remotes}).apply(v)}if(I.shared){new q({shared:I.shared,shareScope:I.shareScope}).apply(v)}(new be).apply(v)}))}}v.exports=ModuleFederationPlugin},14943:function(v,I,P){"use strict";const{RawSource:R}=P(51255);const $=P(34803);const{REMOTE_AND_SHARE_INIT_TYPES:L}=P(30021);const{WEBPACK_MODULE_TYPE_REMOTE:q}=P(6041);const K=P(5205);const ae=P(65317);const ge=P(2914);const be=P(81105);const xe=new Set([K.module]);class RemoteModule extends ${constructor(v,I,P,R){super(q);this.request=v;this.externalRequests=I;this.internalRequest=P;this.shareScope=R;this._identifier=`remote (${R}) ${this.externalRequests.join(" ")} ${this.internalRequest}`}identifier(){return this._identifier}readableIdentifier(v){return`remote ${this.request}`}libIdent(v){return`${this.layer?`(${this.layer})/`:""}webpack/container/remote/${this.request}`}needBuild(v,I){I(null,!this.buildInfo)}build(v,I,P,R,$){this.buildMeta={};this.buildInfo={strict:true};this.clearDependenciesAndBlocks();if(this.externalRequests.length===1){this.addDependency(new be(this.externalRequests[0]))}else{this.addDependency(new ge(this.externalRequests))}$()}size(v){return 6}getSourceTypes(){return L}nameForCondition(){return this.request}codeGeneration({runtimeTemplate:v,moduleGraph:I,chunkGraph:P}){const $=I.getModule(this.dependencies[0]);const L=$&&P.getModuleId($);const q=new Map;q.set("remote",new R(""));const K=new Map;K.set("share-init",[{shareScope:this.shareScope,initStage:20,init:L===undefined?"":`initExternal(${JSON.stringify(L)});`}]);return{sources:q,data:K,runtimeRequirements:xe}}serialize(v){const{write:I}=v;I(this.request);I(this.externalRequests);I(this.internalRequest);I(this.shareScope);super.serialize(v)}static deserialize(v){const{read:I}=v;const P=new RemoteModule(I(),I(),I(),I());P.deserialize(v);return P}}ae(RemoteModule,"webpack/lib/container/RemoteModule");v.exports=RemoteModule},83440:function(v,I,P){"use strict";const R=P(5205);const $=P(78994);const L=P(57227);class RemoteRuntimeModule extends ${constructor(){super("remotes loading")}generate(){const v=this.compilation;const I=this.chunkGraph;const{runtimeTemplate:P,moduleGraph:$}=v;const q={};const K={};for(const v of this.chunk.getAllReferencedChunks()){const P=I.getChunkModulesIterableBySourceType(v,"remote");if(!P)continue;const R=q[v.id]=[];for(const v of P){const P=v;const L=P.internalRequest;const q=I.getModuleId(P);const ae=P.shareScope;const ge=P.dependencies[0];const be=$.getModule(ge);const xe=be&&I.getModuleId(be);R.push(q);K[q]=[ae,L,xe]}}return L.asString([`var chunkMapping = ${JSON.stringify(q,null,"\t")};`,`var idToExternalAndNameMapping = ${JSON.stringify(K,null,"\t")};`,`${R.ensureChunkHandlers}.remotes = ${P.basicFunction("chunkId, promises",[`if(${R.hasOwnProperty}(chunkMapping, chunkId)) {`,L.indent([`chunkMapping[chunkId].forEach(${P.basicFunction("id",[`var getScope = ${R.currentRemoteGetScope};`,"if(!getScope) getScope = [];","var data = idToExternalAndNameMapping[id];","if(getScope.indexOf(data) >= 0) return;","getScope.push(data);","if(data.p) return promises.push(data.p);",`var onError = ${P.basicFunction("error",['if(!error) error = new Error("Container missing");','if(typeof error.message === "string")',L.indent("error.message += '\\nwhile loading \"' + data[1] + '\" from ' + data[2];"),`${R.moduleFactories}[id] = ${P.basicFunction("",["throw error;"])}`,"data.p = 0;"])};`,`var handleFunction = ${P.basicFunction("fn, arg1, arg2, d, next, first",["try {",L.indent(["var promise = fn(arg1, arg2);","if(promise && promise.then) {",L.indent([`var p = promise.then(${P.returningFunction("next(result, d)","result")}, onError);`,"if(first) promises.push(data.p = p); else return p;"]),"} else {",L.indent(["return next(promise, d, first);"]),"}"]),"} catch(error) {",L.indent(["onError(error);"]),"}"])}`,`var onExternal = ${P.returningFunction(`external ? handleFunction(${R.initializeSharing}, data[0], 0, external, onInitialized, first) : onError()`,"external, _, first")};`,`var onInitialized = ${P.returningFunction("handleFunction(external.get, data[1], getScope, 0, onFactory, first)","_, external, first")};`,`var onFactory = ${P.basicFunction("factory",["data.p = 1;",`${R.moduleFactories}[id] = ${P.basicFunction("module",["module.exports = factory();"])}`])};`,`handleFunction(${R.require}, data[2], 0, 0, onExternal, 1);`])});`]),"}"])}`])}}v.exports=RemoteRuntimeModule},81105:function(v,I,P){"use strict";const R=P(39460);const $=P(65317);class RemoteToExternalDependency extends R{constructor(v){super(v)}get type(){return"remote to external"}get category(){return"esm"}}$(RemoteToExternalDependency,"webpack/lib/container/RemoteToExternalDependency");v.exports=RemoteToExternalDependency},96336:function(v){"use strict";const process=(v,I,P,R)=>{const array=v=>{for(const P of v){if(typeof P==="string"){R(P,I(P,P))}else if(P&&typeof P==="object"){object(P)}else{throw new Error("Unexpected options format")}}};const object=v=>{for(const[$,L]of Object.entries(v)){if(typeof L==="string"||Array.isArray(L)){R($,I(L,$))}else{R($,P(L,$))}}};if(!v){}else if(Array.isArray(v)){array(v)}else if(typeof v==="object"){object(v)}else{throw new Error("Unexpected options format")}};const parseOptions=(v,I,P)=>{const R=[];process(v,I,P,((v,I)=>{R.push([v,I])}));return R};const scope=(v,I)=>{const P={};process(I,(v=>v),(v=>v),((I,R)=>{P[I.startsWith("./")?`${v}${I.slice(1)}`:`${v}/${I}`]=R}));return P};v.exports.parseOptions=parseOptions;v.exports.scope=scope},67103:function(v,I,P){"use strict";const{ReplaceSource:R,RawSource:$,ConcatSource:L}=P(51255);const{UsageState:q}=P(21311);const K=P(52402);const ae=P(89959);const{JS_AND_CSS_EXPORT_TYPES:ge,JS_AND_CSS_TYPES:be}=P(30021);const xe=P(5205);const ve=P(57227);class CssGenerator extends K{constructor(v){super();this.convention=v.exportsConvention;this.localIdentName=v.localIdentName;this.exportsOnly=v.exportsOnly;this.esModule=v.esModule}getConcatenationBailoutReason(v,I){if(!this.esModule){return"Module is not an ECMAScript module"}return undefined}generate(v,I){const K=I.type==="javascript"?new R(new $("")):new R(v.originalSource());const ge=[];const be={esModule:this.esModule,exports:new Map};let Ce;const Ne={runtimeTemplate:I.runtimeTemplate,dependencyTemplates:I.dependencyTemplates,moduleGraph:I.moduleGraph,chunkGraph:I.chunkGraph,module:v,runtime:I.runtime,runtimeRequirements:I.runtimeRequirements,concatenationScope:I.concatenationScope,codeGenerationResults:I.codeGenerationResults,initFragments:ge,cssData:be,get chunkInitFragments(){if(!Ce){const v=I.getData();Ce=v.get("chunkInitFragments");if(!Ce){Ce=[];v.set("chunkInitFragments",Ce)}}return Ce}};const handleDependency=v=>{const P=v.constructor;const R=I.dependencyTemplates.get(P);if(!R){throw new Error(`No template for dependency: ${v.constructor.name}`)}R.apply(v,K,Ne)};for(const I of v.dependencies){handleDependency(I)}switch(I.type){case"javascript":{v.buildInfo.cssData=be;I.runtimeRequirements.add(xe.module);if(I.concatenationScope){const R=new L;const $=new Set;for(const[L,q]of be.exports){const K=I.moduleGraph.getExportInfo(v,L).getUsedName(L,I.runtime);if(!K){continue}let ae=ve.toIdentifier(K);const{RESERVED_IDENTIFIER:ge}=P(16081);if(ge.has(ae)){ae=`_${ae}`}const be=0;while($.has(ae)){ae=ve.toIdentifier(L+be)}$.add(ae);I.concatenationScope.registerExport(L,ae);R.add(`${I.runtimeTemplate.supportsConst()?"const":"var"} ${ae} = ${JSON.stringify(q)};\n`)}return R}const R=this.esModule&&I.moduleGraph.getExportsInfo(v).otherExportsInfo.getUsed(I.runtime)!==q.Unused;if(R){I.runtimeRequirements.add(xe.makeNamespaceObject)}const K=[];for(const[v,I]of be.exports){K.push(`\t${JSON.stringify(v)}: ${JSON.stringify(I)}`)}return new $(`${R?`${xe.makeNamespaceObject}(`:""}${v.moduleArgument}.exports = {\n${K.join(",\n")}\n}${R?")":""};`)}case"css":{if(v.presentationalDependencies!==undefined){for(const I of v.presentationalDependencies){handleDependency(I)}}I.runtimeRequirements.add(xe.hasCssModules);return ae.addToSource(K,ge,I)}}}getTypes(v){return this.exportsOnly?ge:be}getSize(v,I){switch(I){case"javascript":{if(!v.buildInfo.cssData){return 42}const I=v.buildInfo.cssData.exports;const P=JSON.stringify(Array.from(I).reduce(((v,[I,P])=>{v[I]=P;return v}),{}));return P.length+42}case"css":{const I=v.originalSource();if(!I){return 0}return I.size()}}}updateHash(v,{module:I}){v.update(this.esModule.toString())}}v.exports=CssGenerator},80928:function(v,I,P){"use strict";const{SyncWaterfallHook:R}=P(84891);const $=P(29327);const L=P(5205);const q=P(78994);const K=P(57227);const ae=P(61935);const{chunkHasCss:ge}=P(53296);const be=new WeakMap;class CssLoadingRuntimeModule extends q{static getCompilationHooks(v){if(!(v instanceof $)){throw new TypeError("The 'compilation' argument must be an instance of Compilation")}let I=be.get(v);if(I===undefined){I={createStylesheet:new R(["source","chunk"]),linkPreload:new R(["source","chunk"]),linkPrefetch:new R(["source","chunk"])};be.set(v,I)}return I}constructor(v){super("css loading",10);this._runtimeRequirements=v}generate(){const{_runtimeRequirements:v}=this;const I=this.compilation;const P=this.chunk;const{chunkGraph:R,runtimeTemplate:$,outputOptions:{crossOriginLoading:q,uniqueName:be,chunkLoadTimeout:xe,charset:ve}}=I;const Ce=L.ensureChunkHandlers;const Ne=R.getChunkConditionMap(P,((v,I)=>Boolean(I.getChunkModulesIterableBySourceType(v,"css"))));const He=ae(Ne);const Qe=v.has(L.ensureChunkHandlers)&&He!==false;const Je=v.has(L.hmrDownloadUpdateHandlers);const Ve=new Set;for(const v of P.getAllInitialChunks()){if(ge(v,R)){Ve.add(v.id)}}if(!Qe&&!Je){return null}const Ke=I.outputOptions.environment;const Ye=$.isNeutralPlatform();const Xe=this._runtimeRequirements.has(L.prefetchChunkHandlers)&&(Ke.document||Ye)&&P.hasChildByOrder(R,"prefetch",true,ge);const Ze=this._runtimeRequirements.has(L.preloadChunkHandlers)&&(Ke.document||Ye)&&P.hasChildByOrder(R,"preload",true,ge);const{linkPreload:et,linkPrefetch:tt}=CssLoadingRuntimeModule.getCompilationHooks(I);const nt=v.has(L.hasFetchPriority);const{createStylesheet:st}=CssLoadingRuntimeModule.getCompilationHooks(I);const rt=Je?`${L.hmrRuntimeStatePrefix}_css`:undefined;const ot=K.asString(["link = document.createElement('link');",ve?"link.charset = 'utf-8';":"",`if (${L.scriptNonce}) {`,K.indent(`link.setAttribute("nonce", ${L.scriptNonce});`),"}",be?'link.setAttribute("data-webpack", uniqueName + ":" + key);':"",nt?K.asString(["if(fetchPriority) {",K.indent('link.setAttribute("fetchpriority", fetchPriority);'),"}"]):"","link.setAttribute(loadingAttribute, 1);",'link.rel = "stylesheet";',"link.href = url;",q?q==="use-credentials"?'link.crossOrigin = "use-credentials";':K.asString(["if (link.href.indexOf(window.location.origin + '/') !== 0) {",K.indent(`link.crossOrigin = ${JSON.stringify(q)};`),"}"]):""]);return K.asString(["// object to store loaded and loading chunks","// undefined = chunk not loaded, null = chunk preloaded/prefetched","// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded",`var installedChunks = ${rt?`${rt} = ${rt} || `:""}{`,K.indent(Array.from(Ve,(v=>`${JSON.stringify(v)}: 0`)).join(",\n")),"};","",be?`var uniqueName = ${JSON.stringify($.outputOptions.uniqueName)};`:"// data-webpack is not used as build has no uniqueName",Qe||Je?K.asString(['var loadingAttribute = "data-webpack-loading";',`var loadStylesheet = ${$.basicFunction(`chunkId, url, done${nt?", fetchPriority":""}${Je?", hmr":""}`,['var link, needAttach, key = "chunk-" + chunkId;',Je?"if(!hmr) {":"",'var links = document.getElementsByTagName("link");',"for(var i = 0; i < links.length; i++) {",K.indent(["var l = links[i];",`if(l.rel == "stylesheet" && (${Je?'l.href.startsWith(url) || l.getAttribute("href").startsWith(url)':'l.href == url || l.getAttribute("href") == url'}${be?' || l.getAttribute("data-webpack") == uniqueName + ":" + key':""})) { link = l; break; }`]),"}","if(!done) return link;",Je?"}":"","if(!link) {",K.indent(["needAttach = true;",st.call(ot,this.chunk)]),"}",`var onLinkComplete = ${$.basicFunction("prev, event",K.asString(["link.onerror = link.onload = null;","link.removeAttribute(loadingAttribute);","clearTimeout(timeout);",'if(event && event.type != "load") link.parentNode.removeChild(link)',"done(event);","if(prev) return prev(event);"]))};`,"if(link.getAttribute(loadingAttribute)) {",K.indent([`var timeout = setTimeout(onLinkComplete.bind(null, undefined, { type: 'timeout', target: link }), ${xe});`,"link.onerror = onLinkComplete.bind(null, link.onerror);","link.onload = onLinkComplete.bind(null, link.onload);"]),"} else onLinkComplete(undefined, { type: 'load', target: link });",Je&&nt?'if (hmr && hmr.getAttribute("fetchpriority")) link.setAttribute("fetchpriority", hmr.getAttribute("fetchpriority"));':"",Je?"hmr ? document.head.insertBefore(link, hmr) :":"","needAttach && document.head.appendChild(link);","return link;"])};`]):"",Qe?K.asString([`${Ce}.css = ${$.basicFunction(`chunkId, promises${nt?" , fetchPriority":""}`,["// css chunk loading",`var installedChunkData = ${L.hasOwnProperty}(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;`,'if(installedChunkData !== 0) { // 0 means "already installed".',K.indent(["",'// a Promise means "currently loading".',"if(installedChunkData) {",K.indent(["promises.push(installedChunkData[2]);"]),"} else {",K.indent([He===true?"if(true) { // all chunks have CSS":`if(${He("chunkId")}) {`,K.indent(["// setup Promise in chunk cache",`var promise = new Promise(${$.expressionFunction("installedChunkData = installedChunks[chunkId] = [resolve, reject]","resolve, reject")});`,"promises.push(installedChunkData[2] = promise);","","// start chunk loading",`var url = ${L.publicPath} + ${L.getChunkCssFilename}(chunkId);`,"// create error before stack unwound to get useful stacktrace later","var error = new Error();",`var loadingEnded = ${$.basicFunction("event",[`if(${L.hasOwnProperty}(installedChunks, chunkId)) {`,K.indent(["installedChunkData = installedChunks[chunkId];","if(installedChunkData !== 0) installedChunks[chunkId] = undefined;","if(installedChunkData) {",K.indent(['if(event.type !== "load") {',K.indent(["var errorType = event && event.type;","var realHref = event && event.target && event.target.href;","error.message = 'Loading css chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realHref + ')';","error.name = 'ChunkLoadError';","error.type = errorType;","error.request = realHref;","installedChunkData[1](error);"]),"} else {",K.indent(["installedChunks[chunkId] = 0;","installedChunkData[0]();"]),"}"]),"}"]),"}"])};`,Ye?"if (typeof document !== 'undefined') {":"",K.indent([`loadStylesheet(chunkId, url, loadingEnded${nt?", fetchPriority":""});`]),Ye?"} else { loadingEnded({ type: 'load' }); }":""]),"} else installedChunks[chunkId] = 0;"]),"}"]),"}"])};`]):"// no chunk loading","",Xe&&He!==false?`${L.prefetchChunkHandlers}.s = ${$.basicFunction("chunkId",[`if((!${L.hasOwnProperty}(installedChunks, chunkId) || installedChunks[chunkId] === undefined) && ${He===true?"true":He("chunkId")}) {`,K.indent(["installedChunks[chunkId] = null;",Ye?"if (typeof document === 'undefined') return;":"",tt.call(K.asString(["var link = document.createElement('link');",ve?"link.charset = 'utf-8';":"",q?`link.crossOrigin = ${JSON.stringify(q)};`:"",`if (${L.scriptNonce}) {`,K.indent(`link.setAttribute("nonce", ${L.scriptNonce});`),"}",'link.rel = "prefetch";','link.as = "style";',`link.href = ${L.publicPath} + ${L.getChunkCssFilename}(chunkId);`]),P),"document.head.appendChild(link);"]),"}"])};`:"// no prefetching","",Ze&&He!==false?`${L.preloadChunkHandlers}.s = ${$.basicFunction("chunkId",[`if((!${L.hasOwnProperty}(installedChunks, chunkId) || installedChunks[chunkId] === undefined) && ${He===true?"true":He("chunkId")}) {`,K.indent(["installedChunks[chunkId] = null;",Ye?"if (typeof document === 'undefined') return;":"",et.call(K.asString(["var link = document.createElement('link');",ve?"link.charset = 'utf-8';":"",`if (${L.scriptNonce}) {`,K.indent(`link.setAttribute("nonce", ${L.scriptNonce});`),"}",'link.rel = "preload";','link.as = "style";',`link.href = ${L.publicPath} + ${L.getChunkCssFilename}(chunkId);`,q?q==="use-credentials"?'link.crossOrigin = "use-credentials";':K.asString(["if (link.href.indexOf(window.location.origin + '/') !== 0) {",K.indent(`link.crossOrigin = ${JSON.stringify(q)};`),"}"]):""]),P),"document.head.appendChild(link);"]),"}"])};`:"// no preloaded",Je?K.asString(["var oldTags = [];","var newTags = [];",`var applyHandler = ${$.basicFunction("options",[`return { dispose: ${$.basicFunction("",["while(oldTags.length) {",K.indent(["var oldTag = oldTags.pop();","if(oldTag.parentNode) oldTag.parentNode.removeChild(oldTag);"]),"}"])}, apply: ${$.basicFunction("",["while(newTags.length) {",K.indent(["var newTag = newTags.pop();","newTag.sheet.disabled = false"]),"}"])} };`])}`,`var cssTextKey = ${$.returningFunction(`Array.from(link.sheet.cssRules, ${$.returningFunction("r.cssText","r")}).join()`,"link")};`,`${L.hmrDownloadUpdateHandlers}.css = ${$.basicFunction("chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList",[Ye?"if (typeof document === 'undefined') return;":"","applyHandlers.push(applyHandler);",`chunkIds.forEach(${$.basicFunction("chunkId",[`var filename = ${L.getChunkCssFilename}(chunkId);`,`var url = ${L.publicPath} + filename;`,"var oldTag = loadStylesheet(chunkId, url);","if(!oldTag) return;",`promises.push(new Promise(${$.basicFunction("resolve, reject",[`var link = loadStylesheet(chunkId, url + (url.indexOf("?") < 0 ? "?" : "&") + "hmr=" + Date.now(), ${$.basicFunction("event",['if(event.type !== "load") {',K.indent(["var errorType = event && event.type;","var realHref = event && event.target && event.target.href;","error.message = 'Loading css hot update chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realHref + ')';","error.name = 'ChunkLoadError';","error.type = errorType;","error.request = realHref;","reject(error);"]),"} else {",K.indent(["try { if(cssTextKey(oldTag) == cssTextKey(link)) { if(link.parentNode) link.parentNode.removeChild(link); return resolve(); } } catch(e) {}","link.sheet.disabled = true;","oldTags.push(oldTag);","newTags.push(link);","resolve();"]),"}"])}, ${nt?"undefined,":""} oldTag);`])}));`])});`])}`]):"// no hmr"])}}v.exports=CssLoadingRuntimeModule},53296:function(v,I,P){"use strict";const{SyncWaterfallHook:R,SyncHook:$}=P(84891);const{ConcatSource:L,PrefixSource:q,ReplaceSource:K,CachedSource:ae,RawSource:ge}=P(51255);const be=P(29327);const xe=P(8176);const{tryRunOrWebpackError:ve}=P(73404);const Ce=P(59336);const{CSS_MODULE_TYPE:Ne,CSS_MODULE_TYPE_GLOBAL:He,CSS_MODULE_TYPE_MODULE:Qe,CSS_MODULE_TYPE_AUTO:Je}=P(6041);const Ve=P(5205);const Ke=P(48700);const Ye=P(57227);const Xe=P(94252);const Ze=P(78388);const et=P(74953);const tt=P(57554);const nt=P(35640);const st=P(4530);const rt=P(90006);const ot=P(79026);const it=P(92296);const at=P(36926);const{compareModulesByIdOrIdentifier:ct}=P(21398);const lt=P(86750);const ut=P(12471);const{getUndoPath:pt}=P(46579);const dt=P(13594);const ft=P(64307);const ht=P(67103);const mt=P(42197);const gt=dt((()=>P(80928)));const getSchema=v=>{const{definitions:I}=P(59992);return{definitions:I,oneOf:[{$ref:`#/definitions/${v}`}]}};const yt={name:"Css Modules Plugin",baseDataPath:"generator"};const bt={css:lt(P(40537),(()=>getSchema("CssGeneratorOptions")),yt),"css/auto":lt(P(28456),(()=>getSchema("CssAutoGeneratorOptions")),yt),"css/module":lt(P(27060),(()=>getSchema("CssModuleGeneratorOptions")),yt),"css/global":lt(P(83654),(()=>getSchema("CssGlobalGeneratorOptions")),yt)};const xt={name:"Css Modules Plugin",baseDataPath:"parser"};const kt={css:lt(P(70344),(()=>getSchema("CssParserOptions")),xt),"css/auto":lt(P(51768),(()=>getSchema("CssAutoParserOptions")),xt),"css/module":lt(P(59132),(()=>getSchema("CssModuleParserOptions")),xt),"css/global":lt(P(12582),(()=>getSchema("CssGlobalParserOptions")),xt)};const vt=new WeakMap;const wt="CssModulesPlugin";class CssModulesPlugin{static getCompilationHooks(v){if(!(v instanceof be)){throw new TypeError("The 'compilation' argument must be an instance of Compilation")}let I=vt.get(v);if(I===undefined){I={renderModulePackage:new R(["source","module","renderContext"]),chunkHash:new $(["chunk","hash","context"])};vt.set(v,I)}return I}constructor(){this._moduleFactoryCache=new WeakMap}apply(v){v.hooks.compilation.tap(wt,((v,{normalModuleFactory:I})=>{const P=CssModulesPlugin.getCompilationHooks(v);const R=new Ke(v.moduleGraph);v.dependencyFactories.set(nt,I);v.dependencyTemplates.set(nt,new nt.Template);v.dependencyFactories.set(ot,I);v.dependencyTemplates.set(ot,new ot.Template);v.dependencyTemplates.set(st,new st.Template);v.dependencyFactories.set(rt,R);v.dependencyTemplates.set(rt,new rt.Template);v.dependencyFactories.set(et,I);v.dependencyTemplates.set(et,new et.Template);v.dependencyTemplates.set(Ze,new Ze.Template);v.dependencyTemplates.set(tt,new tt.Template);v.dependencyTemplates.set(it,new it.Template);for(const P of[Ne,He,Qe,Je]){I.hooks.createParser.for(P).tap(wt,(v=>{kt[P](v);const{url:I,import:R,namedExports:$}=v;switch(P){case Ne:return new mt({importOption:R,url:I,namedExports:$});case He:return new mt({defaultMode:"global",importOption:R,url:I,namedExports:$});case Qe:return new mt({defaultMode:"local",importOption:R,url:I,namedExports:$});case Je:return new mt({defaultMode:"auto",importOption:R,url:I,namedExports:$})}}));I.hooks.createGenerator.for(P).tap(wt,(v=>{bt[P](v);return new ht(v)}));I.hooks.createModuleClass.for(P).tap(wt,((I,P)=>{if(P.dependencies.length>0){const R=P.dependencies[0];if(R instanceof nt){const P=v.moduleGraph.getParentModule(R);if(P instanceof xe){let v;if(P.cssLayer!==undefined||P.supports||P.media){if(!v){v=[]}v.push([P.cssLayer,P.supports,P.media])}if(P.inheritance){if(!v){v=[]}v.push(...P.inheritance)}return new xe({...I,cssLayer:R.layer,supports:R.supports,media:R.media,inheritance:v})}return new xe({...I,cssLayer:R.layer,supports:R.supports,media:R.media})}}return new xe(I)}))}at.getCompilationHooks(v).renderModuleContent.tap(wt,((v,I)=>{if(I instanceof xe&&I.hot){const P=I.buildInfo.cssData.exports;const R=JSON.stringify(JSON.stringify(Array.from(P).reduce(((v,[I,P])=>{v[I]=P;return v}),{})));const $=Ye.asString(["",`var __webpack_css_exports__ = ${R};`,"// only invalidate when locals change","if (module.hot.data && module.hot.data.__webpack_css_exports__ && module.hot.data.__webpack_css_exports__ != __webpack_css_exports__) {",Ye.indent("module.hot.invalidate();"),"} else {",Ye.indent("module.hot.accept();"),"}","module.hot.dispose(function(data) { data.__webpack_css_exports__ = __webpack_css_exports__; });"]);return new L(v,"\n",new ge($))}}));const $=new WeakMap;v.hooks.afterCodeGeneration.tap(wt,(()=>{const{chunkGraph:I}=v;for(const P of v.chunks){if(CssModulesPlugin.chunkHasCss(P,I)){$.set(P,this.getOrderedChunkCssModules(P,I,v))}}}));v.hooks.chunkHash.tap(wt,((v,I,R)=>{P.chunkHash.call(v,I,R)}));v.hooks.contentHash.tap(wt,(I=>{const{chunkGraph:R,codeGenerationResults:L,moduleGraph:q,runtimeTemplate:K,outputOptions:{hashSalt:ae,hashDigest:ge,hashDigestLength:be,hashFunction:xe}}=v;const ve=ut(xe);if(ae)ve.update(ae);P.chunkHash.call(I,ve,{chunkGraph:R,codeGenerationResults:L,moduleGraph:q,runtimeTemplate:K});const Ce=$.get(I);if(Ce){for(const v of Ce){ve.update(R.getModuleHash(v,I.runtime))}}const Ne=ve.digest(ge);I.contentHash.css=ft(Ne,be)}));v.hooks.renderManifest.tap(wt,((I,R)=>{const{chunkGraph:L}=v;const{hash:q,chunk:K,codeGenerationResults:ae,runtimeTemplate:ge}=R;if(K instanceof Ce)return I;const be=$.get(K);if(be!==undefined){const{path:R,info:$}=v.getPathWithInfo(CssModulesPlugin.getChunkFilenameTemplate(K,v.outputOptions),{hash:q,runtime:K.runtime,chunk:K,contentHashType:"css"});const xe=pt(R,v.outputOptions.path,false);I.push({render:()=>this.renderChunk({chunk:K,chunkGraph:L,codeGenerationResults:ae,uniqueName:v.outputOptions.uniqueName,undoPath:xe,modules:be,runtimeTemplate:ge},P),filename:R,info:$,identifier:`css${K.id}`,hash:K.contentHash.css})}return I}));const q=v.outputOptions.chunkLoading;const isEnabledForChunk=v=>{const I=v.getEntryOptions();const P=I&&I.chunkLoading!==undefined?I.chunkLoading:q;return P==="jsonp"||P==="import"};const K=new WeakSet;const handler=(I,P)=>{if(K.has(I))return;K.add(I);if(!isEnabledForChunk(I))return;P.add(Ve.makeNamespaceObject);const R=gt();v.addRuntimeModule(I,new R(P))};v.hooks.runtimeRequirementInTree.for(Ve.hasCssModules).tap(wt,handler);v.hooks.runtimeRequirementInTree.for(Ve.ensureChunkHandlers).tap(wt,((v,I,{chunkGraph:P})=>{if(!isEnabledForChunk(v))return;if(!P.hasModuleInGraph(v,(v=>v.type===Ne||v.type===He||v.type===Qe||v.type===Je))){return}I.add(Ve.hasOwnProperty);I.add(Ve.publicPath);I.add(Ve.getChunkCssFilename)}));v.hooks.runtimeRequirementInTree.for(Ve.hmrDownloadUpdateHandlers).tap(wt,((v,I,{chunkGraph:P})=>{if(!isEnabledForChunk(v))return;if(!P.hasModuleInGraph(v,(v=>v.type===Ne||v.type===He||v.type===Qe||v.type===Je))){return}I.add(Ve.publicPath);I.add(Ve.getChunkCssFilename)}))}))}getModulesInOrder(v,I,P){if(!I)return[];const R=[...I];const $=Array.from(v.groupsIterable,(v=>{const I=R.map((I=>({module:I,index:v.getModulePostOrderIndex(I)}))).filter((v=>v.index!==undefined)).sort(((v,I)=>I.index-v.index)).map((v=>v.module));return{list:I,set:new Set(I)}}));if($.length===1)return $[0].list.reverse();const L=ct(P.chunkGraph);const compareModuleLists=({list:v},{list:I})=>{if(v.length===0){return I.length===0?0:1}if(I.length===0)return-1;return L(v[v.length-1],I[I.length-1])};$.sort(compareModuleLists);const q=[];for(;;){const I=new Set;const R=$[0].list;if(R.length===0){break}let L=R[R.length-1];let K;e:for(;;){for(const{list:v,set:P}of $){if(v.length===0)continue;const R=v[v.length-1];if(R===L)continue;if(!P.has(L))continue;I.add(L);if(I.has(R)){K=R;continue}L=R;K=false;continue e}break}if(K){P.warnings.push(new Xe(`chunk ${v.name||v.id}\nConflicting order between ${K.readableIdentifier(P.requestShortener)} and ${L.readableIdentifier(P.requestShortener)}`));L=K}q.push(L);for(const{list:v,set:I}of $){const P=v[v.length-1];if(P===L)v.pop();else if(K&&I.has(L)){const I=v.indexOf(L);if(I>=0)v.splice(I,1)}}$.sort(compareModuleLists)}return q}getOrderedChunkCssModules(v,I,P){return[...this.getModulesInOrder(v,I.getOrderedChunkModulesIterableBySourceType(v,"css-import",ct(I)),P),...this.getModulesInOrder(v,I.getOrderedChunkModulesIterableBySourceType(v,"css",ct(I)),P)]}renderModule(v,I,P){const{codeGenerationResults:R,chunk:$,undoPath:ge}=I;const be=R.get(v,$.runtime);const xe=be.sources.get("css")||be.sources.get("css-import");const Ce=this._moduleFactoryCache.get(xe);const Ne=[[v.cssLayer,v.supports,v.media]];if(v.inheritance){Ne.push(...v.inheritance)}let He;if(Ce&&Ce.undoPath===ge&&Ce.inheritance.every((([v,I,P],R)=>{const $=Ne[R];if(Array.isArray($)){return v===$[0]&&I===$[1]&&P===$[2]}return false}))){He=Ce.source}else{const v=xe.source();const I=new RegExp(ot.PUBLIC_PATH_AUTO,"g");let P=new K(xe);let R;while(R=I.exec(v)){P.replace(R.index,R.index+=R[0].length-1,ge)}for(let v=0;v<Ne.length;v++){const I=Ne[v][0];const R=Ne[v][1];const $=Ne[v][2];if($){P=new L(`@media ${$} {\n`,new q("\t",P),"}\n")}if(R){P=new L(`@supports (${R}) {\n`,new q("\t",P),"}\n")}if(I!==undefined&&I!==null){P=new L(`@layer${I?` ${I}`:""} {\n`,new q("\t",P),"}\n")}}if(P){P=new L(P,"\n")}He=new ae(P);this._moduleFactoryCache.set(xe,{inheritance:Ne,undoPath:ge,source:He})}return ve((()=>P.renderModulePackage.call(He,v,I)),"CssModulesPlugin.getCompilationHooks().renderModulePackage")}renderChunk({undoPath:v,chunk:I,chunkGraph:P,codeGenerationResults:R,modules:$,runtimeTemplate:q},K){const ae=new L;for(const L of $){try{const $=this.renderModule(L,{undoPath:v,chunk:I,chunkGraph:P,codeGenerationResults:R,runtimeTemplate:q},K);ae.add($)}catch(v){v.message+=`\nduring rendering of css ${L.identifier()}`;throw v}}I.rendered=true;return ae}static getChunkFilenameTemplate(v,I){if(v.cssFilenameTemplate){return v.cssFilenameTemplate}else if(v.canBeInitial()){return I.cssFilename}return I.cssChunkFilename}static chunkHasCss(v,I){return Boolean(I.getChunkModulesIterableBySourceType(v,"css"))||Boolean(I.getChunkModulesIterableBySourceType(v,"css-import"))}}v.exports=CssModulesPlugin},42197:function(v,I,P){"use strict";const R=P(26144);const $=P(14102);const L=P(96868);const{CSS_MODULE_TYPE_AUTO:q}=P(6041);const K=P(33157);const ae=P(53966);const ge=P(94252);const be=P(34022);const xe=P(78388);const ve=P(74953);const Ce=P(57554);const Ne=P(35640);const He=P(4530);const Qe=P(90006);const Je=P(79026);const Ve=P(92296);const Ke=P(1671);const{parseResource:Ye}=P(46579);const{webpackCommentRegExp:Xe,createMagicCommentContext:Ze}=P(47559);const et=P(66954);const tt=":".charCodeAt(0);const nt="/".charCodeAt(0);const st="(".charCodeAt(0);const rt=")".charCodeAt(0);const ot="f".charCodeAt(0);const it="F".charCodeAt(0);const at=/\\[\n\r\f]/g;const ct=/(^[ \t\n\r\f]*|[ \t\n\r\f]*$)/g;const lt=/\\([0-9a-fA-F]{1,6}[ \t\n\r\f]?|[\s\S])/g;const ut=/^(-\w+-)?image-set$/i;const pt=/^@(-\w+-)?keyframes$/;const dt=/^(-\w+-)?animation(-name)?$/i;const ft=/\.module(s)?\.[^.]+$/i;const ht=/\/\*((?!\*\/).*?)\*\//g;const normalizeUrl=(v,I)=>{if(I){v=v.replace(at,"")}v=v.replace(ct,"").replace(lt,(v=>{if(v.length>2){return String.fromCharCode(Number.parseInt(v.slice(1).trim(),16))}return v[1]}));if(/^data:/i.test(v)){return v}if(v.includes("%")){try{v=decodeURIComponent(v)}catch(v){}}return v};const mt=/[ -,.\/:-@[\]\^`{-~]/;const gt=/(^|\\+)?(\\[A-F0-9]{1,6})\u0020(?![a-fA-F0-9\u0020])/g;const escapeIdentifier=v=>{let I="";let P=0;while(P<v.length){const R=v.charAt(P++);let $;if(/[\t\n\f\r\u000B]/.test(R)){const v=R.charCodeAt(0);$=`\\${v.toString(16).toUpperCase()} `}else if(R==="\\"||mt.test(R)){$=`\\${R}`}else{$=R}I+=$}const R=v.charAt(0);if(/^-[-\d]/.test(I)){I=`\\-${I.slice(1)}`}else if(/\d/.test(R)){I=`\\3${R} ${I.slice(1)}`}I=I.replace(gt,((v,I,P)=>{if(I&&I.length%2){return v}return(I||"")+P}));return I};const yt=/\\/;const gobbleHex=v=>{const I=v.toLowerCase();let P="";let R=false;for(let v=0;v<6&&I[v]!==undefined;v++){const $=I.charCodeAt(v);const L=$>=97&&$<=102||$>=48&&$<=57;R=$===32;if(!L)break;P+=I[v]}if(P.length===0)return undefined;const $=Number.parseInt(P,16);const L=$>=55296&&$<=57343;if(L||$===0||$>1114111){return["ï¿½",P.length+(R?1:0)]}return[String.fromCodePoint($),P.length+(R?1:0)]};const unescapeIdentifier=v=>{const I=yt.test(v);if(!I)return v;let P="";for(let I=0;I<v.length;I++){if(v[I]==="\\"){const R=gobbleHex(v.slice(I+1,I+7));if(R!==undefined){P+=R[0];I+=R[1];continue}if(v[I+1]==="\\"){P+="\\";I+=1;continue}if(v.length===I+1){P+=v[I]}continue}P+=v[I]}return P};class LocConverter{constructor(v){this._input=v;this.line=1;this.column=0;this.pos=0}get(v){if(this.pos!==v){if(this.pos<v){const I=this._input.slice(this.pos,v);let P=I.lastIndexOf("\n");if(P===-1){this.column+=I.length}else{this.column=I.length-P-1;this.line++;while(P>0&&(P=I.lastIndexOf("\n",P-1))!==-1)this.line++}}else{let I=this._input.lastIndexOf("\n",this.pos);while(I>=v){this.line--;I=I>0?this._input.lastIndexOf("\n",I-1):-1}this.column=v-I}this.pos=v}return this}}const bt={options:null,errors:null};const xt=0;const kt=1;const vt=et.eatUntil(";");const wt=et.eatUntil("{");const Ct=et.eatUntil(";");class CssParser extends K{constructor({defaultMode:v="pure",importOption:I=true,url:P=true,namedExports:R=true}={}){super();this.defaultMode=v;this.import=I;this.url=P;this.namedExports=R;this.comments=undefined;this.magicCommentContext=Ze()}_emitWarning(v,I,P,R,$){const{line:q,column:K}=P.get(R);const{line:ae,column:be}=P.get($);v.current.addWarning(new L(v.module,new ge(I),{start:{line:q,column:K},end:{line:ae,column:be}}))}parse(v,I){if(Buffer.isBuffer(v)){v=v.toString("utf-8")}else if(typeof v==="object"){throw new Error("webpackAst is unexpected for the CssParser")}if(v[0]==="\ufeff"){v=v.slice(1)}let P=this.defaultMode;const R=I.module;if(P==="auto"&&R.type===q&&ft.test(Ye(R.matchResource||R.resource).path)){P="local"}const L=P==="global"||P==="local";const K=new LocConverter(v);let ge=xt;let Ke=true;const Xe=[];let Ze=0;let at=L;let ct=0;let lt;let mt=false;let gt;const yt=new Set;const bt=new Map;const isNextNestedSyntax=(v,I)=>{I=et.eatWhitespaceAndComments(v,I);if(v[I]==="}"){return false}const P=et.isIdentStartCodePoint(v.charCodeAt(I));return!P};const isLocalMode=()=>lt==="local"||P==="local"&&lt===undefined;const eatText=(v,I,P)=>{let R="";for(;;){if(v.charCodeAt(I)===nt){const P=et.eatComments(v,I);if(I!==P){I=P;if(I===v.length)break}else{R+="/";I++;if(I===v.length)break}}const $=P(v,I);if(I!==$){R+=v.slice(I,$);I=$}else{break}if(I===v.length)break}return[I,R.trimEnd()]};const parseImportOrExport=(v,P,$)=>{$=et.eatWhitespaceAndComments(P,$);let L;if(v===0){let v=P.charCodeAt($);if(v!==st){this._emitWarning(I,`Unexpected '${P[$]}' at ${$} during parsing of ':import' (expected '(')`,K,$,$);return $}$++;const R=$;const q=et.eatString(P,$);if(!q){this._emitWarning(I,`Unexpected '${P[$]}' at ${$} during parsing of ':import' (expected string)`,K,R,$);return $}L=P.slice(q[0]+1,q[1]-1);$=q[1];$=et.eatWhitespaceAndComments(P,$);v=P.charCodeAt($);if(v!==rt){this._emitWarning(I,`Unexpected '${P[$]}' at ${$} during parsing of ':import' (expected ')')`,K,$,$);return $}$++;$=et.eatWhitespaceAndComments(P,$)}const createDep=(I,P,$,q)=>{if(v===0){bt.set(I,{path:L,value:P})}else if(v===1){const v=new xe(I,P);const{line:L,column:ae}=K.get($);const{line:ge,column:be}=K.get(q);v.setLoc(L,ae,ge,be);R.addDependency(v)}};let q=false;let ae=0;let ge;let be;let ve;const Ce={leftCurlyBracket:(v,I,P)=>{ae++;if(ge===undefined){ge=0}return P},rightCurlyBracket:(v,I,R)=>{ae--;if(ge===2){createDep(P.slice(be[0],be[1]),P.slice(ve,R-1).trim(),be[1],R-1);ge=0}if(ae===0&&ge===0){q=true}return R},identifier:(v,I,P)=>{if(ge===0){be=[I,P];ge=1}return P},colon:(v,I,R)=>{if(ge===1){ge=2;ve=et.eatWhitespace(P,R);return ve}return R},semicolon:(v,I,P)=>{if(ge===2){createDep(v.slice(be[0],be[1]),v.slice(ve,P-1),be[1],P-1);ge=0}return P},needTerminate:()=>q};$=et(P,$,Ce);$=et.eatWhiteLine(P,$);return $};const Et=et.eatUntil(":{};");const processLocalDeclaration=(v,I,P)=>{lt=undefined;I=et.eatWhitespaceAndComments(v,I);const $=I;const[L,q]=eatText(v,I,Et);if(v.charCodeAt(L)!==tt)return P;I=L+1;if(q.startsWith("--")&&q.length>=3){const{line:v,column:I}=K.get($);const{line:P,column:ae}=K.get(L);const ge=unescapeIdentifier(q.slice(2));const be=new He(ge,[$,L],"--");be.setLoc(v,I,P,ae);R.addDependency(be);yt.add(ge)}else if(dt.test(q)){mt=true}return I};const processDeclarationValueDone=v=>{if(mt&&gt){const{line:I,column:P}=K.get(gt[0]);const{line:$,column:L}=K.get(gt[1]);const q=unescapeIdentifier(gt[2]?v.slice(gt[0],gt[1]):v.slice(gt[0]+1,gt[1]-1));const ae=new Qe(q,[gt[0],gt[1]]);ae.setLoc(I,P,$,L);R.addDependency(ae);gt=undefined}};const comment=(v,I,P)=>{if(!this.comments)this.comments=[];const{line:R,column:$}=K.get(I);const{line:L,column:q}=K.get(P);const ae={value:v.slice(I+2,P-2),range:[I,P],loc:{start:{line:R,column:$},end:{line:L,column:q}}};this.comments.push(ae);return P};et(v,0,{comment:comment,leftCurlyBracket:(v,I,P)=>{switch(ge){case xt:{Ke=false;ge=kt;if(L){ct=1;at=isNextNestedSyntax(v,P)}break}case kt:{if(L){ct++;at=isNextNestedSyntax(v,P)}break}}return P},rightCurlyBracket:(v,I,P)=>{switch(ge){case kt:{if(--ct===0){ge=xt;if(L){at=true;lt=undefined}}else if(L){if(isLocalMode()){processDeclarationValueDone(v);mt=false}at=isNextNestedSyntax(v,P)}break}}return P},url:(v,P,L,q,ge)=>{if(!this.url){return L}const{options:be,errors:xe}=this.parseCommentOptions([Ze,L]);if(xe){for(const v of xe){const{comment:P}=v;I.module.addWarning(new $(`Compilation error while processing magic comment(-s): /*${P.value}*/: ${v.message}`,P.loc))}}if(be&&be.webpackIgnore!==undefined){if(typeof be.webpackIgnore!=="boolean"){const{line:v,column:P}=K.get(Ze);const{line:R,column:$}=K.get(L);I.module.addWarning(new ae(`\`webpackIgnore\` expected a boolean, but received: ${be.webpackIgnore}.`,{start:{line:v,column:P},end:{line:R,column:$}}))}else if(be.webpackIgnore){return L}}const ve=normalizeUrl(v.slice(q,ge),false);if(ve.length===0)return L;const Ce=new Je(ve,[P,L],"url");const{line:Ne,column:He}=K.get(P);const{line:Qe,column:Ve}=K.get(L);Ce.setLoc(Ne,He,Qe,Ve);R.addDependency(Ce);R.addCodeGenerationDependency(Ce);return L},string:(v,I,P)=>{switch(ge){case kt:{if(mt&&Xe.length===0){gt=[I,P,false]}}}return P},atKeyword:(v,P,q)=>{const ge=v.slice(P,q).toLowerCase();switch(ge){case"@namespace":{this._emitWarning(I,"'@namespace' is not supported in bundled CSS",K,P,q);return vt(v,P)}case"@import":{if(!this.import){return Ct(v,q)}if(!Ke){this._emitWarning(I,"Any '@import' rules must precede all other rules",K,P,q);return q}const L=et.eatImportTokens(v,q,{comment:comment});if(!L[3])return q;const ge=L[3][1];if(!L[0]){this._emitWarning(I,`Expected URL in '${v.slice(P,ge)}'`,K,P,ge);return q}const xe=L[0];const ve=normalizeUrl(v.slice(xe[2],xe[3]),true);const Ce=et.eatWhiteLine(v,ge);const{options:He,errors:Qe}=this.parseCommentOptions([q,xe[1]]);if(Qe){for(const v of Qe){const{comment:P}=v;I.module.addWarning(new $(`Compilation error while processing magic comment(-s): /*${P.value}*/: ${v.message}`,P.loc))}}if(He&&He.webpackIgnore!==undefined){if(typeof He.webpackIgnore!=="boolean"){const{line:v,column:R}=K.get(P);const{line:$,column:L}=K.get(Ce);I.module.addWarning(new ae(`\`webpackIgnore\` expected a boolean, but received: ${He.webpackIgnore}.`,{start:{line:v,column:R},end:{line:$,column:L}}))}else if(He.webpackIgnore){return Ce}}if(ve.length===0){const{line:v,column:I}=K.get(P);const{line:$,column:L}=K.get(Ce);const q=new be("",[P,Ce]);R.addPresentationalDependency(q);q.setLoc(v,I,$,L);return Ce}let Je;if(L[1]){Je=v.slice(L[1][0]+6,L[1][1]-1).trim()}let Ve;if(L[2]){Ve=v.slice(L[2][0]+9,L[2][1]-1).trim()}const Ye=L[2]||L[1]||L[0];const Xe=et.eatWhitespaceAndComments(v,Ye[1]);let Ze;if(Xe!==ge-1){Ze=v.slice(Xe,ge-1).trim()}const{line:tt,column:nt}=K.get(P);const{line:st,column:rt}=K.get(Ce);const ot=new Ne(ve,[P,Ce],Je,Ve&&Ve.length>0?Ve:undefined,Ze&&Ze.length>0?Ze:undefined);ot.setLoc(tt,nt,st,rt);R.addDependency(ot);return Ce}default:{if(L){if(ge==="@value"){const $=vt(v,q);const L=$+1;const ae=v.slice(q,$);let[ge,ve]=ae.split(/\s*from\s*/);if(ve){const v=ge.replace(ht," ").trim().replace(/^\(|\)$/g,"").split(/\s*,\s*/);ve=ve.replace(ht,"").trim();const I=ve[0]==="'"||ve[0]==='"';if(I){ve=ve.slice(1,-1)}for(const I of v){const[v,P]=I.split(/\s*as\s*/);bt.set(P||v,{value:v,path:ve})}}else{const $=et.eatIdentSequence(ge,0);if(!$){this._emitWarning(I,`Broken '@value' at-rule: ${v.slice(P,L)}'`,K,P,L);const $=new be("",[P,L]);R.addPresentationalDependency($);return L}const ae=et.eatWhitespaceAndComments(ge,$[1]);const ve=ge.slice($[0],$[1]);let Ce=ge.charCodeAt(ae)===tt?ge.slice(ae+1):ge.slice($[1]);if(Ce&&!/^\s+$/.test(Ce)){Ce=Ce.trim()}if(bt.has(Ce)){const v=bt.get(Ce);Ce=v.value}bt.set(ve,{value:Ce});const Ne=new xe(ve,Ce);const{line:He,column:Qe}=K.get(P);const{line:Je,column:Ve}=K.get(q);Ne.setLoc(He,Qe,Je,Ve);R.addDependency(Ne)}const Ce=new be("",[P,L]);R.addPresentationalDependency(Ce);return L}else if(pt.test(ge)&&isLocalMode()){const I=et.eatIdentSequenceOrString(v,q);if(!I)return q;const P=unescapeIdentifier(I[2]===true?v.slice(I[0],I[1]):v.slice(I[0]+1,I[1]-1));const{line:$,column:L}=K.get(I[0]);const{line:ae,column:ge}=K.get(I[1]);const be=new He(P,[I[0],I[1]]);be.setLoc($,L,ae,ge);R.addDependency(be);return I[1]}else if(ge==="@property"&&isLocalMode()){const I=et.eatIdentSequence(v,q);if(!I)return q;let P=v.slice(I[0],I[1]);if(!P.startsWith("--")||P.length<3)return q;P=unescapeIdentifier(P.slice(2));yt.add(P);const{line:$,column:L}=K.get(I[0]);const{line:ae,column:ge}=K.get(I[1]);const be=new He(P,[I[0],I[1]],"--");be.setLoc($,L,ae,ge);R.addDependency(be);return I[1]}else if(ge==="@scope"){at=true;return q}at=false}}}return q},semicolon:(v,I,P)=>{if(L&&ge===kt){if(isLocalMode()){processDeclarationValueDone(v);mt=false}at=isNextNestedSyntax(v,P)}return P},identifier:(v,I,P)=>{if(L){if(bt.has(v.slice(I,P))){const $=v.slice(I,P);let{path:L,value:q}=bt.get($);if(L){if(bt.has(L)){const v=bt.get(L);L=v.value.slice(1,-1)}const v=new ve(L,q,[I,P-1]);const{line:$,column:ae}=K.get(I);const{line:ge,column:be}=K.get(P-1);v.setLoc($,ae,ge,be);R.addDependency(v)}else{const{line:v,column:L}=K.get(I);const{line:ae,column:ge}=K.get(P);const be=new Ce($,q,[I,P]);be.setLoc(v,L,ae,ge);R.addDependency(be)}return P}switch(ge){case kt:{if(isLocalMode()){if(mt&&Xe.length===0){gt=[I,P,true]}else{return processLocalDeclaration(v,I,P)}}break}}}return P},delim:(v,I,P)=>{if(at&&isLocalMode()){const I=et.skipCommentsAndEatIdentSequence(v,P);if(!I)return P;const $=unescapeIdentifier(v.slice(I[0],I[1]));const L=new He($,[I[0],I[1]]);const{line:q,column:ae}=K.get(I[0]);const{line:ge,column:be}=K.get(I[1]);L.setLoc(q,ae,ge,be);R.addDependency(L);return I[1]}return P},hash:(v,I,P,$)=>{if(at&&isLocalMode()&&$){const $=I+1;const L=unescapeIdentifier(v.slice($,P));const q=new He(L,[$,P]);const{line:ae,column:ge}=K.get(I);const{line:be,column:xe}=K.get(P);q.setLoc(ae,ge,be,xe);R.addDependency(q)}return P},colon:(v,P,$)=>{if(L){const L=et.skipCommentsAndEatIdentSequence(v,$);if(!L)return $;const q=v.slice(L[0],L[1]).toLowerCase();switch(ge){case xt:{if(q==="import"){const I=parseImportOrExport(0,v,L[1]);const $=new be("",[P,I]);R.addPresentationalDependency($);return I}else if(q==="export"){const I=parseImportOrExport(1,v,L[1]);const $=new be("",[P,I]);R.addPresentationalDependency($);return I}}default:{if(at){const ae=v.charCodeAt(L[1])===st;if(ae&&q==="local"){const v=L[1]+1;lt="local";const I=new be("",[P,v]);R.addPresentationalDependency(I);Xe.push([":local",P,v]);return v}else if(q==="local"){lt="local";$=et.eatWhitespace(v,L[1]);if(L[1]===$){this._emitWarning(I,`Missing whitespace after ':local' in '${v.slice(P,wt(v,$)+1)}'`,K,P,$)}const q=new be("",[P,$]);R.addPresentationalDependency(q);return $}else if(ae&&q==="global"){const v=L[1]+1;lt="global";const I=new be("",[P,v]);R.addPresentationalDependency(I);Xe.push([":global",P,v]);return v}else if(q==="global"){lt="global";$=et.eatWhitespace(v,L[1]);if(L[1]===$){this._emitWarning(I,`Missing whitespace after ':global' in '${v.slice(P,wt(v,$)+1)}'`,K,P,$)}const q=new be("",[P,$]);R.addPresentationalDependency(q);return $}}}}}Ze=$;return $},function:(v,P,L)=>{const q=v.slice(P,L-1).replace(/\\/g,"").toLowerCase();Xe.push([q,P,L]);switch(q){case"src":case"url":{if(!this.url){return L}const P=et.eatString(v,L);if(!P)return L;const{options:ge,errors:be}=this.parseCommentOptions([Ze,L]);if(be){for(const v of be){const{comment:P}=v;I.module.addWarning(new $(`Compilation error while processing magic comment(-s): /*${P.value}*/: ${v.message}`,P.loc))}}if(ge&&ge.webpackIgnore!==undefined){if(typeof ge.webpackIgnore!=="boolean"){const{line:v,column:R}=K.get(P[0]);const{line:$,column:L}=K.get(P[1]);I.module.addWarning(new ae(`\`webpackIgnore\` expected a boolean, but received: ${ge.webpackIgnore}.`,{start:{line:v,column:R},end:{line:$,column:L}}))}else if(ge.webpackIgnore){return L}}const xe=normalizeUrl(v.slice(P[0]+1,P[1]-1),true);if(xe.length===0)return L;const ve=q==="url"||q==="src";const Ce=new Je(xe,[P[0],P[1]],ve?"string":"url");const{line:Ne,column:He}=K.get(P[0]);const{line:Qe,column:Ve}=K.get(P[1]);Ce.setLoc(Ne,He,Qe,Ve);R.addDependency(Ce);R.addCodeGenerationDependency(Ce);return P[1]}default:{if(this.url&&ut.test(q)){Ze=L;const q=et.eatImageSetStrings(v,L,{comment:comment});if(q.length===0)return L;for(const[ge,be]of q.entries()){const xe=normalizeUrl(v.slice(be[0]+1,be[1]-1),true);if(xe.length===0)return L;const{options:ve,errors:Ce}=this.parseCommentOptions([ge===0?P:q[ge-1][1],be[1]]);if(Ce){for(const v of Ce){const{comment:P}=v;I.module.addWarning(new $(`Compilation error while processing magic comment(-s): /*${P.value}*/: ${v.message}`,P.loc))}}if(ve&&ve.webpackIgnore!==undefined){if(typeof ve.webpackIgnore!=="boolean"){const{line:v,column:P}=K.get(be[0]);const{line:R,column:$}=K.get(be[1]);I.module.addWarning(new ae(`\`webpackIgnore\` expected a boolean, but received: ${ve.webpackIgnore}.`,{start:{line:v,column:P},end:{line:R,column:$}}))}else if(ve.webpackIgnore){continue}}const Ne=new Je(xe,[be[0],be[1]],"url");const{line:He,column:Qe}=K.get(be[0]);const{line:Ve,column:Ke}=K.get(be[1]);Ne.setLoc(He,Qe,Ve,Ke);R.addDependency(Ne);R.addCodeGenerationDependency(Ne)}return L}else if(isLocalMode()){if(mt&&Xe.length===1){gt=undefined}if(q==="var"){const I=et.eatIdentSequence(v,L);if(!I)return L;let P=v.slice(I[0],I[1]);if(!P.startsWith("--")||P.length<3)return L;P=unescapeIdentifier(v.slice(I[0]+2,I[1]));const $=et.eatWhitespaceAndComments(v,I[1]);if(v.charCodeAt($)===ot||v.charCodeAt($)===it){const q=et.eatIdentSequence(v,$);if(!q||v.slice(q[0],q[1]).toLowerCase()!=="from"){return L}const ae=et.eatIdentSequenceOrString(v,et.eatWhitespaceAndComments(v,q[1]));if(!ae){return L}const ge=v.slice(ae[0],ae[1]);if(ae[2]===true&&ge==="global"){const v=new be("",[I[1],ae[1]]);R.addPresentationalDependency(v);return L}else if(ae[2]===false){const v=new ve(ge.slice(1,-1),P,[I[0],ae[1]-1]);const{line:$,column:L}=K.get(I[0]);const{line:q,column:be}=K.get(ae[1]-1);v.setLoc($,L,q,be);R.addDependency(v)}}else{const{line:v,column:$}=K.get(I[0]);const{line:q,column:ae}=K.get(I[1]);const ge=new Qe(P,[I[0],I[1]],"--",yt);ge.setLoc(v,$,q,ae);R.addDependency(ge);return L}}}}}return L},leftParenthesis:(v,I,P)=>{Xe.push(["(",I,P]);return P},rightParenthesis:(v,I,P)=>{const $=Xe.pop();if(L&&$&&($[0]===":local"||$[0]===":global")){lt=Xe[Xe.length-1]?Xe[Xe.length-1][0]:undefined;const v=new be("",[I,P]);R.addPresentationalDependency(v)}return P},comma:(v,I,P)=>{if(L){lt=undefined;if(ge===kt&&isLocalMode()){processDeclarationValueDone(v)}}Ze=I;return P}});R.buildInfo.strict=true;R.buildMeta.exportsType=this.namedExports?"namespace":"default";if(!this.namedExports){R.buildMeta.defaultObject="redirect"}R.addDependency(new Ve([],true));return I}getComments(v){if(!this.comments)return[];const[I,P]=v;const compare=(v,I)=>v.range[0]-I;const R=this.comments;let $=Ke.ge(R,I,compare);const L=[];while(R[$]&&R[$].range[1]<=P){L.push(R[$]);$++}return L}parseCommentOptions(v){const I=this.getComments(v);if(I.length===0){return bt}const P={};const $=[];for(const v of I){const{value:I}=v;if(I&&Xe.test(I)){try{for(let[v,$]of Object.entries(R.runInContext(`(function(){return {${I}};})()`,this.magicCommentContext))){if(typeof $==="object"&&$!==null){$=$.constructor.name==="RegExp"?new RegExp($):JSON.parse(JSON.stringify($))}P[v]=$}}catch(I){const P=new Error(String(I.message));P.stack=String(I.stack);Object.assign(P,{comment:v});$.push(P)}}}return{options:P,errors:$}}}v.exports=CssParser;v.exports.escapeIdentifier=escapeIdentifier;v.exports.unescapeIdentifier=unescapeIdentifier},66954:function(v){"use strict";const I="\n".charCodeAt(0);const P="\r".charCodeAt(0);const R="\f".charCodeAt(0);const $="\t".charCodeAt(0);const L=" ".charCodeAt(0);const q="/".charCodeAt(0);const K="\\".charCodeAt(0);const ae="*".charCodeAt(0);const ge="(".charCodeAt(0);const be=")".charCodeAt(0);const xe="{".charCodeAt(0);const ve="}".charCodeAt(0);const Ce="[".charCodeAt(0);const Ne="]".charCodeAt(0);const He='"'.charCodeAt(0);const Qe="'".charCodeAt(0);const Je=".".charCodeAt(0);const Ve=":".charCodeAt(0);const Ke=";".charCodeAt(0);const Ye=",".charCodeAt(0);const Xe="%".charCodeAt(0);const Ze="@".charCodeAt(0);const et="_".charCodeAt(0);const tt="a".charCodeAt(0);const nt="f".charCodeAt(0);const st="e".charCodeAt(0);const rt="u".charCodeAt(0);const ot="z".charCodeAt(0);const it="A".charCodeAt(0);const at="F".charCodeAt(0);const ct="E".charCodeAt(0);const lt="E".charCodeAt(0);const ut="Z".charCodeAt(0);const pt="0".charCodeAt(0);const dt="9".charCodeAt(0);const ft="#".charCodeAt(0);const ht="+".charCodeAt(0);const mt="-".charCodeAt(0);const gt="<".charCodeAt(0);const yt=">".charCodeAt(0);const consumeSpace=(v,I,P)=>{while(_isWhiteSpace(v.charCodeAt(I))){I++}return I};const _isNewline=v=>v===I||v===P||v===R;const consumeExtraNewline=(v,R,$)=>{if(v===P&&R.charCodeAt($)===I){$++}return $};const _isSpace=v=>v===$||v===L;const _isWhiteSpace=v=>_isNewline(v)||_isSpace(v);const isIdentStartCodePoint=v=>v>=tt&&v<=ot||v>=it&&v<=ut||v===et||v>=128;const consumeDelimToken=(v,I,P)=>I;const consumeComments=(v,I,P)=>{while(v.charCodeAt(I)===q&&v.charCodeAt(I+1)===ae){const R=I;I+=2;for(;;){if(I===v.length){return I}if(v.charCodeAt(I)===ae&&v.charCodeAt(I+1)===q){I+=2;if(P.comment){I=P.comment(v,R,I)}break}I++}}return I};const _isHexDigit=v=>_isDigit(v)||v>=it&&v<=at||v>=tt&&v<=nt;const _consumeAnEscapedCodePoint=(v,I)=>{const P=v.charCodeAt(I);I++;if(I===v.length){return I}if(_isHexDigit(P)){for(let P=0;P<5;P++){if(_isHexDigit(v.charCodeAt(I))){I++}}const P=v.charCodeAt(I);if(_isWhiteSpace(P)){I++;I=consumeExtraNewline(P,v,I)}return I}return I};const consumeAStringToken=(v,I,P)=>{const R=I-1;const $=v.charCodeAt(I-1);for(;;){if(I===v.length){if(P.string!==undefined){return P.string(v,R,I)}return I}const L=v.charCodeAt(I);I++;if(L===$){if(P.string!==undefined){return P.string(v,R,I)}return I}else if(_isNewline(L)){I--;return I}else if(L===K){if(I===v.length){return I}else if(_isNewline(v.charCodeAt(I))){const P=v.charCodeAt(I);I++;I=consumeExtraNewline(P,v,I)}else if(_ifTwoCodePointsAreValidEscape(v,I)){I=_consumeAnEscapedCodePoint(v,I)}}else{}}};const isNonASCIICodePoint=(v,I)=>v>128;const isLetter=v=>v>=tt&&v<=ot||v>=it&&v<=ut;const _isIdentStartCodePoint=(v,I)=>isLetter(v)||isNonASCIICodePoint(v,I)||v===et;const _isIdentCodePoint=(v,I)=>_isIdentStartCodePoint(v,I)||_isDigit(v)||v===mt;const _isDigit=v=>v>=pt&&v<=dt;const _ifTwoCodePointsAreValidEscape=(v,I,P,R)=>{const $=P||v.charCodeAt(I-1);const L=R||v.charCodeAt(I);if($!==K)return false;if(_isNewline(L))return false;return true};const _ifThreeCodePointsWouldStartAnIdentSequence=(v,I,P,R,$)=>{const L=P||v.charCodeAt(I-1);const q=R||v.charCodeAt(I);const ae=$||v.charCodeAt(I+1);if(L===mt){if(_isIdentStartCodePoint(q,I)||q===mt||_ifTwoCodePointsAreValidEscape(v,I,q,ae)){return true}return false}else if(_isIdentStartCodePoint(L,I-1)){return true}else if(L===K){if(_ifTwoCodePointsAreValidEscape(v,I,L,q)){return true}return false}return false};const _ifThreeCodePointsWouldStartANumber=(v,I,P,R,$)=>{const L=P||v.charCodeAt(I-1);const q=R||v.charCodeAt(I);const K=$||v.charCodeAt(I);if(L===ht||L===mt){if(_isDigit(q)){return true}else if(q===Je&&_isDigit(K)){return true}return false}else if(L===Je){if(_isDigit(q)){return true}return false}else if(_isDigit(L)){return true}return false};const consumeNumberSign=(v,I,P)=>{const R=I-1;const $=v.charCodeAt(I);const L=v.charCodeAt(I+1);if(_isIdentCodePoint($,I-1)||_ifTwoCodePointsAreValidEscape(v,I,$,L)){const q=v.charCodeAt(I+2);let K=false;if(_ifThreeCodePointsWouldStartAnIdentSequence(v,I,$,L,q)){K=true}I=_consumeAnIdentSequence(v,I,P);if(P.hash!==undefined){return P.hash(v,R,I,K)}return I}return I};const consumeHyphenMinus=(v,I,P)=>{if(_ifThreeCodePointsWouldStartANumber(v,I)){I--;return consumeANumericToken(v,I,P)}else if(v.charCodeAt(I)===mt&&v.charCodeAt(I+1)===yt){return I+2}else if(_ifThreeCodePointsWouldStartAnIdentSequence(v,I)){I--;return consumeAnIdentLikeToken(v,I,P)}return I};const consumeFullStop=(v,I,P)=>{const R=I-1;if(_ifThreeCodePointsWouldStartANumber(v,I)){I--;return consumeANumericToken(v,I,P)}if(P.delim!==undefined){return P.delim(v,R,I)}return I};const consumePlusSign=(v,I,P)=>{if(_ifThreeCodePointsWouldStartANumber(v,I)){I--;return consumeANumericToken(v,I,P)}return I};const _consumeANumber=(v,I)=>{if(v.charCodeAt(I)===mt||v.charCodeAt(I)===ht){I++}while(_isDigit(v.charCodeAt(I))){I++}if(v.charCodeAt(I)===Je&&_isDigit(v.charCodeAt(I+1))){I++;while(_isDigit(v.charCodeAt(I))){I++}}if((v.charCodeAt(I)===st||v.charCodeAt(I)===ct)&&((v.charCodeAt(I+1)===mt||v.charCodeAt(I+1)===ht)&&_isDigit(v.charCodeAt(I+2))||_isDigit(v.charCodeAt(I+1)))){I++;if(v.charCodeAt(I)===ht||v.charCodeAt(I)===mt){I++}while(_isDigit(v.charCodeAt(I))){I++}}return I};const consumeANumericToken=(v,I,P)=>{I=_consumeANumber(v,I,P);const R=v.charCodeAt(I);const $=v.charCodeAt(I+1);const L=v.charCodeAt(I+2);if(_ifThreeCodePointsWouldStartAnIdentSequence(v,I,R,$,L)){return _consumeAnIdentSequence(v,I,P)}else if(R===Xe){return I+1}return I};const consumeColon=(v,I,P)=>{if(P.colon!==undefined){return P.colon(v,I-1,I)}return I};const consumeLeftParenthesis=(v,I,P)=>{if(P.leftParenthesis!==undefined){return P.leftParenthesis(v,I-1,I)}return I};const consumeRightParenthesis=(v,I,P)=>{if(P.rightParenthesis!==undefined){return P.rightParenthesis(v,I-1,I)}return I};const consumeLeftSquareBracket=(v,I,P)=>I;const consumeRightSquareBracket=(v,I,P)=>I;const consumeLeftCurlyBracket=(v,I,P)=>{if(P.leftCurlyBracket!==undefined){return P.leftCurlyBracket(v,I-1,I)}return I};const consumeRightCurlyBracket=(v,I,P)=>{if(P.rightCurlyBracket!==undefined){return P.rightCurlyBracket(v,I-1,I)}return I};const consumeSemicolon=(v,I,P)=>{if(P.semicolon!==undefined){return P.semicolon(v,I-1,I)}return I};const consumeComma=(v,I,P)=>{if(P.comma!==undefined){return P.comma(v,I-1,I)}return I};const _consumeAnIdentSequence=(v,I)=>{for(;;){const P=v.charCodeAt(I);I++;if(_isIdentCodePoint(P,I-1)){}else if(_ifTwoCodePointsAreValidEscape(v,I)){I=_consumeAnEscapedCodePoint(v,I)}else{return I-1}}};const _isNonPrintableCodePoint=v=>v>=0&&v<=8||v===11||v>=14&&v<=31||v===127;const consumeTheRemnantsOfABadUrl=(v,I)=>{for(;;){if(I===v.length){return I}const P=v.charCodeAt(I);I++;if(P===be){return I}else if(_ifTwoCodePointsAreValidEscape(v,I)){I=_consumeAnEscapedCodePoint(v,I)}else{}}};const consumeAUrlToken=(v,I,P,R)=>{while(_isWhiteSpace(v.charCodeAt(I))){I++}const $=I;for(;;){if(I===v.length){if(R.url!==undefined){return R.url(v,P,I,$,I-1)}return I}const L=v.charCodeAt(I);I++;if(L===be){if(R.url!==undefined){return R.url(v,P,I,$,I-1)}return I}else if(_isWhiteSpace(L)){const L=I-1;while(_isWhiteSpace(v.charCodeAt(I))){I++}if(I===v.length){if(R.url!==undefined){return R.url(v,P,I,$,L)}return I}if(v.charCodeAt(I)===be){I++;if(R.url!==undefined){return R.url(v,P,I,$,L)}return I}return consumeTheRemnantsOfABadUrl(v,I)}else if(L===He||L===Qe||L===ge||_isNonPrintableCodePoint(L)){return consumeTheRemnantsOfABadUrl(v,I)}else if(L===K){if(_ifTwoCodePointsAreValidEscape(v,I)){I=_consumeAnEscapedCodePoint(v,I)}else{return consumeTheRemnantsOfABadUrl(v,I)}}else{}}};const consumeAnIdentLikeToken=(v,I,P)=>{const R=I;I=_consumeAnIdentSequence(v,I,P);if(v.slice(R,I).toLowerCase()==="url"&&v.charCodeAt(I)===ge){I++;const $=I;while(_isWhiteSpace(v.charCodeAt(I))&&_isWhiteSpace(v.charCodeAt(I+1))){I++}if(v.charCodeAt(I)===He||v.charCodeAt(I)===Qe||_isWhiteSpace(v.charCodeAt(I))&&(v.charCodeAt(I+1)===He||v.charCodeAt(I+1)===Qe)){if(P.function!==undefined){return P.function(v,R,$)}return I}return consumeAUrlToken(v,I,R,P)}if(v.charCodeAt(I)===ge){I++;if(P.function!==undefined){return P.function(v,R,I)}return I}if(P.identifier!==undefined){return P.identifier(v,R,I)}return I};const consumeLessThan=(v,I,P)=>{if(v.slice(I,I+3)==="!--"){return I+3}return I};const consumeCommercialAt=(v,I,P)=>{const R=I-1;if(_ifThreeCodePointsWouldStartAnIdentSequence(v,I,v.charCodeAt(I),v.charCodeAt(I+1),v.charCodeAt(I+2))){I=_consumeAnIdentSequence(v,I,P);if(P.atKeyword!==undefined){I=P.atKeyword(v,R,I)}return I}return I};const consumeReverseSolidus=(v,I,P)=>{if(_ifTwoCodePointsAreValidEscape(v,I)){I--;return consumeAnIdentLikeToken(v,I,P)}return I};const consumeAToken=(v,q,ae)=>{const Xe=v.charCodeAt(q-1);switch(Xe){case I:case P:case R:case $:case L:return consumeSpace(v,q,ae);case He:return consumeAStringToken(v,q,ae);case ft:return consumeNumberSign(v,q,ae);case Qe:return consumeAStringToken(v,q,ae);case ge:return consumeLeftParenthesis(v,q,ae);case be:return consumeRightParenthesis(v,q,ae);case ht:return consumePlusSign(v,q,ae);case Ye:return consumeComma(v,q,ae);case mt:return consumeHyphenMinus(v,q,ae);case Je:return consumeFullStop(v,q,ae);case Ve:return consumeColon(v,q,ae);case Ke:return consumeSemicolon(v,q,ae);case gt:return consumeLessThan(v,q,ae);case Ze:return consumeCommercialAt(v,q,ae);case Ce:return consumeLeftSquareBracket(v,q,ae);case K:return consumeReverseSolidus(v,q,ae);case Ne:return consumeRightSquareBracket(v,q,ae);case xe:return consumeLeftCurlyBracket(v,q,ae);case ve:return consumeRightCurlyBracket(v,q,ae);default:if(_isDigit(Xe)){q--;return consumeANumericToken(v,q,ae)}else if(Xe===rt||Xe===lt){q--;return consumeAnIdentLikeToken(v,q,ae)}else if(isIdentStartCodePoint(Xe)){q--;return consumeAnIdentLikeToken(v,q,ae)}return consumeDelimToken(v,q,ae)}};v.exports=(v,I=0,P={})=>{while(I<v.length){I=consumeComments(v,I,P);I++;I=consumeAToken(v,I,P);if(P.needTerminate&&P.needTerminate()){break}}return I};v.exports.isIdentStartCodePoint=isIdentStartCodePoint;v.exports.eatComments=(v,I)=>{for(;;){const P=I;I=consumeComments(v,I,{});if(P===I){break}}return I};v.exports.eatWhitespace=(v,I)=>{while(_isWhiteSpace(v.charCodeAt(I))){I++}return I};v.exports.eatWhitespaceAndComments=(v,I)=>{for(;;){const P=I;I=consumeComments(v,I,{});while(_isWhiteSpace(v.charCodeAt(I))){I++}if(P===I){break}}return I};v.exports.eatComments=(v,I)=>{for(;;){const P=I;I=consumeComments(v,I,{});if(P===I){break}}return I};v.exports.eatWhiteLine=(v,I)=>{for(;;){const P=v.charCodeAt(I);if(_isSpace(P)){I++;continue}if(_isNewline(P))I++;I=consumeExtraNewline(P,v,I);break}return I};v.exports.skipCommentsAndEatIdentSequence=(I,P)=>{P=v.exports.eatComments(I,P);const R=P;if(_ifThreeCodePointsWouldStartAnIdentSequence(I,P,I.charCodeAt(P),I.charCodeAt(P+1),I.charCodeAt(P+2))){return[R,_consumeAnIdentSequence(I,P,{})]}return undefined};v.exports.eatString=(I,P)=>{P=v.exports.eatWhitespaceAndComments(I,P);const R=P;if(I.charCodeAt(P)===He||I.charCodeAt(P)===Qe){return[R,consumeAStringToken(I,P+1,{})]}return undefined};v.exports.eatImageSetStrings=(v,I,P)=>{const R=[];let $=true;let L=false;let q=1;const K={...P,string:(v,I,P)=>{if($&&q===1){R.push([I,P]);$=false}return P},comma:(v,I,P)=>{if(q===1){$=true}return P},leftParenthesis:(v,I,P)=>{q++;return P},function:(v,I,P)=>{q++;return P},rightParenthesis:(v,I,P)=>{q--;if(q===0){L=true}return P}};while(I<v.length){I=consumeComments(v,I,K);I++;I=consumeAToken(v,I,K);if(L){break}}return R};v.exports.eatImportTokens=(v,I,P)=>{const R=new Array(4);let $;let L=false;let q=0;const K={...P,url:(v,I,P,L,K)=>{if(R[0]===undefined&&q===0&&R[1]===undefined&&R[2]===undefined&&R[3]===undefined){R[0]=[I,P,L,K];$=undefined}return P},string:(v,I,P)=>{if(q===0&&R[0]===undefined&&R[1]===undefined&&R[2]===undefined&&R[3]===undefined){R[0]=[I,P,I+1,P-1];$=undefined}else if(R[0]!==undefined&&$===0){R[0][2]=I+1;R[0][3]=P-1}return P},leftParenthesis:(v,I,P)=>{q++;return P},rightParenthesis:(v,I,P)=>{q--;if(q===0&&$!==undefined){R[$][1]=P;$=undefined}return P},function:(v,I,P)=>{if(q===0){const L=v.slice(I,P-1).replace(/\\/g,"").toLowerCase();if(L==="url"&&R[0]===undefined&&R[1]===undefined&&R[2]===undefined&&R[3]===undefined){$=0;R[$]=[I,P+1,P+1,P+1]}else if(L==="layer"&&R[1]===undefined&&R[2]===undefined){$=1;R[$]=[I,P]}else if(L==="supports"&&R[2]===undefined){$=2;R[$]=[I,P]}else{$=undefined}}q++;return P},identifier:(v,I,P)=>{if(q===0&&R[1]===undefined&&R[2]===undefined){const L=v.slice(I,P).replace(/\\/g,"").toLowerCase();if(L==="layer"){R[1]=[I,P];$=undefined}}return P},semicolon:(v,I,P)=>{if(q===0){L=true;R[3]=[I,P]}return P}};while(I<v.length){I=consumeComments(v,I,K);I++;I=consumeAToken(v,I,K);if(L){break}}return R};v.exports.eatIdentSequence=(I,P)=>{P=v.exports.eatWhitespaceAndComments(I,P);const R=P;if(_ifThreeCodePointsWouldStartAnIdentSequence(I,P,I.charCodeAt(P),I.charCodeAt(P+1),I.charCodeAt(P+2))){return[R,_consumeAnIdentSequence(I,P,{})]}return undefined};v.exports.eatIdentSequenceOrString=(I,P)=>{P=v.exports.eatWhitespaceAndComments(I,P);const R=P;if(I.charCodeAt(P)===He||I.charCodeAt(P)===Qe){return[R,consumeAStringToken(I,P+1,{}),false]}else if(_ifThreeCodePointsWouldStartAnIdentSequence(I,P,I.charCodeAt(P),I.charCodeAt(P+1),I.charCodeAt(P+2))){return[R,_consumeAnIdentSequence(I,P,{}),true]}return undefined};v.exports.eatUntil=v=>{const I=Array.from({length:v.length},((I,P)=>v.charCodeAt(P)));const P=Array.from({length:I.reduce(((v,I)=>Math.max(v,I)),0)+1},(()=>false));for(const v of I){P[v]=true}return(v,I)=>{for(;;){const R=v.charCodeAt(I);if(R<P.length&&P[R]){return I}I++;if(I===v.length)return I}}}},49605:function(v,I,P){"use strict";const{Tracer:R}=P(86853);const{JAVASCRIPT_MODULE_TYPE_AUTO:$,JAVASCRIPT_MODULE_TYPE_DYNAMIC:L,JAVASCRIPT_MODULE_TYPE_ESM:q,WEBASSEMBLY_MODULE_TYPE_ASYNC:K,WEBASSEMBLY_MODULE_TYPE_SYNC:ae,JSON_MODULE_TYPE:ge}=P(6041);const be=P(86750);const{dirname:xe,mkdirpSync:ve}=P(80749);const Ce=be(P(65094),(()=>P(15330)),{name:"Profiling Plugin",baseDataPath:"options"});let Ne;try{Ne=P(31405)}catch(v){console.log("Unable to CPU profile in < node 8.0")}class Profiler{constructor(v){this.session=undefined;this.inspector=v;this._startTime=0}hasSession(){return this.session!==undefined}startProfiling(){if(this.inspector===undefined){return Promise.resolve()}try{this.session=new Ne.Session;this.session.connect()}catch(v){this.session=undefined;return Promise.resolve()}const v=process.hrtime();this._startTime=v[0]*1e6+Math.round(v[1]/1e3);return Promise.all([this.sendCommand("Profiler.setSamplingInterval",{interval:100}),this.sendCommand("Profiler.enable"),this.sendCommand("Profiler.start")])}sendCommand(v,I){if(this.hasSession()){return new Promise(((P,R)=>{this.session.post(v,I,((v,I)=>{if(v!==null){R(v)}else{P(I)}}))}))}return Promise.resolve()}destroy(){if(this.hasSession()){this.session.disconnect()}return Promise.resolve()}stopProfiling(){return this.sendCommand("Profiler.stop").then((({profile:v})=>{const I=process.hrtime();const P=I[0]*1e6+Math.round(I[1]/1e3);if(v.startTime<this._startTime||v.endTime>P){const I=v.endTime-v.startTime;const R=P-this._startTime;const $=Math.max(0,R-I);v.startTime=this._startTime+$/2;v.endTime=P-$/2}return{profile:v}}))}}const createTrace=(v,I)=>{const P=new R;const $=new Profiler(Ne);if(/\/|\\/.test(I)){const P=xe(v,I);ve(v,P)}const L=v.createWriteStream(I);let q=0;P.pipe(L);P.instantEvent({name:"TracingStartedInPage",id:++q,cat:["disabled-by-default-devtools.timeline"],args:{data:{sessionId:"-1",page:"0xfff",frames:[{frame:"0xfff",url:"webpack",name:""}]}}});P.instantEvent({name:"TracingStartedInBrowser",id:++q,cat:["disabled-by-default-devtools.timeline"],args:{data:{sessionId:"-1"}}});return{trace:P,counter:q,profiler:$,end:v=>{P.push("]");L.on("close",(()=>{v()}));P.push(null)}}};const He="ProfilingPlugin";class ProfilingPlugin{constructor(v={}){Ce(v);this.outputPath=v.outputPath||"events.json"}apply(v){const I=createTrace(v.intermediateFileSystem,this.outputPath);I.profiler.startProfiling();for(const P of Object.keys(v.hooks)){const R=v.hooks[P];if(R){R.intercept(makeInterceptorFor("Compiler",I)(P))}}for(const P of Object.keys(v.resolverFactory.hooks)){const R=v.resolverFactory.hooks[P];if(R){R.intercept(makeInterceptorFor("Resolver",I)(P))}}v.hooks.compilation.tap(He,((v,{normalModuleFactory:P,contextModuleFactory:R})=>{interceptAllHooksFor(v,I,"Compilation");interceptAllHooksFor(P,I,"Normal Module Factory");interceptAllHooksFor(R,I,"Context Module Factory");interceptAllParserHooks(P,I);interceptAllJavascriptModulesPluginHooks(v,I)}));v.hooks.done.tapAsync({name:He,stage:Infinity},((P,R)=>{if(v.watchMode)return R();I.profiler.stopProfiling().then((v=>{if(v===undefined){I.profiler.destroy();I.end(R);return}const P=v.profile.startTime;const $=v.profile.endTime;I.trace.completeEvent({name:"TaskQueueManager::ProcessTaskFromWorkQueue",id:++I.counter,cat:["toplevel"],ts:P,args:{src_file:"../../ipc/ipc_moji_bootstrap.cc",src_func:"Accept"}});I.trace.completeEvent({name:"EvaluateScript",id:++I.counter,cat:["devtools.timeline"],ts:P,dur:$-P,args:{data:{url:"webpack",lineNumber:1,columnNumber:1,frame:"0xFFF"}}});I.trace.instantEvent({name:"CpuProfile",id:++I.counter,cat:["disabled-by-default-devtools.timeline"],ts:$,args:{data:{cpuProfile:v.profile}}});I.profiler.destroy();I.end(R)}))}))}}const interceptAllHooksFor=(v,I,P)=>{if(Reflect.has(v,"hooks")){for(const R of Object.keys(v.hooks)){const $=v.hooks[R];if($&&!$._fakeHook){$.intercept(makeInterceptorFor(P,I)(R))}}}};const interceptAllParserHooks=(v,I)=>{const P=[$,L,q,ge,K,ae];for(const R of P){v.hooks.parser.for(R).tap(He,((v,P)=>{interceptAllHooksFor(v,I,"Parser")}))}};const interceptAllJavascriptModulesPluginHooks=(v,I)=>{interceptAllHooksFor({hooks:P(36926).getCompilationHooks(v)},I,"JavascriptModulesPlugin")};const makeInterceptorFor=(v,I)=>v=>({register:P=>{const{name:R,type:$,fn:L}=P;const q=R===He?L:makeNewProfiledTapFn(v,I,{name:R,type:$,fn:L});return{...P,fn:q}}});const makeNewProfiledTapFn=(v,I,{name:P,type:R,fn:$})=>{const L=["blink.user_timing"];switch(R){case"promise":return(...v)=>{const R=++I.counter;I.trace.begin({name:P,id:R,cat:L});const q=$(...v);return q.then((v=>{I.trace.end({name:P,id:R,cat:L});return v}))};case"async":return(...v)=>{const R=++I.counter;I.trace.begin({name:P,id:R,cat:L});const q=v.pop();$(...v,((...v)=>{I.trace.end({name:P,id:R,cat:L});q(...v)}))};case"sync":return(...v)=>{const R=++I.counter;if(P===He){return $(...v)}I.trace.begin({name:P,id:R,cat:L});let q;try{q=$(...v)}catch(v){I.trace.end({name:P,id:R,cat:L});throw v}I.trace.end({name:P,id:R,cat:L});return q};default:break}};v.exports=ProfilingPlugin;v.exports.Profiler=Profiler},65065:function(v,I,P){"use strict";const R=P(5205);const $=P(65317);const L=P(18941);const q={f:{definition:"var __WEBPACK_AMD_DEFINE_RESULT__;",content:`!(__WEBPACK_AMD_DEFINE_RESULT__ = (#).call(exports, ${R.require}, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))`,requests:[R.require,R.exports,R.module]},o:{definition:"",content:"!(module.exports = #)",requests:[R.module]},of:{definition:"var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;",content:`!(__WEBPACK_AMD_DEFINE_FACTORY__ = (#),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, ${R.require}, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))`,requests:[R.require,R.exports,R.module]},af:{definition:"var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;",content:`!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_RESULT__ = (#).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))`,requests:[R.exports,R.module]},ao:{definition:"",content:"!(#, module.exports = #)",requests:[R.module]},aof:{definition:"var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;",content:`!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_FACTORY__ = (#),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))`,requests:[R.exports,R.module]},lf:{definition:"var XXX, XXXmodule;",content:`!(XXXmodule = { id: YYY, exports: {}, loaded: false }, XXX = (#).call(XXXmodule.exports, ${R.require}, XXXmodule.exports, XXXmodule), XXXmodule.loaded = true, XXX === undefined && (XXX = XXXmodule.exports))`,requests:[R.require,R.module]},lo:{definition:"var XXX;",content:"!(XXX = #)",requests:[]},lof:{definition:"var XXX, XXXfactory, XXXmodule;",content:`!(XXXfactory = (#), (typeof XXXfactory === 'function' ? ((XXXmodule = { id: YYY, exports: {}, loaded: false }), (XXX = XXXfactory.call(XXXmodule.exports, ${R.require}, XXXmodule.exports, XXXmodule)), (XXXmodule.loaded = true), XXX === undefined && (XXX = XXXmodule.exports)) : XXX = XXXfactory))`,requests:[R.require,R.module]},laf:{definition:"var __WEBPACK_AMD_DEFINE_ARRAY__, XXX, XXXexports;",content:"!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, XXX = (#).apply(XXXexports = {}, __WEBPACK_AMD_DEFINE_ARRAY__), XXX === undefined && (XXX = XXXexports))",requests:[]},lao:{definition:"var XXX;",content:"!(#, XXX = #)",requests:[]},laof:{definition:"var XXXarray, XXXfactory, XXXexports, XXX;",content:`!(XXXarray = #, XXXfactory = (#),\n\t\t(typeof XXXfactory === 'function' ?\n\t\t\t((XXX = XXXfactory.apply(XXXexports = {}, XXXarray)), XXX === undefined && (XXX = XXXexports)) :\n\t\t\t(XXX = XXXfactory)\n\t\t))`,requests:[]}};class AMDDefineDependency extends L{constructor(v,I,P,R,$){super();this.range=v;this.arrayRange=I;this.functionRange=P;this.objectRange=R;this.namedModule=$;this.localModule=null}get type(){return"amd define"}serialize(v){const{write:I}=v;I(this.range);I(this.arrayRange);I(this.functionRange);I(this.objectRange);I(this.namedModule);I(this.localModule);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();this.arrayRange=I();this.functionRange=I();this.objectRange=I();this.namedModule=I();this.localModule=I();super.deserialize(v)}}$(AMDDefineDependency,"webpack/lib/dependencies/AMDDefineDependency");AMDDefineDependency.Template=class AMDDefineDependencyTemplate extends L.Template{apply(v,I,{runtimeRequirements:P}){const R=v;const $=this.branch(R);const{definition:L,content:K,requests:ae}=q[$];for(const v of ae){P.add(v)}this.replace(R,I,L,K)}localModuleVar(v){return v.localModule&&v.localModule.used&&v.localModule.variableName()}branch(v){const I=this.localModuleVar(v)?"l":"";const P=v.arrayRange?"a":"";const R=v.objectRange?"o":"";const $=v.functionRange?"f":"";return I+P+R+$}replace(v,I,P,R){const $=this.localModuleVar(v);if($){R=R.replace(/XXX/g,$.replace(/\$/g,"$$$$"));P=P.replace(/XXX/g,$.replace(/\$/g,"$$$$"))}if(v.namedModule){R=R.replace(/YYY/g,JSON.stringify(v.namedModule))}const L=R.split("#");if(P)I.insert(0,P);let q=v.range[0];if(v.arrayRange){I.replace(q,v.arrayRange[0]-1,L.shift());q=v.arrayRange[1]}if(v.objectRange){I.replace(q,v.objectRange[0]-1,L.shift());q=v.objectRange[1]}else if(v.functionRange){I.replace(q,v.functionRange[0]-1,L.shift());q=v.functionRange[1]}I.replace(q,v.range[1]-1,L.shift());if(L.length>0)throw new Error("Implementation error")}};v.exports=AMDDefineDependency},41101:function(v,I,P){"use strict";const R=P(5205);const $=P(65065);const L=P(66423);const q=P(96272);const K=P(79718);const ae=P(34022);const ge=P(47712);const be=P(57342);const xe=P(61219);const{addLocalModule:ve,getLocalModule:Ce}=P(71356);const isBoundFunctionExpression=v=>{if(v.type!=="CallExpression")return false;if(v.callee.type!=="MemberExpression")return false;if(v.callee.computed)return false;if(v.callee.object.type!=="FunctionExpression")return false;if(v.callee.property.type!=="Identifier")return false;if(v.callee.property.name!=="bind")return false;return true};const isUnboundFunctionExpression=v=>{if(v.type==="FunctionExpression")return true;if(v.type==="ArrowFunctionExpression")return true;return false};const isCallable=v=>{if(isUnboundFunctionExpression(v))return true;if(isBoundFunctionExpression(v))return true;return false};class AMDDefineDependencyParserPlugin{constructor(v){this.options=v}apply(v){v.hooks.call.for("define").tap("AMDDefineDependencyParserPlugin",this.processCallDefine.bind(this,v))}processArray(v,I,P,$,L){if(P.isArray()){const R=P.items;for(const[P,q]of R.entries()){if(q.isString()&&["require","module","exports"].includes(q.string))$[P]=q.string;const R=this.processItem(v,I,q,L);if(R===undefined){this.processContext(v,I,q)}}return true}else if(P.isConstArray()){const L=[];const q=P.array;for(const[P,K]of q.entries()){let q;let ae;if(K==="require"){$[P]=K;q=R.require}else if(["exports","module"].includes(K)){$[P]=K;q=K}else if(ae=Ce(v.state,K)){ae.flagUsed();q=new xe(ae,undefined,false);q.loc=I.loc;v.state.module.addPresentationalDependency(q)}else{q=this.newRequireItemDependency(K);q.loc=I.loc;q.optional=Boolean(v.scope.inTry);v.state.current.addDependency(q)}L.push(q)}const K=this.newRequireArrayDependency(L,P.range);K.loc=I.loc;K.optional=Boolean(v.scope.inTry);v.state.module.addPresentationalDependency(K);return true}}processItem(v,I,P,$){if(P.isConditional()){const R=P.options;for(const P of R){const R=this.processItem(v,I,P);if(R===undefined){this.processContext(v,I,P)}}return true}else if(P.isString()){let L;let q;if(P.string==="require"){L=new ae(R.require,P.range,[R.require])}else if(P.string==="exports"){L=new ae("exports",P.range,[R.exports])}else if(P.string==="module"){L=new ae("module",P.range,[R.module])}else if(q=Ce(v.state,P.string,$)){q.flagUsed();L=new xe(q,P.range,false)}else{L=this.newRequireItemDependency(P.string,P.range);L.optional=Boolean(v.scope.inTry);v.state.current.addDependency(L);return true}L.loc=I.loc;v.state.module.addPresentationalDependency(L);return true}}processContext(v,I,P){const R=ge.create(q,P.range,P,I,this.options,{category:"amd"},v);if(!R)return;R.loc=I.loc;R.optional=Boolean(v.scope.inTry);v.state.current.addDependency(R);return true}processCallDefine(v,I){let P;let R;let $;let L;switch(I.arguments.length){case 1:if(isCallable(I.arguments[0])){R=I.arguments[0]}else if(I.arguments[0].type==="ObjectExpression"){$=I.arguments[0]}else{$=R=I.arguments[0]}break;case 2:if(I.arguments[0].type==="Literal"){L=I.arguments[0].value;if(isCallable(I.arguments[1])){R=I.arguments[1]}else if(I.arguments[1].type==="ObjectExpression"){$=I.arguments[1]}else{$=R=I.arguments[1]}}else{P=I.arguments[0];if(isCallable(I.arguments[1])){R=I.arguments[1]}else if(I.arguments[1].type==="ObjectExpression"){$=I.arguments[1]}else{$=R=I.arguments[1]}}break;case 3:L=I.arguments[0].value;P=I.arguments[1];if(isCallable(I.arguments[2])){R=I.arguments[2]}else if(I.arguments[2].type==="ObjectExpression"){$=I.arguments[2]}else{$=R=I.arguments[2]}break;default:return}be.bailout(v.state);let q=null;let K=0;if(R){if(isUnboundFunctionExpression(R)){q=R.params}else if(isBoundFunctionExpression(R)){const v=R.callee.object;q=v.params;K=R.arguments.length-1;if(K<0){K=0}}}const ae=new Map;if(P){const R={};const $=v.evaluateExpression(P);const ge=this.processArray(v,I,$,R,L);if(!ge)return;if(q){q=q.slice(K).filter(((I,P)=>{if(R[P]){ae.set(I.name,v.getVariableInfo(R[P]));return false}return true}))}}else{const I=["require","exports","module"];if(q){q=q.slice(K).filter(((P,R)=>{if(I[R]){ae.set(P.name,v.getVariableInfo(I[R]));return false}return true}))}}let ge;if(R&&isUnboundFunctionExpression(R)){ge=v.scope.inTry;v.inScope(q,(()=>{for(const[I,P]of ae){v.setVariable(I,P)}v.scope.inTry=ge;if(R.body.type==="BlockStatement"){v.detectMode(R.body.body);const I=v.prevStatement;v.preWalkStatement(R.body);v.prevStatement=I;v.walkStatement(R.body)}else{v.walkExpression(R.body)}}))}else if(R&&isBoundFunctionExpression(R)){ge=v.scope.inTry;const I=R.callee.object;v.inScope(I.params.filter((v=>!["require","module","exports"].includes(v.name))),(()=>{for(const[I,P]of ae){v.setVariable(I,P)}v.scope.inTry=ge;if(I.body.type==="BlockStatement"){v.detectMode(I.body.body);const P=v.prevStatement;v.preWalkStatement(I.body);v.prevStatement=P;v.walkStatement(I.body)}else{v.walkExpression(I.body)}}));if(R.arguments){v.walkExpressions(R.arguments)}}else if(R||$){v.walkExpression(R||$)}const xe=this.newDefineDependency(I.range,P?P.range:null,R?R.range:null,$?$.range:null,L||null);xe.loc=I.loc;if(L){xe.localModule=ve(v.state,L)}v.state.module.addPresentationalDependency(xe);return true}newDefineDependency(v,I,P,R,L){return new $(v,I,P,R,L)}newRequireArrayDependency(v,I){return new L(v,I)}newRequireItemDependency(v,I){return new K(v,I)}}v.exports=AMDDefineDependencyParserPlugin},99947:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$}=P(6041);const L=P(5205);const{approve:q,evaluateToIdentifier:K,evaluateToString:ae,toConstantDependency:ge}=P(59932);const be=P(65065);const xe=P(41101);const ve=P(66423);const Ce=P(96272);const Ne=P(54526);const He=P(69519);const Qe=P(79718);const{AMDDefineRuntimeModule:Je,AMDOptionsRuntimeModule:Ve}=P(34852);const Ke=P(34022);const Ye=P(61219);const Xe=P(58793);const Ze="AMDPlugin";class AMDPlugin{constructor(v){this.amdOptions=v}apply(v){const I=this.amdOptions;v.hooks.compilation.tap(Ze,((v,{contextModuleFactory:P,normalModuleFactory:et})=>{v.dependencyTemplates.set(He,new He.Template);v.dependencyFactories.set(Qe,et);v.dependencyTemplates.set(Qe,new Qe.Template);v.dependencyTemplates.set(ve,new ve.Template);v.dependencyFactories.set(Ce,P);v.dependencyTemplates.set(Ce,new Ce.Template);v.dependencyTemplates.set(be,new be.Template);v.dependencyTemplates.set(Xe,new Xe.Template);v.dependencyTemplates.set(Ye,new Ye.Template);v.hooks.runtimeRequirementInModule.for(L.amdDefine).tap(Ze,((v,I)=>{I.add(L.require)}));v.hooks.runtimeRequirementInModule.for(L.amdOptions).tap(Ze,((v,I)=>{I.add(L.requireScope)}));v.hooks.runtimeRequirementInTree.for(L.amdDefine).tap(Ze,((I,P)=>{v.addRuntimeModule(I,new Je)}));v.hooks.runtimeRequirementInTree.for(L.amdOptions).tap(Ze,((P,R)=>{v.addRuntimeModule(P,new Ve(I))}));const handler=(v,I)=>{if(I.amd!==undefined&&!I.amd)return;const tapOptionsHooks=(I,P,R)=>{v.hooks.expression.for(I).tap(Ze,ge(v,L.amdOptions,[L.amdOptions]));v.hooks.evaluateIdentifier.for(I).tap(Ze,K(I,P,R,true));v.hooks.evaluateTypeof.for(I).tap(Ze,ae("object"));v.hooks.typeof.for(I).tap(Ze,ge(v,JSON.stringify("object")))};new Ne(I).apply(v);new xe(I).apply(v);tapOptionsHooks("define.amd","define",(()=>"amd"));tapOptionsHooks("require.amd","require",(()=>["amd"]));tapOptionsHooks("__webpack_amd_options__","__webpack_amd_options__",(()=>[]));v.hooks.expression.for("define").tap(Ze,(I=>{const P=new Ke(L.amdDefine,I.range,[L.amdDefine]);P.loc=I.loc;v.state.module.addPresentationalDependency(P);return true}));v.hooks.typeof.for("define").tap(Ze,ge(v,JSON.stringify("function")));v.hooks.evaluateTypeof.for("define").tap(Ze,ae("function"));v.hooks.canRename.for("define").tap(Ze,q);v.hooks.rename.for("define").tap(Ze,(I=>{const P=new Ke(L.amdDefine,I.range,[L.amdDefine]);P.loc=I.loc;v.state.module.addPresentationalDependency(P);return false}));v.hooks.typeof.for("require").tap(Ze,ge(v,JSON.stringify("function")));v.hooks.evaluateTypeof.for("require").tap(Ze,ae("function"))};et.hooks.parser.for(R).tap(Ze,handler);et.hooks.parser.for($).tap(Ze,handler)}))}}v.exports=AMDPlugin},66423:function(v,I,P){"use strict";const R=P(82034);const $=P(65317);const L=P(18941);class AMDRequireArrayDependency extends L{constructor(v,I){super();this.depsArray=v;this.range=I}get type(){return"amd require array"}get category(){return"amd"}serialize(v){const{write:I}=v;I(this.depsArray);I(this.range);super.serialize(v)}deserialize(v){const{read:I}=v;this.depsArray=I();this.range=I();super.deserialize(v)}}$(AMDRequireArrayDependency,"webpack/lib/dependencies/AMDRequireArrayDependency");AMDRequireArrayDependency.Template=class AMDRequireArrayDependencyTemplate extends R{apply(v,I,P){const R=v;const $=this.getContent(R,P);I.replace(R.range[0],R.range[1]-1,$)}getContent(v,I){const P=v.depsArray.map((v=>this.contentForDependency(v,I)));return`[${P.join(", ")}]`}contentForDependency(v,{runtimeTemplate:I,moduleGraph:P,chunkGraph:R,runtimeRequirements:$}){if(typeof v==="string"){return v}if(v.localModule){return v.localModule.variableName()}return I.moduleExports({module:P.getModule(v),chunkGraph:R,request:v.request,runtimeRequirements:$})}};v.exports=AMDRequireArrayDependency},96272:function(v,I,P){"use strict";const R=P(65317);const $=P(38768);class AMDRequireContextDependency extends ${constructor(v,I,P){super(v);this.range=I;this.valueRange=P}get type(){return"amd require context"}get category(){return"amd"}serialize(v){const{write:I}=v;I(this.range);I(this.valueRange);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();this.valueRange=I();super.deserialize(v)}}R(AMDRequireContextDependency,"webpack/lib/dependencies/AMDRequireContextDependency");AMDRequireContextDependency.Template=P(17694);v.exports=AMDRequireContextDependency},53864:function(v,I,P){"use strict";const R=P(67927);const $=P(65317);class AMDRequireDependenciesBlock extends R{constructor(v,I){super(null,v,I)}}$(AMDRequireDependenciesBlock,"webpack/lib/dependencies/AMDRequireDependenciesBlock");v.exports=AMDRequireDependenciesBlock},54526:function(v,I,P){"use strict";const R=P(5205);const $=P(53966);const L=P(66423);const q=P(96272);const K=P(53864);const ae=P(69519);const ge=P(79718);const be=P(34022);const xe=P(47712);const ve=P(61219);const{getLocalModule:Ce}=P(71356);const Ne=P(58793);const He=P(75363);class AMDRequireDependenciesBlockParserPlugin{constructor(v){this.options=v}processFunctionArgument(v,I){let P=true;const R=He(I);if(R){v.inScope(R.fn.params.filter((v=>!["require","module","exports"].includes(v.name))),(()=>{if(R.fn.body.type==="BlockStatement"){v.walkStatement(R.fn.body)}else{v.walkExpression(R.fn.body)}}));v.walkExpressions(R.expressions);if(R.needThis===false){P=false}}else{v.walkExpression(I)}return P}apply(v){v.hooks.call.for("require").tap("AMDRequireDependenciesBlockParserPlugin",this.processCallRequire.bind(this,v))}processArray(v,I,P){if(P.isArray()){for(const R of P.items){const P=this.processItem(v,I,R);if(P===undefined){this.processContext(v,I,R)}}return true}else if(P.isConstArray()){const $=[];for(const L of P.array){let P;let q;if(L==="require"){P=R.require}else if(["exports","module"].includes(L)){P=L}else if(q=Ce(v.state,L)){q.flagUsed();P=new ve(q,undefined,false);P.loc=I.loc;v.state.module.addPresentationalDependency(P)}else{P=this.newRequireItemDependency(L);P.loc=I.loc;P.optional=Boolean(v.scope.inTry);v.state.current.addDependency(P)}$.push(P)}const L=this.newRequireArrayDependency($,P.range);L.loc=I.loc;L.optional=Boolean(v.scope.inTry);v.state.module.addPresentationalDependency(L);return true}}processItem(v,I,P){if(P.isConditional()){for(const R of P.options){const P=this.processItem(v,I,R);if(P===undefined){this.processContext(v,I,R)}}return true}else if(P.isString()){let $;let L;if(P.string==="require"){$=new be(R.require,P.string,[R.require])}else if(P.string==="module"){$=new be(v.state.module.buildInfo.moduleArgument,P.range,[R.module])}else if(P.string==="exports"){$=new be(v.state.module.buildInfo.exportsArgument,P.range,[R.exports])}else if(L=Ce(v.state,P.string)){L.flagUsed();$=new ve(L,P.range,false)}else{$=this.newRequireItemDependency(P.string,P.range);$.loc=I.loc;$.optional=Boolean(v.scope.inTry);v.state.current.addDependency($);return true}$.loc=I.loc;v.state.module.addPresentationalDependency($);return true}}processContext(v,I,P){const R=xe.create(q,P.range,P,I,this.options,{category:"amd"},v);if(!R)return;R.loc=I.loc;R.optional=Boolean(v.scope.inTry);v.state.current.addDependency(R);return true}processArrayForRequestString(v){if(v.isArray()){const I=v.items.map((v=>this.processItemForRequestString(v)));if(I.every(Boolean))return I.join(" ")}else if(v.isConstArray()){return v.array.join(" ")}}processItemForRequestString(v){if(v.isConditional()){const I=v.options.map((v=>this.processItemForRequestString(v)));if(I.every(Boolean))return I.join("|")}else if(v.isString()){return v.string}}processCallRequire(v,I){let P;let R;let L;let q;const K=v.state.current;if(I.arguments.length>=1){P=v.evaluateExpression(I.arguments[0]);R=this.newRequireDependenciesBlock(I.loc,this.processArrayForRequestString(P));L=this.newRequireDependency(I.range,P.range,I.arguments.length>1?I.arguments[1].range:null,I.arguments.length>2?I.arguments[2].range:null);L.loc=I.loc;R.addDependency(L);v.state.current=R}if(I.arguments.length===1){v.inScope([],(()=>{q=this.processArray(v,I,P)}));v.state.current=K;if(!q)return;v.state.current.addBlock(R);return true}if(I.arguments.length===2||I.arguments.length===3){try{v.inScope([],(()=>{q=this.processArray(v,I,P)}));if(!q){const P=new Ne("unsupported",I.range);K.addPresentationalDependency(P);if(v.state.module){v.state.module.addError(new $(`Cannot statically analyse 'require(â€¦, â€¦)' in line ${I.loc.start.line}`,I.loc))}R=null;return true}L.functionBindThis=this.processFunctionArgument(v,I.arguments[1]);if(I.arguments.length===3){L.errorCallbackBindThis=this.processFunctionArgument(v,I.arguments[2])}}finally{v.state.current=K;if(R)v.state.current.addBlock(R)}return true}}newRequireDependenciesBlock(v,I){return new K(v,I)}newRequireDependency(v,I,P,R){return new ae(v,I,P,R)}newRequireItemDependency(v,I){return new ge(v,I)}newRequireArrayDependency(v,I){return new L(v,I)}}v.exports=AMDRequireDependenciesBlockParserPlugin},69519:function(v,I,P){"use strict";const R=P(5205);const $=P(65317);const L=P(18941);class AMDRequireDependency extends L{constructor(v,I,P,R){super();this.outerRange=v;this.arrayRange=I;this.functionRange=P;this.errorCallbackRange=R;this.functionBindThis=false;this.errorCallbackBindThis=false}get category(){return"amd"}serialize(v){const{write:I}=v;I(this.outerRange);I(this.arrayRange);I(this.functionRange);I(this.errorCallbackRange);I(this.functionBindThis);I(this.errorCallbackBindThis);super.serialize(v)}deserialize(v){const{read:I}=v;this.outerRange=I();this.arrayRange=I();this.functionRange=I();this.errorCallbackRange=I();this.functionBindThis=I();this.errorCallbackBindThis=I();super.deserialize(v)}}$(AMDRequireDependency,"webpack/lib/dependencies/AMDRequireDependency");AMDRequireDependency.Template=class AMDRequireDependencyTemplate extends L.Template{apply(v,I,{runtimeTemplate:P,moduleGraph:$,chunkGraph:L,runtimeRequirements:q}){const K=v;const ae=$.getParentBlock(K);const ge=P.blockPromise({chunkGraph:L,block:ae,message:"AMD require",runtimeRequirements:q});if(K.arrayRange&&!K.functionRange){const v=`${ge}.then(function() {`;const P=`;})['catch'](${R.uncaughtErrorHandler})`;q.add(R.uncaughtErrorHandler);I.replace(K.outerRange[0],K.arrayRange[0]-1,v);I.replace(K.arrayRange[1],K.outerRange[1]-1,P);return}if(K.functionRange&&!K.arrayRange){const v=`${ge}.then((`;const P=`).bind(exports, ${R.require}, exports, module))['catch'](${R.uncaughtErrorHandler})`;q.add(R.uncaughtErrorHandler);I.replace(K.outerRange[0],K.functionRange[0]-1,v);I.replace(K.functionRange[1],K.outerRange[1]-1,P);return}if(K.arrayRange&&K.functionRange&&K.errorCallbackRange){const v=`${ge}.then(function() { `;const P=`}${K.functionBindThis?".bind(this)":""})['catch'](`;const R=`${K.errorCallbackBindThis?".bind(this)":""})`;I.replace(K.outerRange[0],K.arrayRange[0]-1,v);I.insert(K.arrayRange[0],"var __WEBPACK_AMD_REQUIRE_ARRAY__ = ");I.replace(K.arrayRange[1],K.functionRange[0]-1,"; (");I.insert(K.functionRange[1],").apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);");I.replace(K.functionRange[1],K.errorCallbackRange[0]-1,P);I.replace(K.errorCallbackRange[1],K.outerRange[1]-1,R);return}if(K.arrayRange&&K.functionRange){const v=`${ge}.then(function() { `;const P=`}${K.functionBindThis?".bind(this)":""})['catch'](${R.uncaughtErrorHandler})`;q.add(R.uncaughtErrorHandler);I.replace(K.outerRange[0],K.arrayRange[0]-1,v);I.insert(K.arrayRange[0],"var __WEBPACK_AMD_REQUIRE_ARRAY__ = ");I.replace(K.arrayRange[1],K.functionRange[0]-1,"; (");I.insert(K.functionRange[1],").apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);");I.replace(K.functionRange[1],K.outerRange[1]-1,P)}}};v.exports=AMDRequireDependency},79718:function(v,I,P){"use strict";const R=P(65317);const $=P(39460);const L=P(87264);class AMDRequireItemDependency extends ${constructor(v,I){super(v);this.range=I}get type(){return"amd require"}get category(){return"amd"}}R(AMDRequireItemDependency,"webpack/lib/dependencies/AMDRequireItemDependency");AMDRequireItemDependency.Template=L;v.exports=AMDRequireItemDependency},34852:function(v,I,P){"use strict";const R=P(5205);const $=P(78994);const L=P(57227);class AMDDefineRuntimeModule extends ${constructor(){super("amd define")}generate(){return L.asString([`${R.amdDefine} = function () {`,L.indent("throw new Error('define cannot be used indirect');"),"};"])}}class AMDOptionsRuntimeModule extends ${constructor(v){super("amd options");this.options=v}generate(){return L.asString([`${R.amdOptions} = ${JSON.stringify(this.options)};`])}}v.exports.AMDDefineRuntimeModule=AMDDefineRuntimeModule;v.exports.AMDOptionsRuntimeModule=AMDOptionsRuntimeModule},45871:function(v,I,P){"use strict";const R=P(82034);const $=P(89959);const L=P(65317);const q=P(18941);class CachedConstDependency extends q{constructor(v,I,P){super();this.expression=v;this.range=I;this.identifier=P;this._hashUpdate=undefined}_createHashUpdate(){return`${this.identifier}${this.range}${this.expression}`}updateHash(v,I){if(this._hashUpdate===undefined){this._hashUpdate=this._createHashUpdate()}v.update(this._hashUpdate)}serialize(v){const{write:I}=v;I(this.expression);I(this.range);I(this.identifier);super.serialize(v)}deserialize(v){const{read:I}=v;this.expression=I();this.range=I();this.identifier=I();super.deserialize(v)}}L(CachedConstDependency,"webpack/lib/dependencies/CachedConstDependency");CachedConstDependency.Template=class CachedConstDependencyTemplate extends R{apply(v,I,{runtimeTemplate:P,dependencyTemplates:R,initFragments:L}){const q=v;L.push(new $(`var ${q.identifier} = ${q.expression};\n`,$.STAGE_CONSTANTS,0,`const ${q.identifier}`));if(typeof q.range==="number"){I.insert(q.range,q.identifier);return}I.replace(q.range[0],q.range[1]-1,q.identifier)}};v.exports=CachedConstDependency},52285:function(v,I,P){"use strict";const R=P(5205);v.exports.handleDependencyBase=(v,I,P)=>{let $;let L;switch(v){case"exports":P.add(R.exports);$=I.exportsArgument;L="expression";break;case"module.exports":P.add(R.module);$=`${I.moduleArgument}.exports`;L="expression";break;case"this":P.add(R.thisAsExports);$="this";L="expression";break;case"Object.defineProperty(exports)":P.add(R.exports);$=I.exportsArgument;L="Object.defineProperty";break;case"Object.defineProperty(module.exports)":P.add(R.module);$=`${I.moduleArgument}.exports`;L="Object.defineProperty";break;case"Object.defineProperty(this)":P.add(R.thisAsExports);$="this";L="Object.defineProperty";break;default:throw new Error(`Unsupported base ${v}`)}return[L,$]}},4207:function(v,I,P){"use strict";const R=P(49790);const{UsageState:$}=P(21311);const L=P(57227);const{equals:q}=P(29179);const K=P(65317);const ae=P(30158);const{handleDependencyBase:ge}=P(52285);const be=P(39460);const xe=P(8655);const ve=Symbol("CommonJsExportRequireDependency.ids");const Ce={};class CommonJsExportRequireDependency extends be{constructor(v,I,P,R,$,L,q){super($);this.range=v;this.valueRange=I;this.base=P;this.names=R;this.ids=L;this.resultUsed=q;this.asiSafe=undefined}get type(){return"cjs export require"}couldAffectReferencingModule(){return R.TRANSITIVE}getIds(v){return v.getMeta(this)[ve]||this.ids}setIds(v,I){v.getMeta(this)[ve]=I}getReferencedExports(v,I){const P=this.getIds(v);const getFullResult=()=>{if(P.length===0){return R.EXPORTS_OBJECT_REFERENCED}return[{name:P,canMangle:false}]};if(this.resultUsed)return getFullResult();let L=v.getExportsInfo(v.getParentModule(this));for(const v of this.names){const P=L.getReadOnlyExportInfo(v);const q=P.getUsed(I);if(q===$.Unused)return R.NO_EXPORTS_REFERENCED;if(q!==$.OnlyPropertiesUsed)return getFullResult();L=P.exportsInfo;if(!L)return getFullResult()}if(L.otherExportsInfo.getUsed(I)!==$.Unused){return getFullResult()}const q=[];for(const v of L.orderedExports){xe(I,q,P.concat(v.name),v,false)}return q.map((v=>({name:v,canMangle:false})))}getExports(v){if(this.names.length===1){const I=this.getIds(v);const P=this.names[0];const R=v.getConnection(this);if(!R)return;return{exports:[{name:P,from:R,export:I.length===0?null:I,canMangle:!(P in Ce)&&false}],dependencies:[R.module]}}else if(this.names.length>0){const v=this.names[0];return{exports:[{name:v,canMangle:!(v in Ce)&&false}],dependencies:undefined}}const I=v.getConnection(this);if(!I)return;const P=this.getStarReexports(v,undefined,I.module);const R=this.getIds(v);if(P){return{exports:Array.from(P.exports,(v=>({name:v,from:I,export:R.concat(v),canMangle:!(v in Ce)&&false}))),dependencies:[I.module]}}return{exports:true,from:R.length===0?I:undefined,canMangle:false,dependencies:[I.module]}}getStarReexports(v,I,P=v.getModule(this)){let R=v.getExportsInfo(P);const L=this.getIds(v);if(L.length>0)R=R.getNestedExportsInfo(L);let q=v.getExportsInfo(v.getParentModule(this));if(this.names.length>0)q=q.getNestedExportsInfo(this.names);const K=R&&R.otherExportsInfo.provided===false;const ae=q&&q.otherExportsInfo.getUsed(I)===$.Unused;if(!K&&!ae){return}const ge=P.getExportsType(v,false)==="namespace";const be=new Set;const xe=new Set;if(ae){for(const v of q.orderedExports){const P=v.name;if(v.getUsed(I)===$.Unused)continue;if(P==="__esModule"&&ge){be.add(P)}else if(R){const v=R.getReadOnlyExportInfo(P);if(v.provided===false)continue;be.add(P);if(v.provided===true)continue;xe.add(P)}else{be.add(P);xe.add(P)}}}else if(K){for(const v of R.orderedExports){const P=v.name;if(v.provided===false)continue;if(q){const v=q.getReadOnlyExportInfo(P);if(v.getUsed(I)===$.Unused)continue}be.add(P);if(v.provided===true)continue;xe.add(P)}if(ge){be.add("__esModule");xe.delete("__esModule")}}return{exports:be,checked:xe}}serialize(v){const{write:I}=v;I(this.asiSafe);I(this.range);I(this.valueRange);I(this.base);I(this.names);I(this.ids);I(this.resultUsed);super.serialize(v)}deserialize(v){const{read:I}=v;this.asiSafe=I();this.range=I();this.valueRange=I();this.base=I();this.names=I();this.ids=I();this.resultUsed=I();super.deserialize(v)}}K(CommonJsExportRequireDependency,"webpack/lib/dependencies/CommonJsExportRequireDependency");CommonJsExportRequireDependency.Template=class CommonJsExportRequireDependencyTemplate extends be.Template{apply(v,I,{module:P,runtimeTemplate:R,chunkGraph:$,moduleGraph:K,runtimeRequirements:be,runtime:xe}){const ve=v;const Ce=K.getExportsInfo(P).getUsedName(ve.names,xe);const[Ne,He]=ge(ve.base,P,be);const Qe=K.getModule(ve);let Je=R.moduleExports({module:Qe,chunkGraph:$,request:ve.request,weak:ve.weak,runtimeRequirements:be});if(Qe){const v=ve.getIds(K);const I=K.getExportsInfo(Qe).getUsedName(v,xe);if(I){const P=q(I,v)?"":`${L.toNormalComment(ae(v))} `;Je+=`${P}${ae(I)}`}}switch(Ne){case"expression":I.replace(ve.range[0],ve.range[1]-1,Ce?`${He}${ae(Ce)} = ${Je}`:`/* unused reexport */ ${Je}`);return;case"Object.defineProperty":throw new Error("TODO");default:throw new Error("Unexpected type")}}};v.exports=CommonJsExportRequireDependency},57633:function(v,I,P){"use strict";const R=P(89959);const $=P(65317);const L=P(30158);const{handleDependencyBase:q}=P(52285);const K=P(18941);const ae={};class CommonJsExportsDependency extends K{constructor(v,I,P,R){super();this.range=v;this.valueRange=I;this.base=P;this.names=R}get type(){return"cjs exports"}getExports(v){const I=this.names[0];return{exports:[{name:I,canMangle:!(I in ae)}],dependencies:undefined}}serialize(v){const{write:I}=v;I(this.range);I(this.valueRange);I(this.base);I(this.names);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();this.valueRange=I();this.base=I();this.names=I();super.deserialize(v)}}$(CommonJsExportsDependency,"webpack/lib/dependencies/CommonJsExportsDependency");CommonJsExportsDependency.Template=class CommonJsExportsDependencyTemplate extends K.Template{apply(v,I,{module:P,moduleGraph:$,initFragments:K,runtimeRequirements:ae,runtime:ge}){const be=v;const xe=$.getExportsInfo(P).getUsedName(be.names,ge);const[ve,Ce]=q(be.base,P,ae);switch(ve){case"expression":if(!xe){K.push(new R("var __webpack_unused_export__;\n",R.STAGE_CONSTANTS,0,"__webpack_unused_export__"));I.replace(be.range[0],be.range[1]-1,"__webpack_unused_export__");return}I.replace(be.range[0],be.range[1]-1,`${Ce}${L(xe)}`);return;case"Object.defineProperty":if(!xe){K.push(new R("var __webpack_unused_export__;\n",R.STAGE_CONSTANTS,0,"__webpack_unused_export__"));I.replace(be.range[0],be.valueRange[0]-1,"__webpack_unused_export__ = (");I.replace(be.valueRange[1],be.range[1]-1,")");return}I.replace(be.range[0],be.valueRange[0]-1,`Object.defineProperty(${Ce}${L(xe.slice(0,-1))}, ${JSON.stringify(xe[xe.length-1])}, (`);I.replace(be.valueRange[1],be.range[1]-1,"))")}}};v.exports=CommonJsExportsDependency},91094:function(v,I,P){"use strict";const R=P(5205);const $=P(28408);const{evaluateToString:L}=P(59932);const q=P(30158);const K=P(4207);const ae=P(57633);const ge=P(80239);const be=P(57342);const xe=P(74618);const ve=P(27420);const getValueOfPropertyDescription=v=>{if(v.type!=="ObjectExpression")return;for(const I of v.properties){if(I.computed)continue;const v=I.key;if(v.type!=="Identifier"||v.name!=="value")continue;return I.value}};const isTruthyLiteral=v=>{switch(v.type){case"Literal":return Boolean(v.value);case"UnaryExpression":if(v.operator==="!")return isFalsyLiteral(v.argument)}return false};const isFalsyLiteral=v=>{switch(v.type){case"Literal":return!v.value;case"UnaryExpression":if(v.operator==="!")return isTruthyLiteral(v.argument)}return false};const parseRequireCall=(v,I)=>{const P=[];while(I.type==="MemberExpression"){if(I.object.type==="Super")return;if(!I.property)return;const v=I.property;if(I.computed){if(v.type!=="Literal")return;P.push(`${v.value}`)}else{if(v.type!=="Identifier")return;P.push(v.name)}I=I.object}if(I.type!=="CallExpression"||I.arguments.length!==1)return;const R=I.callee;if(R.type!=="Identifier"||v.getVariableInfo(R.name)!=="require"){return}const $=I.arguments[0];if($.type==="SpreadElement")return;const L=v.evaluateExpression($);return{argument:L,ids:P.reverse()}};class CommonJsExportsParserPlugin{constructor(v){this.moduleGraph=v}apply(v){const enableStructuredExports=()=>{be.enable(v.state)};const checkNamespace=(I,P,R)=>{if(!be.isEnabled(v.state))return;if(P.length>0&&P[0]==="__esModule"){if(R&&isTruthyLiteral(R)&&I){be.setFlagged(v.state)}else{be.setDynamic(v.state)}}};const bailout=I=>{be.bailout(v.state);if(I)bailoutHint(I)};const bailoutHint=I=>{this.moduleGraph.getOptimizationBailout(v.state.module).push(`CommonJS bailout: ${I}`)};v.hooks.evaluateTypeof.for("module").tap("CommonJsExportsParserPlugin",L("object"));v.hooks.evaluateTypeof.for("exports").tap("CommonJsPlugin",L("object"));const handleAssignExport=(I,P,R)=>{if(xe.isEnabled(v.state))return;const $=parseRequireCall(v,I.right);if($&&$.argument.isString()&&(R.length===0||R[0]!=="__esModule")){enableStructuredExports();if(R.length===0)be.setDynamic(v.state);const L=new K(I.range,null,P,R,$.argument.string,$.ids,!v.isStatementLevelExpression(I));L.loc=I.loc;L.optional=Boolean(v.scope.inTry);v.state.module.addDependency(L);return true}if(R.length===0)return;enableStructuredExports();const L=R;checkNamespace(v.statementPath.length===1&&v.isStatementLevelExpression(I),L,I.right);const q=new ae(I.left.range,null,P,L);q.loc=I.loc;v.state.module.addDependency(q);v.walkExpression(I.right);return true};v.hooks.assignMemberChain.for("exports").tap("CommonJsExportsParserPlugin",((v,I)=>handleAssignExport(v,"exports",I)));v.hooks.assignMemberChain.for("this").tap("CommonJsExportsParserPlugin",((I,P)=>{if(!v.scope.topLevelScope)return;return handleAssignExport(I,"this",P)}));v.hooks.assignMemberChain.for("module").tap("CommonJsExportsParserPlugin",((v,I)=>{if(I[0]!=="exports")return;return handleAssignExport(v,"module.exports",I.slice(1))}));v.hooks.call.for("Object.defineProperty").tap("CommonJsExportsParserPlugin",(I=>{const P=I;if(!v.isStatementLevelExpression(P))return;if(P.arguments.length!==3)return;if(P.arguments[0].type==="SpreadElement")return;if(P.arguments[1].type==="SpreadElement")return;if(P.arguments[2].type==="SpreadElement")return;const R=v.evaluateExpression(P.arguments[0]);if(!R.isIdentifier())return;if(R.identifier!=="exports"&&R.identifier!=="module.exports"&&(R.identifier!=="this"||!v.scope.topLevelScope)){return}const $=v.evaluateExpression(P.arguments[1]);const L=$.asString();if(typeof L!=="string")return;enableStructuredExports();const q=P.arguments[2];checkNamespace(v.statementPath.length===1,[L],getValueOfPropertyDescription(q));const K=new ae(P.range,P.arguments[2].range,`Object.defineProperty(${R.identifier})`,[L]);K.loc=P.loc;v.state.module.addDependency(K);v.walkExpression(P.arguments[2]);return true}));const handleAccessExport=(I,P,R,L)=>{if(xe.isEnabled(v.state))return;if(R.length===0){bailout(`${P} is used directly at ${$(I.loc)}`)}if(L&&R.length===1){bailoutHint(`${P}${q(R)}(...) prevents optimization as ${P} is passed as call context at ${$(I.loc)}`)}const K=new ge(I.range,P,R,Boolean(L));K.loc=I.loc;v.state.module.addDependency(K);if(L){v.walkExpressions(L.arguments)}return true};v.hooks.callMemberChain.for("exports").tap("CommonJsExportsParserPlugin",((v,I)=>handleAccessExport(v.callee,"exports",I,v)));v.hooks.expressionMemberChain.for("exports").tap("CommonJsExportsParserPlugin",((v,I)=>handleAccessExport(v,"exports",I)));v.hooks.expression.for("exports").tap("CommonJsExportsParserPlugin",(v=>handleAccessExport(v,"exports",[])));v.hooks.callMemberChain.for("module").tap("CommonJsExportsParserPlugin",((v,I)=>{if(I[0]!=="exports")return;return handleAccessExport(v.callee,"module.exports",I.slice(1),v)}));v.hooks.expressionMemberChain.for("module").tap("CommonJsExportsParserPlugin",((v,I)=>{if(I[0]!=="exports")return;return handleAccessExport(v,"module.exports",I.slice(1))}));v.hooks.expression.for("module.exports").tap("CommonJsExportsParserPlugin",(v=>handleAccessExport(v,"module.exports",[])));v.hooks.callMemberChain.for("this").tap("CommonJsExportsParserPlugin",((I,P)=>{if(!v.scope.topLevelScope)return;return handleAccessExport(I.callee,"this",P,I)}));v.hooks.expressionMemberChain.for("this").tap("CommonJsExportsParserPlugin",((I,P)=>{if(!v.scope.topLevelScope)return;return handleAccessExport(I,"this",P)}));v.hooks.expression.for("this").tap("CommonJsExportsParserPlugin",(I=>{if(!v.scope.topLevelScope)return;return handleAccessExport(I,"this",[])}));v.hooks.expression.for("module").tap("CommonJsPlugin",(I=>{bailout();const P=xe.isEnabled(v.state);const $=new ve(P?R.harmonyModuleDecorator:R.nodeModuleDecorator,!P);$.loc=I.loc;v.state.module.addDependency($);return true}))}}v.exports=CommonJsExportsParserPlugin},15193:function(v,I,P){"use strict";const R=P(57227);const{equals:$}=P(29179);const{getTrimmedIdsAndRange:L}=P(82426);const q=P(65317);const K=P(30158);const ae=P(39460);class CommonJsFullRequireDependency extends ae{constructor(v,I,P,R){super(v);this.range=I;this.names=P;this.idRanges=R;this.call=false;this.asiSafe=undefined}getReferencedExports(v,I){if(this.call){const I=v.getModule(this);if(!I||I.getExportsType(v,false)!=="namespace"){return[this.names.slice(0,-1)]}}return[this.names]}serialize(v){const{write:I}=v;I(this.names);I(this.idRanges);I(this.call);I(this.asiSafe);super.serialize(v)}deserialize(v){const{read:I}=v;this.names=I();this.idRanges=I();this.call=I();this.asiSafe=I();super.deserialize(v)}get type(){return"cjs full require"}get category(){return"commonjs"}}CommonJsFullRequireDependency.Template=class CommonJsFullRequireDependencyTemplate extends ae.Template{apply(v,I,{module:P,runtimeTemplate:q,moduleGraph:ae,chunkGraph:ge,runtimeRequirements:be,runtime:xe,initFragments:ve}){const Ce=v;if(!Ce.range)return;const Ne=ae.getModule(Ce);let He=q.moduleExports({module:Ne,chunkGraph:ge,request:Ce.request,weak:Ce.weak,runtimeRequirements:be});const{trimmedRange:[Qe,Je],trimmedIds:Ve}=L(Ce.names,Ce.range,Ce.idRanges,ae,Ce);if(Ne){const v=ae.getExportsInfo(Ne).getUsedName(Ve,xe);if(v){const I=$(v,Ve)?"":`${R.toNormalComment(K(Ve))} `;const P=`${I}${K(v)}`;He=Ce.asiSafe===true?`(${He}${P})`:`${He}${P}`}}I.replace(Qe,Je-1,He)}};q(CommonJsFullRequireDependency,"webpack/lib/dependencies/CommonJsFullRequireDependency");v.exports=CommonJsFullRequireDependency},59935:function(v,I,P){"use strict";const{fileURLToPath:R}=P(57310);const $=P(14102);const L=P(5205);const q=P(53966);const K=P(94252);const ae=P(28665);const{evaluateToIdentifier:ge,evaluateToString:be,expressionIsUnsupported:xe,toConstantDependency:ve}=P(59932);const Ce=P(15193);const Ne=P(74406);const He=P(60667);const Qe=P(34022);const Je=P(47712);const Ve=P(61219);const{getLocalModule:Ke}=P(71356);const Ye=P(22740);const Xe=P(85499);const Ze=P(77964);const et=P(16138);const tt=Symbol("createRequire");const nt=Symbol("createRequire()");class CommonJsImportsParserPlugin{constructor(v){this.options=v}apply(v){const I=this.options;const getContext=()=>{if(v.currentTagData){const{context:I}=v.currentTagData;return I}};const tapRequireExpression=(I,P)=>{v.hooks.typeof.for(I).tap("CommonJsImportsParserPlugin",ve(v,JSON.stringify("function")));v.hooks.evaluateTypeof.for(I).tap("CommonJsImportsParserPlugin",be("function"));v.hooks.evaluateIdentifier.for(I).tap("CommonJsImportsParserPlugin",ge(I,"require",P,true))};const tapRequireExpressionTag=I=>{v.hooks.typeof.for(I).tap("CommonJsImportsParserPlugin",ve(v,JSON.stringify("function")));v.hooks.evaluateTypeof.for(I).tap("CommonJsImportsParserPlugin",be("function"))};tapRequireExpression("require",(()=>[]));tapRequireExpression("require.resolve",(()=>["resolve"]));tapRequireExpression("require.resolveWeak",(()=>["resolveWeak"]));v.hooks.assign.for("require").tap("CommonJsImportsParserPlugin",(I=>{const P=new Qe("var require;",0);P.loc=I.loc;v.state.module.addPresentationalDependency(P);return true}));v.hooks.expression.for("require.main").tap("CommonJsImportsParserPlugin",xe(v,"require.main is not supported by webpack."));v.hooks.call.for("require.main.require").tap("CommonJsImportsParserPlugin",xe(v,"require.main.require is not supported by webpack."));v.hooks.expression.for("module.parent.require").tap("CommonJsImportsParserPlugin",xe(v,"module.parent.require is not supported by webpack."));v.hooks.call.for("module.parent.require").tap("CommonJsImportsParserPlugin",xe(v,"module.parent.require is not supported by webpack."));const defineUndefined=I=>{const P=new Qe("undefined",I.range);P.loc=I.loc;v.state.module.addPresentationalDependency(P);return false};v.hooks.canRename.for("require").tap("CommonJsImportsParserPlugin",(()=>true));v.hooks.rename.for("require").tap("CommonJsImportsParserPlugin",defineUndefined);const P=ve(v,L.moduleCache,[L.moduleCache,L.moduleId,L.moduleLoaded]);v.hooks.expression.for("require.cache").tap("CommonJsImportsParserPlugin",P);const requireAsExpressionHandler=P=>{const R=new Ne({request:I.unknownContextRequest,recursive:I.unknownContextRecursive,regExp:I.unknownContextRegExp,mode:"sync"},P.range,undefined,v.scope.inShorthand,getContext());R.critical=I.unknownContextCritical&&"require function is used in a way in which dependencies cannot be statically extracted";R.loc=P.loc;R.optional=Boolean(v.scope.inTry);v.state.current.addDependency(R);return true};v.hooks.expression.for("require").tap("CommonJsImportsParserPlugin",requireAsExpressionHandler);const processRequireItem=(I,P)=>{if(P.isString()){const R=new He(P.string,P.range,getContext());R.loc=I.loc;R.optional=Boolean(v.scope.inTry);v.state.current.addDependency(R);return true}};const processRequireContext=(P,R)=>{const $=Je.create(Ne,P.range,R,P,I,{category:"commonjs"},v,undefined,getContext());if(!$)return;$.loc=P.loc;$.optional=Boolean(v.scope.inTry);v.state.current.addDependency($);return true};const createRequireHandler=P=>R=>{if(I.commonjsMagicComments){const{options:I,errors:P}=v.parseCommentOptions(R.range);if(P){for(const I of P){const{comment:P}=I;v.state.module.addWarning(new $(`Compilation error while processing magic comment(-s): /*${P.value}*/: ${I.message}`,P.loc))}}if(I&&I.webpackIgnore!==undefined){if(typeof I.webpackIgnore!=="boolean"){v.state.module.addWarning(new q(`\`webpackIgnore\` expected a boolean, but received: ${I.webpackIgnore}.`,R.loc))}else if(I.webpackIgnore){return true}}}if(R.arguments.length!==1)return;let L;const K=v.evaluateExpression(R.arguments[0]);if(K.isConditional()){let I=false;for(const v of K.options){const P=processRequireItem(R,v);if(P===undefined){I=true}}if(!I){const I=new Ye(R.callee.range);I.loc=R.loc;v.state.module.addPresentationalDependency(I);return true}}if(K.isString()&&(L=Ke(v.state,K.string))){L.flagUsed();const I=new Ve(L,R.range,P);I.loc=R.loc;v.state.module.addPresentationalDependency(I)}else{const I=processRequireItem(R,K);if(I===undefined){processRequireContext(R,K)}else{const I=new Ye(R.callee.range);I.loc=R.loc;v.state.module.addPresentationalDependency(I)}}return true};v.hooks.call.for("require").tap("CommonJsImportsParserPlugin",createRequireHandler(false));v.hooks.new.for("require").tap("CommonJsImportsParserPlugin",createRequireHandler(true));v.hooks.call.for("module.require").tap("CommonJsImportsParserPlugin",createRequireHandler(false));v.hooks.new.for("module.require").tap("CommonJsImportsParserPlugin",createRequireHandler(true));const chainHandler=(I,P,R,$,L)=>{if(R.arguments.length!==1)return;const q=v.evaluateExpression(R.arguments[0]);if(q.isString()&&!Ke(v.state,q.string)){const P=new Ce(q.string,I.range,$,L);P.asiSafe=!v.isAsiPosition(I.range[0]);P.optional=Boolean(v.scope.inTry);P.loc=I.loc;v.state.current.addDependency(P);return true}};const callChainHandler=(I,P,R,$,L)=>{if(R.arguments.length!==1)return;const q=v.evaluateExpression(R.arguments[0]);if(q.isString()&&!Ke(v.state,q.string)){const P=new Ce(q.string,I.callee.range,$,L);P.call=true;P.asiSafe=!v.isAsiPosition(I.range[0]);P.optional=Boolean(v.scope.inTry);P.loc=I.callee.loc;v.state.current.addDependency(P);v.walkExpressions(I.arguments);return true}};v.hooks.memberChainOfCallMemberChain.for("require").tap("CommonJsImportsParserPlugin",chainHandler);v.hooks.memberChainOfCallMemberChain.for("module.require").tap("CommonJsImportsParserPlugin",chainHandler);v.hooks.callMemberChainOfCallMemberChain.for("require").tap("CommonJsImportsParserPlugin",callChainHandler);v.hooks.callMemberChainOfCallMemberChain.for("module.require").tap("CommonJsImportsParserPlugin",callChainHandler);const processResolve=(P,R)=>{if(!R&&I.commonjsMagicComments){const{options:I,errors:R}=v.parseCommentOptions(P.range);if(R){for(const I of R){const{comment:P}=I;v.state.module.addWarning(new $(`Compilation error while processing magic comment(-s): /*${P.value}*/: ${I.message}`,P.loc))}}if(I&&I.webpackIgnore!==undefined){if(typeof I.webpackIgnore!=="boolean"){v.state.module.addWarning(new q(`\`webpackIgnore\` expected a boolean, but received: ${I.webpackIgnore}.`,P.loc))}else if(I.webpackIgnore){return true}}}if(P.arguments.length!==1)return;const L=v.evaluateExpression(P.arguments[0]);if(L.isConditional()){for(const v of L.options){const I=processResolveItem(P,v,R);if(I===undefined){processResolveContext(P,v,R)}}const I=new et(P.callee.range);I.loc=P.loc;v.state.module.addPresentationalDependency(I);return true}const K=processResolveItem(P,L,R);if(K===undefined){processResolveContext(P,L,R)}const ae=new et(P.callee.range);ae.loc=P.loc;v.state.module.addPresentationalDependency(ae);return true};const processResolveItem=(I,P,R)=>{if(P.isString()){const $=new Ze(P.string,P.range,getContext());$.loc=I.loc;$.optional=Boolean(v.scope.inTry);$.weak=R;v.state.current.addDependency($);return true}};const processResolveContext=(P,R,$)=>{const L=Je.create(Xe,R.range,R,P,I,{category:"commonjs",mode:$?"weak":"sync"},v,getContext());if(!L)return;L.loc=P.loc;L.optional=Boolean(v.scope.inTry);v.state.current.addDependency(L);return true};v.hooks.call.for("require.resolve").tap("CommonJsImportsParserPlugin",(v=>processResolve(v,false)));v.hooks.call.for("require.resolveWeak").tap("CommonJsImportsParserPlugin",(v=>processResolve(v,true)));if(!I.createRequire)return;let st=[];let rt;if(I.createRequire===true){st=["module","node:module"];rt="createRequire"}else{let v;const P=/^(.*) from (.*)$/.exec(I.createRequire);if(P){[,rt,v]=P}if(!rt||!v){const v=new K(`Parsing javascript parser option "createRequire" failed, got ${JSON.stringify(I.createRequire)}`);v.details='Expected string in format "createRequire from module", where "createRequire" is specifier name and "module" name of the module';throw v}}tapRequireExpressionTag(nt);tapRequireExpressionTag(tt);v.hooks.evaluateCallExpression.for(tt).tap("CommonJsImportsParserPlugin",(I=>{const P=parseCreateRequireArguments(I);if(P===undefined)return;const R=v.evaluatedVariable({tag:nt,data:{context:P},next:undefined});return(new ae).setIdentifier(R,R,(()=>[])).setSideEffects(false).setRange(I.range)}));v.hooks.unhandledExpressionMemberChain.for(nt).tap("CommonJsImportsParserPlugin",((I,P)=>xe(v,`createRequire().${P.join(".")} is not supported by webpack.`)(I)));v.hooks.canRename.for(nt).tap("CommonJsImportsParserPlugin",(()=>true));v.hooks.canRename.for(tt).tap("CommonJsImportsParserPlugin",(()=>true));v.hooks.rename.for(tt).tap("CommonJsImportsParserPlugin",defineUndefined);v.hooks.expression.for(nt).tap("CommonJsImportsParserPlugin",requireAsExpressionHandler);v.hooks.call.for(nt).tap("CommonJsImportsParserPlugin",createRequireHandler(false));const parseCreateRequireArguments=I=>{const P=I.arguments;if(P.length!==1){const P=new K("module.createRequire supports only one argument.");P.loc=I.loc;v.state.module.addWarning(P);return}const $=P[0];const L=v.evaluateExpression($);if(!L.isString()){const I=new K("module.createRequire failed parsing argument.");I.loc=$.loc;v.state.module.addWarning(I);return}const q=L.string.startsWith("file://")?R(L.string):L.string;return q.slice(0,q.lastIndexOf(q.startsWith("/")?"/":"\\"))};v.hooks.import.tap({name:"CommonJsImportsParserPlugin",stage:-10},((I,P)=>{if(!st.includes(P)||I.specifiers.length!==1||I.specifiers[0].type!=="ImportSpecifier"||I.specifiers[0].imported.type!=="Identifier"||I.specifiers[0].imported.name!==rt)return;const R=new Qe(v.isAsiPosition(I.range[0])?";":"",I.range);R.loc=I.loc;v.state.module.addPresentationalDependency(R);v.unsetAsiPosition(I.range[1]);return true}));v.hooks.importSpecifier.tap({name:"CommonJsImportsParserPlugin",stage:-10},((I,P,R,$)=>{if(!st.includes(P)||R!==rt)return;v.tagVariable($,tt);return true}));v.hooks.preDeclarator.tap("CommonJsImportsParserPlugin",(I=>{if(I.id.type!=="Identifier"||!I.init||I.init.type!=="CallExpression"||I.init.callee.type!=="Identifier")return;const P=v.getVariableInfo(I.init.callee.name);if(P&&P.tagInfo&&P.tagInfo.tag===tt){const P=parseCreateRequireArguments(I.init);if(P===undefined)return;v.tagVariable(I.id.name,nt,{name:I.id.name,context:P});return true}}));v.hooks.memberChainOfCallMemberChain.for(tt).tap("CommonJsImportsParserPlugin",((v,I,R,$)=>{if(I.length!==0||$.length!==1||$[0]!=="cache")return;const L=parseCreateRequireArguments(R);if(L===undefined)return;return P(v)}));v.hooks.callMemberChainOfCallMemberChain.for(tt).tap("CommonJsImportsParserPlugin",((v,I,P,R)=>{if(I.length!==0||R.length!==1||R[0]!=="resolve")return;return processResolve(v,false)}));v.hooks.expressionMemberChain.for(nt).tap("CommonJsImportsParserPlugin",((v,I)=>{if(I.length===1&&I[0]==="cache"){return P(v)}}));v.hooks.callMemberChain.for(nt).tap("CommonJsImportsParserPlugin",((v,I)=>{if(I.length===1&&I[0]==="resolve"){return processResolve(v,false)}}));v.hooks.call.for(tt).tap("CommonJsImportsParserPlugin",(I=>{const P=new Qe("/* createRequire() */ undefined",I.range);P.loc=I.loc;v.state.module.addPresentationalDependency(P);return true}))}}v.exports=CommonJsImportsParserPlugin},54256:function(v,I,P){"use strict";const R=P(5205);const $=P(78994);const L=P(48700);const q=P(57227);const K=P(57633);const ae=P(15193);const ge=P(74406);const be=P(60667);const xe=P(80239);const ve=P(27420);const Ce=P(22740);const Ne=P(85499);const He=P(77964);const Qe=P(16138);const Je=P(56711);const Ve=P(91094);const Ke=P(59935);const{JAVASCRIPT_MODULE_TYPE_AUTO:Ye,JAVASCRIPT_MODULE_TYPE_DYNAMIC:Xe}=P(6041);const{evaluateToIdentifier:Ze,toConstantDependency:et}=P(59932);const tt=P(4207);const nt="CommonJsPlugin";class CommonJsPlugin{apply(v){v.hooks.compilation.tap(nt,((v,{contextModuleFactory:I,normalModuleFactory:P})=>{v.dependencyFactories.set(be,P);v.dependencyTemplates.set(be,new be.Template);v.dependencyFactories.set(ae,P);v.dependencyTemplates.set(ae,new ae.Template);v.dependencyFactories.set(ge,I);v.dependencyTemplates.set(ge,new ge.Template);v.dependencyFactories.set(He,P);v.dependencyTemplates.set(He,new He.Template);v.dependencyFactories.set(Ne,I);v.dependencyTemplates.set(Ne,new Ne.Template);v.dependencyTemplates.set(Qe,new Qe.Template);v.dependencyTemplates.set(Ce,new Ce.Template);v.dependencyTemplates.set(K,new K.Template);v.dependencyFactories.set(tt,P);v.dependencyTemplates.set(tt,new tt.Template);const $=new L(v.moduleGraph);v.dependencyFactories.set(xe,$);v.dependencyTemplates.set(xe,new xe.Template);v.dependencyFactories.set(ve,$);v.dependencyTemplates.set(ve,new ve.Template);v.hooks.runtimeRequirementInModule.for(R.harmonyModuleDecorator).tap(nt,((v,I)=>{I.add(R.module);I.add(R.requireScope)}));v.hooks.runtimeRequirementInModule.for(R.nodeModuleDecorator).tap(nt,((v,I)=>{I.add(R.module);I.add(R.requireScope)}));v.hooks.runtimeRequirementInTree.for(R.harmonyModuleDecorator).tap(nt,((I,P)=>{v.addRuntimeModule(I,new HarmonyModuleDecoratorRuntimeModule)}));v.hooks.runtimeRequirementInTree.for(R.nodeModuleDecorator).tap(nt,((I,P)=>{v.addRuntimeModule(I,new NodeModuleDecoratorRuntimeModule)}));const handler=(I,P)=>{if(P.commonjs!==undefined&&!P.commonjs)return;I.hooks.typeof.for("module").tap(nt,et(I,JSON.stringify("object")));I.hooks.expression.for("require.main").tap(nt,et(I,`${R.moduleCache}[${R.entryModuleId}]`,[R.moduleCache,R.entryModuleId]));I.hooks.expression.for(R.moduleLoaded).tap(nt,(v=>{I.state.module.buildInfo.moduleConcatenationBailout=R.moduleLoaded;const P=new Je([R.moduleLoaded]);P.loc=v.loc;I.state.module.addPresentationalDependency(P);return true}));I.hooks.expression.for(R.moduleId).tap(nt,(v=>{I.state.module.buildInfo.moduleConcatenationBailout=R.moduleId;const P=new Je([R.moduleId]);P.loc=v.loc;I.state.module.addPresentationalDependency(P);return true}));I.hooks.evaluateIdentifier.for("module.hot").tap(nt,Ze("module.hot","module",(()=>["hot"]),null));new Ke(P).apply(I);new Ve(v.moduleGraph).apply(I)};P.hooks.parser.for(Ye).tap(nt,handler);P.hooks.parser.for(Xe).tap(nt,handler)}))}}class HarmonyModuleDecoratorRuntimeModule extends ${constructor(){super("harmony module decorator")}generate(){const{runtimeTemplate:v}=this.compilation;return q.asString([`${R.harmonyModuleDecorator} = ${v.basicFunction("module",["module = Object.create(module);","if (!module.children) module.children = [];","Object.defineProperty(module, 'exports', {",q.indent(["enumerable: true,",`set: ${v.basicFunction("",["throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);"])}`]),"});","return module;"])};`])}}class NodeModuleDecoratorRuntimeModule extends ${constructor(){super("node module decorator")}generate(){const{runtimeTemplate:v}=this.compilation;return q.asString([`${R.nodeModuleDecorator} = ${v.basicFunction("module",["module.paths = [];","if (!module.children) module.children = [];","return module;"])};`])}}v.exports=CommonJsPlugin},74406:function(v,I,P){"use strict";const R=P(65317);const $=P(38768);const L=P(17694);class CommonJsRequireContextDependency extends ${constructor(v,I,P,R,$){super(v,$);this.range=I;this.valueRange=P;this.inShorthand=R}get type(){return"cjs require context"}serialize(v){const{write:I}=v;I(this.range);I(this.valueRange);I(this.inShorthand);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();this.valueRange=I();this.inShorthand=I();super.deserialize(v)}}R(CommonJsRequireContextDependency,"webpack/lib/dependencies/CommonJsRequireContextDependency");CommonJsRequireContextDependency.Template=L;v.exports=CommonJsRequireContextDependency},60667:function(v,I,P){"use strict";const R=P(65317);const $=P(39460);const L=P(73706);class CommonJsRequireDependency extends ${constructor(v,I,P){super(v);this.range=I;this._context=P}get type(){return"cjs require"}get category(){return"commonjs"}}CommonJsRequireDependency.Template=L;R(CommonJsRequireDependency,"webpack/lib/dependencies/CommonJsRequireDependency");v.exports=CommonJsRequireDependency},80239:function(v,I,P){"use strict";const R=P(5205);const{equals:$}=P(29179);const L=P(65317);const q=P(30158);const K=P(18941);class CommonJsSelfReferenceDependency extends K{constructor(v,I,P,R){super();this.range=v;this.base=I;this.names=P;this.call=R}get type(){return"cjs self exports reference"}get category(){return"self"}getResourceIdentifier(){return"self"}getReferencedExports(v,I){return[this.call?this.names.slice(0,-1):this.names]}serialize(v){const{write:I}=v;I(this.range);I(this.base);I(this.names);I(this.call);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();this.base=I();this.names=I();this.call=I();super.deserialize(v)}}L(CommonJsSelfReferenceDependency,"webpack/lib/dependencies/CommonJsSelfReferenceDependency");CommonJsSelfReferenceDependency.Template=class CommonJsSelfReferenceDependencyTemplate extends K.Template{apply(v,I,{module:P,moduleGraph:L,runtime:K,runtimeRequirements:ae}){const ge=v;const be=ge.names.length===0?ge.names:L.getExportsInfo(P).getUsedName(ge.names,K);if(!be){throw new Error("Self-reference dependency has unused export name: This should not happen")}let xe;switch(ge.base){case"exports":ae.add(R.exports);xe=P.exportsArgument;break;case"module.exports":ae.add(R.module);xe=`${P.moduleArgument}.exports`;break;case"this":ae.add(R.thisAsExports);xe="this";break;default:throw new Error(`Unsupported base ${ge.base}`)}if(xe===ge.base&&$(be,ge.names)){return}I.replace(ge.range[0],ge.range[1]-1,`${xe}${q(be)}`)}};v.exports=CommonJsSelfReferenceDependency},34022:function(v,I,P){"use strict";const R=P(65317);const $=P(18941);class ConstDependency extends ${constructor(v,I,P){super();this.expression=v;this.range=I;this.runtimeRequirements=P?new Set(P):null;this._hashUpdate=undefined}updateHash(v,I){if(this._hashUpdate===undefined){let v=`${this.range}|${this.expression}`;if(this.runtimeRequirements){for(const I of this.runtimeRequirements){v+="|";v+=I}}this._hashUpdate=v}v.update(this._hashUpdate)}getModuleEvaluationSideEffectsState(v){return false}serialize(v){const{write:I}=v;I(this.expression);I(this.range);I(this.runtimeRequirements);super.serialize(v)}deserialize(v){const{read:I}=v;this.expression=I();this.range=I();this.runtimeRequirements=I();super.deserialize(v)}}R(ConstDependency,"webpack/lib/dependencies/ConstDependency");ConstDependency.Template=class ConstDependencyTemplate extends $.Template{apply(v,I,P){const R=v;if(R.runtimeRequirements){for(const v of R.runtimeRequirements){P.runtimeRequirements.add(v)}}if(typeof R.range==="number"){I.insert(R.range,R.expression);return}I.replace(R.range[0],R.range[1]-1,R.expression)}};v.exports=ConstDependency},38768:function(v,I,P){"use strict";const R=P(49790);const $=P(82034);const L=P(65317);const q=P(13594);const K=q((()=>P(38595)));const regExpToString=v=>v?String(v):"";class ContextDependency extends R{constructor(v,I){super();this.options=v;this.userRequest=this.options&&this.options.request;this.critical=false;this.hadGlobalOrStickyRegExp=false;if(this.options&&(this.options.regExp.global||this.options.regExp.sticky)){this.options={...this.options,regExp:null};this.hadGlobalOrStickyRegExp=true}this.request=undefined;this.range=undefined;this.valueRange=undefined;this.inShorthand=undefined;this.replaces=undefined;this._requestContext=I}getContext(){return this._requestContext}get category(){return"commonjs"}couldAffectReferencingModule(){return true}getResourceIdentifier(){return`context${this._requestContext||""}|ctx request${this.options.request} ${this.options.recursive} `+`${regExpToString(this.options.regExp)} ${regExpToString(this.options.include)} ${regExpToString(this.options.exclude)} `+`${this.options.mode} ${this.options.chunkName} `+`${JSON.stringify(this.options.groupOptions)}`+`${this.options.referencedExports?` ${JSON.stringify(this.options.referencedExports)}`:""}`}getWarnings(v){let I=super.getWarnings(v);if(this.critical){if(!I)I=[];const v=K();I.push(new v(this.critical))}if(this.hadGlobalOrStickyRegExp){if(!I)I=[];const v=K();I.push(new v("Contexts can't use RegExps with the 'g' or 'y' flags."))}return I}serialize(v){const{write:I}=v;I(this.options);I(this.userRequest);I(this.critical);I(this.hadGlobalOrStickyRegExp);I(this.request);I(this._requestContext);I(this.range);I(this.valueRange);I(this.prepend);I(this.replaces);super.serialize(v)}deserialize(v){const{read:I}=v;this.options=I();this.userRequest=I();this.critical=I();this.hadGlobalOrStickyRegExp=I();this.request=I();this._requestContext=I();this.range=I();this.valueRange=I();this.prepend=I();this.replaces=I();super.deserialize(v)}}L(ContextDependency,"webpack/lib/dependencies/ContextDependency");ContextDependency.Template=$;v.exports=ContextDependency},47712:function(v,I,P){"use strict";const{parseResource:R}=P(46579);const quoteMeta=v=>v.replace(/[-[\]\\/{}()*+?.^$|]/g,"\\$&");const splitContextFromPrefix=v=>{const I=v.lastIndexOf("/");let P=".";if(I>=0){P=v.slice(0,I);v=`.${v.slice(I)}`}return{context:P,prefix:v}};v.exports.create=(v,I,P,$,L,q,K,...ae)=>{if(P.isTemplateString()){const ge=P.quasis;const be=ge[0].string;const xe=ge.length>1?ge[ge.length-1].string:"";const ve=P.range;const{context:Ce,prefix:Ne}=splitContextFromPrefix(be);const{path:He,query:Qe,fragment:Je}=R(xe,K);const Ve=ge.slice(1,-1);const Ke=L.wrappedContextRegExp.source+Ve.map((v=>quoteMeta(v.string)+L.wrappedContextRegExp.source)).join("");const Ye=new RegExp(`^${quoteMeta(Ne)}${Ke}${quoteMeta(He)}$`);const Xe=new v({request:Ce+Qe+Je,recursive:L.wrappedContextRecursive,regExp:Ye,mode:"sync",...q},I,ve,...ae);Xe.loc=$.loc;const Ze=[];const et=P.parts;for(const[v,I]of et.entries()){if(v%2===0){let R=I.range;let $=I.string;if(P.templateStringKind==="cooked"){$=JSON.stringify($);$=$.slice(1,-1)}if(v===0){$=Ne;R=[P.range[0],I.range[1]];$=(P.templateStringKind==="cooked"?"`":"String.raw`")+$}else if(v===et.length-1){$=He;R=[I.range[0],P.range[1]];$=`${$}\``}else if(I.expression&&I.expression.type==="TemplateElement"&&I.expression.value.raw===$){continue}Ze.push({range:R,value:$})}else{K.walkExpression(I.expression)}}Xe.replaces=Ze;Xe.critical=L.wrappedContextCritical&&"a part of the request of a dependency is an expression";return Xe}else if(P.isWrapped()&&(P.prefix&&P.prefix.isString()||P.postfix&&P.postfix.isString())){const ge=P.prefix&&P.prefix.isString()?P.prefix.string:"";const be=P.postfix&&P.postfix.isString()?P.postfix.string:"";const xe=P.prefix&&P.prefix.isString()?P.prefix.range:null;const ve=P.postfix&&P.postfix.isString()?P.postfix.range:null;const Ce=P.range;const{context:Ne,prefix:He}=splitContextFromPrefix(ge);const{path:Qe,query:Je,fragment:Ve}=R(be,K);const Ke=new RegExp(`^${quoteMeta(He)}${L.wrappedContextRegExp.source}${quoteMeta(Qe)}$`);const Ye=new v({request:Ne+Je+Ve,recursive:L.wrappedContextRecursive,regExp:Ke,mode:"sync",...q},I,Ce,...ae);Ye.loc=$.loc;const Xe=[];if(xe){Xe.push({range:xe,value:JSON.stringify(He)})}if(ve){Xe.push({range:ve,value:JSON.stringify(Qe)})}Ye.replaces=Xe;Ye.critical=L.wrappedContextCritical&&"a part of the request of a dependency is an expression";if(K&&P.wrappedInnerExpressions){for(const v of P.wrappedInnerExpressions){if(v.expression)K.walkExpression(v.expression)}}return Ye}const ge=new v({request:L.exprContextRequest,recursive:L.exprContextRecursive,regExp:L.exprContextRegExp,mode:"sync",...q},I,P.range,...ae);ge.loc=$.loc;ge.critical=L.exprContextCritical&&"the request of a dependency is an expression";K.walkExpression(P.expression);return ge}},36363:function(v,I,P){"use strict";const R=P(38768);class ContextDependencyTemplateAsId extends R.Template{apply(v,I,{runtimeTemplate:P,moduleGraph:R,chunkGraph:$,runtimeRequirements:L}){const q=v;const K=R.getModule(q);const ae=P.moduleExports({module:K,chunkGraph:$,request:q.request,weak:q.weak,runtimeRequirements:L});if(K){if(q.valueRange){if(Array.isArray(q.replaces)){for(let v=0;v<q.replaces.length;v++){const P=q.replaces[v];I.replace(P.range[0],P.range[1]-1,P.value)}}I.replace(q.valueRange[1],q.range[1]-1,")");I.replace(q.range[0],q.valueRange[0]-1,`${ae}.resolve(`)}else{I.replace(q.range[0],q.range[1]-1,`${ae}.resolve`)}}else{I.replace(q.range[0],q.range[1]-1,ae)}}}v.exports=ContextDependencyTemplateAsId},17694:function(v,I,P){"use strict";const R=P(38768);class ContextDependencyTemplateAsRequireCall extends R.Template{apply(v,I,{runtimeTemplate:P,moduleGraph:R,chunkGraph:$,runtimeRequirements:L}){const q=v;let K=P.moduleExports({module:R.getModule(q),chunkGraph:$,request:q.request,runtimeRequirements:L});if(q.inShorthand){K=`${q.inShorthand}: ${K}`}if(R.getModule(q)){if(q.valueRange){if(Array.isArray(q.replaces)){for(let v=0;v<q.replaces.length;v++){const P=q.replaces[v];I.replace(P.range[0],P.range[1]-1,P.value)}}I.replace(q.valueRange[1],q.range[1]-1,")");I.replace(q.range[0],q.valueRange[0]-1,`${K}(`)}else{I.replace(q.range[0],q.range[1]-1,K)}}else{I.replace(q.range[0],q.range[1]-1,K)}}}v.exports=ContextDependencyTemplateAsRequireCall},10573:function(v,I,P){"use strict";const R=P(49790);const $=P(65317);const L=P(39460);class ContextElementDependency extends L{constructor(v,I,P,R,$,L,q){super(v);this.referencedExports=$;this._typePrefix=P;this._category=R;this._context=L||undefined;if(I){this.userRequest=I}this.assertions=q}get type(){if(this._typePrefix){return`${this._typePrefix} context element`}return"context element"}get category(){return this._category}getReferencedExports(v,I){if(!this.referencedExports)return R.EXPORTS_OBJECT_REFERENCED;const P=[];for(const I of this.referencedExports){if(this._typePrefix==="import()"&&I[0]==="default"){const I=v.getParentModule(this);const P=v.getModule(this);const $=P.getExportsType(v,I.options.namespaceObject==="strict");if($==="default-only"||$==="default-with-named"){return R.EXPORTS_OBJECT_REFERENCED}}P.push({name:I,canMangle:false})}return P}serialize(v){const{write:I}=v;I(this._typePrefix);I(this._category);I(this.referencedExports);I(this.assertions);super.serialize(v)}deserialize(v){const{read:I}=v;this._typePrefix=I();this._category=I();this.referencedExports=I();this.assertions=I();super.deserialize(v)}}$(ContextElementDependency,"webpack/lib/dependencies/ContextElementDependency");v.exports=ContextElementDependency},33369:function(v,I,P){"use strict";const R=P(5205);const $=P(65317);const L=P(18941);class CreateScriptUrlDependency extends L{constructor(v){super();this.range=v}get type(){return"create script url"}serialize(v){const{write:I}=v;I(this.range);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();super.deserialize(v)}}CreateScriptUrlDependency.Template=class CreateScriptUrlDependencyTemplate extends L.Template{apply(v,I,{runtimeRequirements:P}){const $=v;P.add(R.createScriptUrl);I.insert($.range[0],`${R.createScriptUrl}(`);I.insert($.range[1],")")}};$(CreateScriptUrlDependency,"webpack/lib/dependencies/CreateScriptUrlDependency");v.exports=CreateScriptUrlDependency},38595:function(v,I,P){"use strict";const R=P(94252);const $=P(65317);class CriticalDependencyWarning extends R{constructor(v){super();this.name="CriticalDependencyWarning";this.message=`Critical dependency: ${v}`}}$(CriticalDependencyWarning,"webpack/lib/dependencies/CriticalDependencyWarning");v.exports=CriticalDependencyWarning},78388:function(v,I,P){"use strict";const{cssExportConvention:R}=P(68718);const $=P(65317);const L=P(18941);class CssIcssExportDependency extends L{constructor(v,I){super();this.name=v;this.value=I;this._hashUpdate=undefined}get type(){return"css :export"}getExportsConventionNames(v,I){if(this._conventionNames){return this._conventionNames}this._conventionNames=R(v,I);return this._conventionNames}getExports(v){const I=v.getParentModule(this);const P=I.generator.convention;const R=this.getExportsConventionNames(this.name,P);return{exports:R.map((v=>({name:v,canMangle:true}))),dependencies:undefined}}updateHash(v,{chunkGraph:I}){if(this._hashUpdate===undefined){const v=I.moduleGraph.getParentModule(this);const P=v.generator;const R=this.getExportsConventionNames(this.name,P.convention);this._hashUpdate=JSON.stringify(R)}v.update("exportsConvention");v.update(this._hashUpdate)}serialize(v){const{write:I}=v;I(this.name);I(this.value);super.serialize(v)}deserialize(v){const{read:I}=v;this.name=I();this.value=I();super.deserialize(v)}}CssIcssExportDependency.Template=class CssIcssExportDependencyTemplate extends L.Template{apply(v,I,{cssData:P,module:R,runtime:$,moduleGraph:L}){const q=v;const K=R;const ae=K.generator.convention;const ge=q.getExportsConventionNames(q.name,ae);const be=ge.map((v=>L.getExportInfo(K,v).getUsedName(v,$))).filter(Boolean);for(const v of be.concat(ge)){P.exports.set(v,q.value)}}};$(CssIcssExportDependency,"webpack/lib/dependencies/CssIcssExportDependency");v.exports=CssIcssExportDependency},74953:function(v,I,P){"use strict";const R=P(65317);const $=P(78388);const L=P(4530);const q=P(39460);class CssIcssImportDependency extends q{constructor(v,I,P){super(v);this.range=P;this.exportName=I}get type(){return"css :import"}get category(){return"css-import"}serialize(v){const{write:I}=v;I(this.range);I(this.exportName);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();this.exportName=I();super.deserialize(v)}}CssIcssImportDependency.Template=class CssIcssImportDependencyTemplate extends q.Template{apply(v,I,P){const R=v;const{range:q}=R;const K=P.moduleGraph.getModule(R);let ae;for(const v of K.dependencies){if(v instanceof L&&R.exportName===v.name){ae=L.Template.getIdentifier(v,R.exportName,{...P,module:K});break}else if(v instanceof $&&R.exportName===v.name){ae=v.value;break}}if(!ae){throw new Error(`Imported '${R.exportName}' name from '${R.request}' not found`)}I.replace(q[0],q[1],ae)}};R(CssIcssImportDependency,"webpack/lib/dependencies/CssIcssImportDependency");v.exports=CssIcssImportDependency},57554:function(v,I,P){"use strict";const R=P(65317);const $=P(18941);class CssIcssSymbolDependency extends ${constructor(v,I,P){super();this.name=v;this.value=I;this.range=P;this._hashUpdate=undefined}get type(){return"css @value identifier"}get category(){return"self"}updateHash(v,I){if(this._hashUpdate===undefined){this._hashUpdate=`${this.range}${this.name}${this.value}`}v.update(this._hashUpdate)}getExports(v){return{exports:[{name:this.name,canMangle:true}],dependencies:undefined}}getReferencedExports(v,I){return[[this.name]]}serialize(v){const{write:I}=v;I(this.name);I(this.value);I(this.range);super.serialize(v)}deserialize(v){const{read:I}=v;this.name=I();this.value=I();this.range=I();super.deserialize(v)}}CssIcssSymbolDependency.Template=class CssValueAtRuleDependencyTemplate extends $.Template{apply(v,I,{cssData:P}){const R=v;I.replace(R.range[0],R.range[1]-1,R.value);P.exports.set(R.name,R.value)}};R(CssIcssSymbolDependency,"webpack/lib/dependencies/CssIcssSymbolDependency");v.exports=CssIcssSymbolDependency},35640:function(v,I,P){"use strict";const R=P(65317);const $=P(39460);class CssImportDependency extends ${constructor(v,I,P,R,$){super(v);this.range=I;this.layer=P;this.supports=R;this.media=$}get type(){return"css @import"}get category(){return"css-import"}getResourceIdentifier(){let v=`context${this._context||""}|module${this.request}`;if(this.layer){v+=`|layer${this.layer}`}if(this.supports){v+=`|supports${this.supports}`}if(this.media){v+=`|media${this.media}`}return v}serialize(v){const{write:I}=v;I(this.layer);I(this.supports);I(this.media);super.serialize(v)}deserialize(v){const{read:I}=v;this.layer=I();this.supports=I();this.media=I();super.deserialize(v)}}CssImportDependency.Template=class CssImportDependencyTemplate extends $.Template{apply(v,I,P){const R=v;I.replace(R.range[0],R.range[1]-1,"")}};R(CssImportDependency,"webpack/lib/dependencies/CssImportDependency");v.exports=CssImportDependency},4530:function(v,I,P){"use strict";const{cssExportConvention:R}=P(68718);const $=P(12471);const{makePathsRelative:L}=P(46579);const q=P(65317);const K=P(13594);const ae=P(18941);const ge=K((()=>P(42197)));const getLocalIdent=(v,I,P,R)=>{const q=I.generator.localIdentName;const K=L(I.context,I.matchResource||I.resource,R.compilation.compiler.root);const{hashFunction:ae,hashDigest:ge,hashDigestLength:be,hashSalt:xe,uniqueName:ve}=R.outputOptions;const Ce=$(ae);if(xe){Ce.update(xe)}Ce.update(K);if(!/\[local\]/.test(q)){Ce.update(v)}const Ne=Ce.digest(ge).slice(0,be);return R.compilation.getPath(q,{filename:K,hash:Ne,contentHash:Ne,chunkGraph:P,module:I}).replace(/\[local\]/g,v).replace(/\[uniqueName\]/g,ve).replace(/^((-?[0-9])|--)/,"_$1")};class CssLocalIdentifierDependency extends ae{constructor(v,I,P=""){super();this.name=v;this.range=I;this.prefix=P;this._conventionNames=undefined;this._hashUpdate=undefined}get type(){return"css local identifier"}getExportsConventionNames(v,I){if(this._conventionNames){return this._conventionNames}this._conventionNames=R(this.name,I);return this._conventionNames}getExports(v){const I=v.getParentModule(this);const P=I.generator.convention;const R=this.getExportsConventionNames(this.name,P);return{exports:R.map((v=>({name:v,canMangle:true}))),dependencies:undefined}}updateHash(v,{chunkGraph:I}){if(this._hashUpdate===undefined){const v=I.moduleGraph.getParentModule(this);const P=v.generator;const R=this.getExportsConventionNames(this.name,P.convention);this._hashUpdate=`exportsConvention|${JSON.stringify(R)}|localIdentName|${JSON.stringify(P.localIdentName)}`}v.update(this._hashUpdate)}serialize(v){const{write:I}=v;I(this.name);I(this.range);I(this.prefix);super.serialize(v)}deserialize(v){const{read:I}=v;this.name=I();this.range=I();this.prefix=I();super.deserialize(v)}}CssLocalIdentifierDependency.Template=class CssLocalIdentifierDependencyTemplate extends ae.Template{static getIdentifier(v,I,{module:P,chunkGraph:R,runtimeTemplate:$}){const L=v;const q=P;return L.prefix+ge().escapeIdentifier(getLocalIdent(I,q,R,$))}apply(v,I,P){const{module:R,moduleGraph:$,runtime:L,cssData:q}=P;const K=v;const ae=R;const be=ae.generator.convention;const xe=K.getExportsConventionNames(K.name,be);const ve=xe.map((v=>$.getExportInfo(ae,v).getUsedName(v,L))).filter(Boolean);const Ce=ve.length===0?xe[0]:ve[0];const Ne=CssLocalIdentifierDependencyTemplate.getIdentifier(K,Ce,P);I.replace(K.range[0],K.range[1]-1,Ne);for(const v of ve.concat(xe)){q.exports.set(v,ge().unescapeIdentifier(Ne))}}};q(CssLocalIdentifierDependency,"webpack/lib/dependencies/CssLocalIdentifierDependency");v.exports=CssLocalIdentifierDependency},90006:function(v,I,P){"use strict";const R=P(49790);const $=P(65317);const L=P(4530);class CssSelfLocalIdentifierDependency extends L{constructor(v,I,P="",R=undefined){super(v,I,P);this.declaredSet=R}get type(){return"css self local identifier"}get category(){return"self"}getResourceIdentifier(){return"self"}getExports(v){if(this.declaredSet&&!this.declaredSet.has(this.name))return;return super.getExports(v)}getReferencedExports(v,I){if(this.declaredSet&&!this.declaredSet.has(this.name))return R.NO_EXPORTS_REFERENCED;return[[this.name]]}serialize(v){const{write:I}=v;I(this.declaredSet);super.serialize(v)}deserialize(v){const{read:I}=v;this.declaredSet=I();super.deserialize(v)}}CssSelfLocalIdentifierDependency.Template=class CssSelfLocalIdentifierDependencyTemplate extends L.Template{apply(v,I,P){const R=v;if(R.declaredSet&&!R.declaredSet.has(R.name))return;super.apply(v,I,P)}};$(CssSelfLocalIdentifierDependency,"webpack/lib/dependencies/CssSelfLocalIdentifierDependency");v.exports=CssSelfLocalIdentifierDependency},79026:function(v,I,P){"use strict";const R=P(18966);const $=P(65317);const L=P(13594);const q=P(39460);const K=L((()=>new R("data:,","ignored-asset","(ignored asset)")));class CssUrlDependency extends q{constructor(v,I,P){super(v);this.range=I;this.urlType=P}get type(){return"css url()"}get category(){return"url"}createIgnoredModule(v){return K()}serialize(v){const{write:I}=v;I(this.urlType);super.serialize(v)}deserialize(v){const{read:I}=v;this.urlType=I();super.deserialize(v)}}const cssEscapeString=v=>{let I=0;let P=0;let R=0;for(let $=0;$<v.length;$++){const L=v.charCodeAt($);switch(L){case 9:case 10:case 32:case 40:case 41:I++;break;case 34:P++;break;case 39:R++;break}}if(I<2){return v.replace(/[\n\t ()'"\\]/g,(v=>`\\${v}`))}else if(P<=R){return`"${v.replace(/[\n"\\]/g,(v=>`\\${v}`))}"`}return`'${v.replace(/[\n'\\]/g,(v=>`\\${v}`))}'`};CssUrlDependency.Template=class CssUrlDependencyTemplate extends q.Template{apply(v,I,{moduleGraph:P,runtimeTemplate:R,codeGenerationResults:$}){const L=v;const q=P.getModule(L);let K;switch(L.urlType){case"string":K=cssEscapeString(this.assetUrl({module:q,codeGenerationResults:$}));break;case"url":K=`url(${cssEscapeString(this.assetUrl({module:q,codeGenerationResults:$}))})`;break;case"src":K=`src(${cssEscapeString(this.assetUrl({module:q,codeGenerationResults:$}))})`;break}I.replace(L.range[0],L.range[1]-1,K)}assetUrl({runtime:v,module:I,codeGenerationResults:P}){if(!I){return"data:,"}const R=P.get(I,v);const $=R.data;if(!$)return"data:,";const L=$.get("url");if(!L||!L["css-url"])return"data:,";return L["css-url"]}};$(CssUrlDependency,"webpack/lib/dependencies/CssUrlDependency");CssUrlDependency.PUBLIC_PATH_AUTO="__WEBPACK_CSS_PUBLIC_PATH_AUTO__";v.exports=CssUrlDependency},79443:function(v,I,P){"use strict";const R=P(65317);const $=P(39460);class DelegatedSourceDependency extends ${constructor(v){super(v)}get type(){return"delegated source"}get category(){return"esm"}}R(DelegatedSourceDependency,"webpack/lib/dependencies/DelegatedSourceDependency");v.exports=DelegatedSourceDependency},27142:function(v,I,P){"use strict";const R=P(49790);const $=P(65317);class DllEntryDependency extends R{constructor(v,I){super();this.dependencies=v;this.name=I}get type(){return"dll entry"}serialize(v){const{write:I}=v;I(this.dependencies);I(this.name);super.serialize(v)}deserialize(v){const{read:I}=v;this.dependencies=I();this.name=I();super.deserialize(v)}}$(DllEntryDependency,"webpack/lib/dependencies/DllEntryDependency");v.exports=DllEntryDependency},57342:function(v){"use strict";const I=new WeakMap;v.exports.bailout=v=>{const P=I.get(v);I.set(v,false);if(P===true){const I=v.module.buildMeta;I.exportsType=undefined;I.defaultObject=false}};v.exports.enable=v=>{const P=I.get(v);if(P===false)return;I.set(v,true);if(P!==true){const I=v.module.buildMeta;I.exportsType="default";I.defaultObject="redirect"}};v.exports.setFlagged=v=>{const P=I.get(v);if(P!==true)return;const R=v.module.buildMeta;if(R.exportsType==="dynamic")return;R.exportsType="flagged"};v.exports.setDynamic=v=>{const P=I.get(v);if(P!==true)return;v.module.buildMeta.exportsType="dynamic"};v.exports.isEnabled=v=>{const P=I.get(v);return P===true}},2932:function(v,I,P){"use strict";const R=P(65317);const $=P(39460);class EntryDependency extends ${constructor(v){super(v)}get type(){return"entry"}get category(){return"esm"}}R(EntryDependency,"webpack/lib/dependencies/EntryDependency");v.exports=EntryDependency},7001:function(v,I,P){"use strict";const{UsageState:R}=P(21311);const $=P(65317);const L=P(18941);const getProperty=(v,I,P,$,L)=>{if(!P){switch($){case"usedExports":{const P=v.getExportsInfo(I).getUsedExports(L);if(typeof P==="boolean"||P===undefined||P===null){return P}return Array.from(P).sort()}}}const q=P;switch($){case"canMangle":{const P=v.getExportsInfo(I);const R=P.getReadOnlyExportInfoRecursive(q);if(R)return R.canMangle;return P.otherExportsInfo.canMangle}case"used":return v.getExportsInfo(I).getUsed(q,L)!==R.Unused;case"useInfo":{const P=v.getExportsInfo(I).getUsed(q,L);switch(P){case R.Used:case R.OnlyPropertiesUsed:return true;case R.Unused:return false;case R.NoInfo:return;case R.Unknown:return null;default:throw new Error(`Unexpected UsageState ${P}`)}}case"provideInfo":return v.getExportsInfo(I).isExportProvided(q)}};class ExportsInfoDependency extends L{constructor(v,I,P){super();this.range=v;this.exportName=I;this.property=P}serialize(v){const{write:I}=v;I(this.range);I(this.exportName);I(this.property);super.serialize(v)}static deserialize(v){const I=new ExportsInfoDependency(v.read(),v.read(),v.read());I.deserialize(v);return I}}$(ExportsInfoDependency,"webpack/lib/dependencies/ExportsInfoDependency");ExportsInfoDependency.Template=class ExportsInfoDependencyTemplate extends L.Template{apply(v,I,{module:P,moduleGraph:R,runtime:$}){const L=v;const q=getProperty(R,P,L.exportName,L.property,$);I.replace(L.range[0],L.range[1]-1,q===undefined?"undefined":JSON.stringify(q))}};v.exports=ExportsInfoDependency},63121:function(v,I,P){"use strict";const R=P(65317);const $=P(45871);const L=P(16142);class ExternalModuleDependency extends ${constructor(v,I,P,R,$,L){super(R,$,L);this.importedModule=v;this.specifiers=I;this.default=P}_createHashUpdate(){return`${this.importedModule}${JSON.stringify(this.specifiers)}${this.default||"null"}${super._createHashUpdate()}`}serialize(v){super.serialize(v);const{write:I}=v;I(this.importedModule);I(this.specifiers);I(this.default)}deserialize(v){super.deserialize(v);const{read:I}=v;this.importedModule=I();this.specifiers=I();this.default=I()}}R(ExternalModuleDependency,"webpack/lib/dependencies/ExternalModuleDependency");ExternalModuleDependency.Template=class ExternalModuleDependencyTemplate extends $.Template{apply(v,I,P){super.apply(v,I,P);const R=v;const{chunkInitFragments:$,runtimeTemplate:q}=P;$.push(new L(`${q.supportNodePrefixForCoreModules()?"node:":""}${R.importedModule}`,R.specifiers,R.default))}};v.exports=ExternalModuleDependency},16142:function(v,I,P){"use strict";const R=P(89959);const $=P(65317);class ExternalModuleInitFragment extends R{constructor(v,I,P){super(undefined,R.STAGE_CONSTANTS,0,`external module imports|${v}|${P||"null"}`);this.importedModule=v;if(Array.isArray(I)){this.specifiers=new Map;for(const{name:v,value:P}of I){let I=this.specifiers.get(v);if(!I){I=new Set;this.specifiers.set(v,I)}I.add(P||v)}}else{this.specifiers=I}this.defaultImport=P}merge(v){const I=new Map(this.specifiers);for(const[P,R]of v.specifiers){if(I.has(P)){const v=I.get(P);for(const I of R)v.add(I)}else{I.set(P,R)}}return new ExternalModuleInitFragment(this.importedModule,I,this.defaultImport)}getContent({runtimeRequirements:v}){const I=[];for(const[v,P]of this.specifiers){for(const R of P){if(R===v){I.push(v)}else{I.push(`${v} as ${R}`)}}}let P=I.length>0?`{${I.join(",")}}`:"";if(this.defaultImport){P=`${this.defaultImport}${P?`, ${P}`:""}`}return`import ${P} from ${JSON.stringify(this.importedModule)};`}serialize(v){super.serialize(v);const{write:I}=v;I(this.importedModule);I(this.specifiers);I(this.defaultImport)}deserialize(v){super.deserialize(v);const{read:I}=v;this.importedModule=I();this.specifiers=I();this.defaultImport=I()}}$(ExternalModuleInitFragment,"webpack/lib/dependencies/ExternalModuleInitFragment");v.exports=ExternalModuleInitFragment},13826:function(v,I,P){"use strict";const R=P(57227);const $=P(65317);const L=P(33643);const q=P(18941);class HarmonyAcceptDependency extends q{constructor(v,I,P){super();this.range=v;this.dependencies=I;this.hasCallback=P}get type(){return"accepted harmony modules"}serialize(v){const{write:I}=v;I(this.range);I(this.dependencies);I(this.hasCallback);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();this.dependencies=I();this.hasCallback=I();super.deserialize(v)}}$(HarmonyAcceptDependency,"webpack/lib/dependencies/HarmonyAcceptDependency");HarmonyAcceptDependency.Template=class HarmonyAcceptDependencyTemplate extends q.Template{apply(v,I,P){const $=v;const{module:q,runtime:K,runtimeRequirements:ae,runtimeTemplate:ge,moduleGraph:be,chunkGraph:xe}=P;const ve=$.dependencies.map((v=>{const I=be.getModule(v);return{dependency:v,runtimeCondition:I?L.Template.getImportEmittedRuntime(q,I):false}})).filter((({runtimeCondition:v})=>v!==false)).map((({dependency:v,runtimeCondition:I})=>{const $=ge.runtimeConditionExpression({chunkGraph:xe,runtime:K,runtimeCondition:I,runtimeRequirements:ae});const L=v.getImportStatement(true,P);const q=L[0]+L[1];if($!=="true"){return`if (${$}) {\n${R.indent(q)}\n}\n`}return q})).join("");if($.hasCallback){if(ge.supportsArrowFunction()){I.insert($.range[0],`__WEBPACK_OUTDATED_DEPENDENCIES__ => { ${ve}(`);I.insert($.range[1],")(__WEBPACK_OUTDATED_DEPENDENCIES__); }")}else{I.insert($.range[0],`function(__WEBPACK_OUTDATED_DEPENDENCIES__) { ${ve}(`);I.insert($.range[1],")(__WEBPACK_OUTDATED_DEPENDENCIES__); }.bind(this)")}return}const Ce=ge.supportsArrowFunction();I.insert($.range[1]-.5,`, ${Ce?"() =>":"function()"} { ${ve} }`)}};v.exports=HarmonyAcceptDependency},13268:function(v,I,P){"use strict";const R=P(65317);const $=P(33643);const L=P(18941);class HarmonyAcceptImportDependency extends ${constructor(v){super(v,Number.NaN);this.weak=true}get type(){return"harmony accept"}}R(HarmonyAcceptImportDependency,"webpack/lib/dependencies/HarmonyAcceptImportDependency");HarmonyAcceptImportDependency.Template=L.Template;v.exports=HarmonyAcceptImportDependency},23948:function(v,I,P){"use strict";const{UsageState:R}=P(21311);const $=P(89959);const L=P(5205);const q=P(65317);const K=P(18941);class HarmonyCompatibilityDependency extends K{get type(){return"harmony export header"}}q(HarmonyCompatibilityDependency,"webpack/lib/dependencies/HarmonyCompatibilityDependency");HarmonyCompatibilityDependency.Template=class HarmonyExportDependencyTemplate extends K.Template{apply(v,I,{module:P,runtimeTemplate:q,moduleGraph:K,initFragments:ae,runtimeRequirements:ge,runtime:be,concatenationScope:xe}){if(xe)return;const ve=K.getExportsInfo(P);if(ve.getReadOnlyExportInfo("__esModule").getUsed(be)!==R.Unused){const v=q.defineEsModuleFlagStatement({exportsArgument:P.exportsArgument,runtimeRequirements:ge});ae.push(new $(v,$.STAGE_HARMONY_EXPORTS,0,"harmony compatibility"))}if(K.isAsync(P)){ge.add(L.module);ge.add(L.asyncModule);ae.push(new $(q.supportsArrowFunction()?`${L.asyncModule}(${P.moduleArgument}, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n`:`${L.asyncModule}(${P.moduleArgument}, async function (__webpack_handle_async_dependencies__, __webpack_async_result__) { try {\n`,$.STAGE_ASYNC_BOUNDARY,0,undefined,`\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }${P.buildMeta.async?", 1":""});`))}}};v.exports=HarmonyCompatibilityDependency},32842:function(v,I,P){"use strict";const R=P(32227);const{JAVASCRIPT_MODULE_TYPE_ESM:$}=P(6041);const L=P(57342);const q=P(23948);const K=P(74618);v.exports=class HarmonyDetectionParserPlugin{constructor(v){const{topLevelAwait:I=false}=v||{};this.topLevelAwait=I}apply(v){v.hooks.program.tap("HarmonyDetectionParserPlugin",(I=>{const P=v.state.module.type===$;const R=P||I.body.some((v=>v.type==="ImportDeclaration"||v.type==="ExportDefaultDeclaration"||v.type==="ExportNamedDeclaration"||v.type==="ExportAllDeclaration"));if(R){const I=v.state.module;const R=new q;R.loc={start:{line:-1,column:0},end:{line:-1,column:0},index:-3};I.addPresentationalDependency(R);L.bailout(v.state);K.enable(v.state,P);v.scope.isStrict=true}}));v.hooks.topLevelAwait.tap("HarmonyDetectionParserPlugin",(()=>{const I=v.state.module;if(!this.topLevelAwait){throw new Error("The top-level-await experiment is not enabled (set experiments.topLevelAwait: true to enable it)")}if(!K.isEnabled(v.state)){throw new Error("Top-level-await is only supported in EcmaScript Modules")}I.buildMeta.async=true;R.check(I,v.state.compilation.runtimeTemplate,"topLevelAwait")}));const skipInHarmony=()=>{if(K.isEnabled(v.state)){return true}};const nullInHarmony=()=>{if(K.isEnabled(v.state)){return null}};const I=["define","exports"];for(const P of I){v.hooks.evaluateTypeof.for(P).tap("HarmonyDetectionParserPlugin",nullInHarmony);v.hooks.typeof.for(P).tap("HarmonyDetectionParserPlugin",skipInHarmony);v.hooks.evaluate.for(P).tap("HarmonyDetectionParserPlugin",nullInHarmony);v.hooks.expression.for(P).tap("HarmonyDetectionParserPlugin",skipInHarmony);v.hooks.call.for(P).tap("HarmonyDetectionParserPlugin",skipInHarmony)}}}},75508:function(v,I,P){"use strict";const R=P(65317);const $=P(43319);class HarmonyEvaluatedImportSpecifierDependency extends ${constructor(v,I,P,R,$,L,q){super(v,I,P,R,$,false,L,[]);this.operator=q}get type(){return`evaluated X ${this.operator} harmony import specifier`}serialize(v){super.serialize(v);const{write:I}=v;I(this.operator)}deserialize(v){super.deserialize(v);const{read:I}=v;this.operator=I()}}R(HarmonyEvaluatedImportSpecifierDependency,"webpack/lib/dependencies/HarmonyEvaluatedImportSpecifierDependency");HarmonyEvaluatedImportSpecifierDependency.Template=class HarmonyEvaluatedImportSpecifierDependencyTemplate extends $.Template{apply(v,I,P){const R=v;const{module:$,moduleGraph:L,runtime:q}=P;const K=L.getConnection(R);if(K&&!K.isTargetActive(q))return;const ae=L.getExportsInfo(K.module);const ge=R.getIds(L);let be;const xe=K.module.getExportsType(L,$.buildMeta.strictHarmonyModule);switch(xe){case"default-with-named":{if(ge[0]==="default"){be=ge.length===1||ae.isExportProvided(ge.slice(1))}else{be=ae.isExportProvided(ge)}break}case"namespace":{be=ge[0]==="__esModule"?ge.length===1||undefined:ae.isExportProvided(ge);break}case"dynamic":{if(ge[0]!=="default"){be=ae.isExportProvided(ge)}break}}if(typeof be==="boolean"){I.replace(R.range[0],R.range[1]-1,` ${be}`)}else{const v=ae.getUsedName(ge,q);const $=this._getCodeForIds(R,I,P,ge.slice(0,-1));I.replace(R.range[0],R.range[1]-1,`${v?JSON.stringify(v[v.length-1]):'""'} in ${$}`)}}};v.exports=HarmonyEvaluatedImportSpecifierDependency},10831:function(v,I,P){"use strict";const{getImportAttributes:R}=P(31384);const $=P(9696);const L=P(34022);const q=P(81737);const K=P(566);const ae=P(20709);const ge=P(92091);const{ExportPresenceModes:be}=P(33643);const{harmonySpecifierTag:xe}=P(98994);const ve=P(55697);const{HarmonyStarExportsList:Ce}=ae;v.exports=class HarmonyExportDependencyParserPlugin{constructor(v){this.exportPresenceMode=v.reexportExportsPresence!==undefined?be.fromUserOption(v.reexportExportsPresence):v.exportsPresence!==undefined?be.fromUserOption(v.exportsPresence):v.strictExportPresence?be.ERROR:be.AUTO}apply(v){const{exportPresenceMode:I}=this;v.hooks.export.tap("HarmonyExportDependencyParserPlugin",(I=>{const P=new K(I.declaration&&I.declaration.range,I.range);P.loc=Object.create(I.loc);P.loc.index=-1;v.state.module.addPresentationalDependency(P);return true}));v.hooks.exportImport.tap("HarmonyExportDependencyParserPlugin",((I,P)=>{v.state.lastHarmonyImportOrder=(v.state.lastHarmonyImportOrder||0)+1;const $=new L("",I.range);$.loc=I.loc;$.loc.index=-1;v.state.module.addPresentationalDependency($);const q=new ve(P,v.state.lastHarmonyImportOrder,R(I));q.loc=Object.create(I.loc);q.loc.index=-1;v.state.current.addDependency(q);return true}));v.hooks.exportExpression.tap("HarmonyExportDependencyParserPlugin",((I,P)=>{const R=P.type==="FunctionDeclaration";const L=P.range;const K=I.range;const ae=v.getComments([K[0],L[0]]);const ge=new q(L,K,ae.map((v=>{switch(v.type){case"Block":return`/*${v.value}*/`;case"Line":return`//${v.value}\n`}return""})).join(""),P.type.endsWith("Declaration")&&P.id?P.id.name:R?{range:[L[0],P.params.length>0?P.params[0].range[0]:P.body.range[0]],prefix:`${P.async?"async ":""}function${P.generator?"*":""} `,suffix:`(${P.params.length>0?"":") "}`}:undefined);ge.loc=Object.create(I.loc);ge.loc.index=-1;v.state.current.addDependency(ge);$.addVariableUsage(v,P.type.endsWith("Declaration")&&P.id?P.id.name:"*default*","default");return true}));v.hooks.exportSpecifier.tap("HarmonyExportDependencyParserPlugin",((P,R,L,q)=>{const K=v.getTagData(R,xe);const be=v.state.harmonyNamedExports=v.state.harmonyNamedExports||new Set;be.add(L);$.addVariableUsage(v,R,L);const ve=K?new ae(K.source,K.sourceOrder,K.ids,L,be,null,I,null,K.assertions):new ge(R,L);ve.loc=Object.create(P.loc);ve.loc.index=q;const Ce=!v.isAsiPosition(P.range[0]);if(!Ce){v.setAsiPosition(P.range[1])}v.state.current.addDependency(ve);return true}));v.hooks.exportImportSpecifier.tap("HarmonyExportDependencyParserPlugin",((P,R,$,L,q)=>{const K=v.state.harmonyNamedExports=v.state.harmonyNamedExports||new Set;let ge=null;if(L){K.add(L)}else{ge=v.state.harmonyStarExports=v.state.harmonyStarExports||new Ce}const be=new ae(R,v.state.lastHarmonyImportOrder,$?[$]:[],L,K,ge&&ge.slice(),I,ge);if(ge){ge.push(be)}be.loc=Object.create(P.loc);be.loc.index=q;const xe=!v.isAsiPosition(P.range[0]);if(!xe){v.setAsiPosition(P.range[1])}v.state.current.addDependency(be);return true}))}}},81737:function(v,I,P){"use strict";const R=P(40255);const $=P(5205);const L=P(65317);const q=P(30158);const K=P(1272);const ae=P(18941);class HarmonyExportExpressionDependency extends ae{constructor(v,I,P,R){super();this.range=v;this.rangeStatement=I;this.prefix=P;this.declarationId=R}get type(){return"harmony export expression"}getExports(v){return{exports:["default"],priority:1,terminalBinding:true,dependencies:undefined}}getModuleEvaluationSideEffectsState(v){return false}serialize(v){const{write:I}=v;I(this.range);I(this.rangeStatement);I(this.prefix);I(this.declarationId);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();this.rangeStatement=I();this.prefix=I();this.declarationId=I();super.deserialize(v)}}L(HarmonyExportExpressionDependency,"webpack/lib/dependencies/HarmonyExportExpressionDependency");HarmonyExportExpressionDependency.Template=class HarmonyExportDependencyTemplate extends ae.Template{apply(v,I,{module:P,moduleGraph:L,runtimeTemplate:ae,runtimeRequirements:ge,initFragments:be,runtime:xe,concatenationScope:ve}){const Ce=v;const{declarationId:Ne}=Ce;const He=P.exportsArgument;if(Ne){let v;if(typeof Ne==="string"){v=Ne}else{v=R.DEFAULT_EXPORT;I.replace(Ne.range[0],Ne.range[1]-1,`${Ne.prefix}${v}${Ne.suffix}`)}if(ve){ve.registerExport("default",v)}else{const I=L.getExportsInfo(P).getUsedName("default",xe);if(I){const P=new Map;P.set(I,`/* export default binding */ ${v}`);be.push(new K(He,P))}}I.replace(Ce.rangeStatement[0],Ce.range[0]-1,`/* harmony default export */ ${Ce.prefix}`)}else{let v;const Ne=R.DEFAULT_EXPORT;if(ae.supportsConst()){v=`/* harmony default export */ const ${Ne} = `;if(ve){ve.registerExport("default",Ne)}else{const I=L.getExportsInfo(P).getUsedName("default",xe);if(I){ge.add($.exports);const v=new Map;v.set(I,Ne);be.push(new K(He,v))}else{v=`/* unused harmony default export */ var ${Ne} = `}}}else if(ve){v=`/* harmony default export */ var ${Ne} = `;ve.registerExport("default",Ne)}else{const I=L.getExportsInfo(P).getUsedName("default",xe);if(I){ge.add($.exports);v=`/* harmony default export */ ${He}${q(typeof I==="string"?[I]:I)} = `}else{v=`/* unused harmony default export */ var ${Ne} = `}}if(Ce.range){I.replace(Ce.rangeStatement[0],Ce.range[0]-1,`${v}(${Ce.prefix}`);I.replace(Ce.range[1],Ce.rangeStatement[1]-.5,");");return}I.replace(Ce.rangeStatement[0],Ce.rangeStatement[1]-1,v)}}};v.exports=HarmonyExportExpressionDependency},566:function(v,I,P){"use strict";const R=P(65317);const $=P(18941);class HarmonyExportHeaderDependency extends ${constructor(v,I){super();this.range=v;this.rangeStatement=I}get type(){return"harmony export header"}serialize(v){const{write:I}=v;I(this.range);I(this.rangeStatement);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();this.rangeStatement=I();super.deserialize(v)}}R(HarmonyExportHeaderDependency,"webpack/lib/dependencies/HarmonyExportHeaderDependency");HarmonyExportHeaderDependency.Template=class HarmonyExportDependencyTemplate extends $.Template{apply(v,I,P){const R=v;const $="";const L=R.range?R.range[0]-1:R.rangeStatement[1]-1;I.replace(R.rangeStatement[0],L,$)}};v.exports=HarmonyExportHeaderDependency},20709:function(v,I,P){"use strict";const R=P(73129);const $=P(49790);const{UsageState:L}=P(21311);const q=P(83403);const K=P(89959);const ae=P(5205);const ge=P(57227);const{countIterable:be}=P(57031);const{first:xe,combine:ve}=P(81956);const Ce=P(65317);const Ne=P(30158);const{propertyName:He}=P(16081);const{getRuntimeKey:Qe,keyToRuntime:Je,filterRuntime:Ve}=P(86620);const Ke=P(1272);const Ye=P(33643);const Xe=P(8655);const{ExportPresenceModes:Ze}=Ye;const et=Symbol("HarmonyExportImportedSpecifierDependency.ids");class NormalReexportItem{constructor(v,I,P,R,$){this.name=v;this.ids=I;this.exportInfo=P;this.checked=R;this.hidden=$}}class ExportMode{constructor(v){this.type=v;this.items=null;this.name=null;this.partialNamespaceExportInfo=null;this.ignored=null;this.hidden=null;this.userRequest=null;this.fakeType=0}}const determineExportAssignments=(v,I,P)=>{const R=new Set;const $=[];if(P){I=I.concat(P)}for(const P of I){const I=$.length;$[I]=R.size;const L=v.getModule(P);if(L){const P=v.getExportsInfo(L);for(const v of P.exports){if(v.provided===true&&v.name!=="default"&&!R.has(v.name)){R.add(v.name);$[I]=R.size}}}}$.push(R.size);return{names:Array.from(R),dependencyIndices:$}};const findDependencyForName=({names:v,dependencyIndices:I},P,R)=>{const $=R[Symbol.iterator]();const L=I[Symbol.iterator]();let q=$.next();let K=L.next();if(K.done)return;for(let I=0;I<v.length;I++){while(I>=K.value){q=$.next();K=L.next();if(K.done)return}if(v[I]===P)return q.value}return undefined};const getMode=(v,I,P)=>{const R=v.getModule(I);if(!R){const v=new ExportMode("missing");v.userRequest=I.userRequest;return v}const $=I.name;const q=Je(P);const K=v.getParentModule(I);const ae=v.getExportsInfo(K);if($?ae.getUsed($,q)===L.Unused:ae.isUsed(q)===false){const v=new ExportMode("unused");v.name=$||"*";return v}const ge=R.getExportsType(v,K.buildMeta.strictHarmonyModule);const be=I.getIds(v);if($&&be.length>0&&be[0]==="default"){switch(ge){case"dynamic":{const v=new ExportMode("reexport-dynamic-default");v.name=$;return v}case"default-only":case"default-with-named":{const v=ae.getReadOnlyExportInfo($);const I=new ExportMode("reexport-named-default");I.name=$;I.partialNamespaceExportInfo=v;return I}}}if($){let v;const I=ae.getReadOnlyExportInfo($);if(be.length>0){switch(ge){case"default-only":v=new ExportMode("reexport-undefined");v.name=$;break;default:v=new ExportMode("normal-reexport");v.items=[new NormalReexportItem($,be,I,false,false)];break}}else{switch(ge){case"default-only":v=new ExportMode("reexport-fake-namespace-object");v.name=$;v.partialNamespaceExportInfo=I;v.fakeType=0;break;case"default-with-named":v=new ExportMode("reexport-fake-namespace-object");v.name=$;v.partialNamespaceExportInfo=I;v.fakeType=2;break;case"dynamic":default:v=new ExportMode("reexport-namespace-object");v.name=$;v.partialNamespaceExportInfo=I}}return v}const{ignoredExports:xe,exports:ve,checked:Ce,hidden:Ne}=I.getStarReexports(v,q,ae,R);if(!ve){const v=new ExportMode("dynamic-reexport");v.ignored=xe;v.hidden=Ne;return v}if(ve.size===0){const v=new ExportMode("empty-star");v.hidden=Ne;return v}const He=new ExportMode("normal-reexport");He.items=Array.from(ve,(v=>new NormalReexportItem(v,[v],ae.getReadOnlyExportInfo(v),Ce.has(v),false)));if(Ne!==undefined){for(const v of Ne){He.items.push(new NormalReexportItem(v,[v],ae.getReadOnlyExportInfo(v),false,true))}}return He};class HarmonyExportImportedSpecifierDependency extends Ye{constructor(v,I,P,R,$,L,q,K,ae){super(v,I,ae);this.ids=P;this.name=R;this.activeExports=$;this.otherStarExports=L;this.exportPresenceMode=q;this.allStarExports=K}couldAffectReferencingModule(){return $.TRANSITIVE}get id(){throw new Error("id was renamed to ids and type changed to string[]")}getId(){throw new Error("id was renamed to ids and type changed to string[]")}setId(){throw new Error("id was renamed to ids and type changed to string[]")}get type(){return"harmony export imported specifier"}getIds(v){return v.getMeta(this)[et]||this.ids}setIds(v,I){v.getMeta(this)[et]=I}getMode(v,I){return v.dependencyCacheProvide(this,Qe(I),getMode)}getStarReexports(v,I,P=v.getExportsInfo(v.getParentModule(this)),R=v.getModule(this)){const $=v.getExportsInfo(R);const q=$.otherExportsInfo.provided===false;const K=P.otherExportsInfo.getUsed(I)===L.Unused;const ae=new Set(["default",...this.activeExports]);let ge;const be=this._discoverActiveExportsFromOtherStarExports(v);if(be!==undefined){ge=new Set;for(let v=0;v<be.namesSlice;v++){ge.add(be.names[v])}for(const v of ae)ge.delete(v)}if(!q&&!K){return{ignoredExports:ae,hidden:ge}}const xe=new Set;const ve=new Set;const Ce=ge!==undefined?new Set:undefined;if(K){for(const v of P.orderedExports){const P=v.name;if(ae.has(P))continue;if(v.getUsed(I)===L.Unused)continue;const R=$.getReadOnlyExportInfo(P);if(R.provided===false)continue;if(ge!==undefined&&ge.has(P)){Ce.add(P);continue}xe.add(P);if(R.provided===true)continue;ve.add(P)}}else if(q){for(const v of $.orderedExports){const R=v.name;if(ae.has(R))continue;if(v.provided===false)continue;const $=P.getReadOnlyExportInfo(R);if($.getUsed(I)===L.Unused)continue;if(ge!==undefined&&ge.has(R)){Ce.add(R);continue}xe.add(R);if(v.provided===true)continue;ve.add(R)}}return{ignoredExports:ae,exports:xe,checked:ve,hidden:Ce}}getCondition(v){return(I,P)=>{const R=this.getMode(v,P);return R.type!=="unused"&&R.type!=="empty-star"}}getModuleEvaluationSideEffectsState(v){return false}getReferencedExports(v,I){const P=this.getMode(v,I);switch(P.type){case"missing":case"unused":case"empty-star":case"reexport-undefined":return $.NO_EXPORTS_REFERENCED;case"reexport-dynamic-default":return $.EXPORTS_OBJECT_REFERENCED;case"reexport-named-default":{if(!P.partialNamespaceExportInfo)return $.EXPORTS_OBJECT_REFERENCED;const v=[];Xe(I,v,[],P.partialNamespaceExportInfo);return v}case"reexport-namespace-object":case"reexport-fake-namespace-object":{if(!P.partialNamespaceExportInfo)return $.EXPORTS_OBJECT_REFERENCED;const v=[];Xe(I,v,[],P.partialNamespaceExportInfo,P.type==="reexport-fake-namespace-object");return v}case"dynamic-reexport":return $.EXPORTS_OBJECT_REFERENCED;case"normal-reexport":{const v=[];for(const{ids:R,exportInfo:$,hidden:L}of P.items){if(L)continue;Xe(I,v,R,$,false)}return v}default:throw new Error(`Unknown mode ${P.type}`)}}_discoverActiveExportsFromOtherStarExports(v){if(!this.otherStarExports)return;const I="length"in this.otherStarExports?this.otherStarExports.length:be(this.otherStarExports);if(I===0)return;if(this.allStarExports){const{names:P,dependencyIndices:R}=v.cached(determineExportAssignments,this.allStarExports.dependencies);return{names:P,namesSlice:R[I-1],dependencyIndices:R,dependencyIndex:I}}const{names:P,dependencyIndices:R}=v.cached(determineExportAssignments,this.otherStarExports,this);return{names:P,namesSlice:R[I-1],dependencyIndices:R,dependencyIndex:I}}getExports(v){const I=this.getMode(v,undefined);switch(I.type){case"missing":return;case"dynamic-reexport":{const P=v.getConnection(this);return{exports:true,from:P,canMangle:false,excludeExports:I.hidden?ve(I.ignored,I.hidden):I.ignored,hideExports:I.hidden,dependencies:[P.module]}}case"empty-star":return{exports:[],hideExports:I.hidden,dependencies:[v.getModule(this)]};case"normal-reexport":{const P=v.getConnection(this);return{exports:Array.from(I.items,(v=>({name:v.name,from:P,export:v.ids,hidden:v.hidden}))),priority:1,dependencies:[P.module]}}case"reexport-dynamic-default":{const P=v.getConnection(this);return{exports:[{name:I.name,from:P,export:["default"]}],priority:1,dependencies:[P.module]}}case"reexport-undefined":return{exports:[I.name],dependencies:[v.getModule(this)]};case"reexport-fake-namespace-object":{const P=v.getConnection(this);return{exports:[{name:I.name,from:P,export:null,exports:[{name:"default",canMangle:false,from:P,export:null}]}],priority:1,dependencies:[P.module]}}case"reexport-namespace-object":{const P=v.getConnection(this);return{exports:[{name:I.name,from:P,export:null}],priority:1,dependencies:[P.module]}}case"reexport-named-default":{const P=v.getConnection(this);return{exports:[{name:I.name,from:P,export:["default"]}],priority:1,dependencies:[P.module]}}default:throw new Error(`Unknown mode ${I.type}`)}}_getEffectiveExportPresenceLevel(v){if(this.exportPresenceMode!==Ze.AUTO)return this.exportPresenceMode;const I=v.getParentModule(this);return I.buildMeta.strictHarmonyModule?Ze.ERROR:Ze.WARN}getWarnings(v){const I=this._getEffectiveExportPresenceLevel(v);if(I===Ze.WARN){return this._getErrors(v)}return null}getErrors(v){const I=this._getEffectiveExportPresenceLevel(v);if(I===Ze.ERROR){return this._getErrors(v)}return null}_getErrors(v){const I=this.getIds(v);let P=this.getLinkingErrors(v,I,`(reexported as '${this.name}')`);if(I.length===0&&this.name===null){const I=this._discoverActiveExportsFromOtherStarExports(v);if(I&&I.namesSlice>0){const R=new Set(I.names.slice(I.namesSlice,I.dependencyIndices[I.dependencyIndex]));const $=v.getModule(this);if($){const L=v.getExportsInfo($);const K=new Map;for(const P of L.orderedExports){if(P.provided!==true)continue;if(P.name==="default")continue;if(this.activeExports.has(P.name))continue;if(R.has(P.name))continue;const L=findDependencyForName(I,P.name,this.allStarExports?this.allStarExports.dependencies:[...this.otherStarExports,this]);if(!L)continue;const q=P.getTerminalBinding(v);if(!q)continue;const ae=v.getModule(L);if(ae===$)continue;const ge=v.getExportInfo(ae,P.name);const be=ge.getTerminalBinding(v);if(!be)continue;if(q===be)continue;const xe=K.get(L.request);if(xe===undefined){K.set(L.request,[P.name])}else{xe.push(P.name)}}for(const[v,I]of K){if(!P)P=[];P.push(new q(`The requested module '${this.request}' contains conflicting star exports for the ${I.length>1?"names":"name"} ${I.map((v=>`'${v}'`)).join(", ")} with the previous requested module '${v}'`))}}}}return P}serialize(v){const{write:I,setCircularReference:P}=v;P(this);I(this.ids);I(this.name);I(this.activeExports);I(this.otherStarExports);I(this.exportPresenceMode);I(this.allStarExports);super.serialize(v)}deserialize(v){const{read:I,setCircularReference:P}=v;P(this);this.ids=I();this.name=I();this.activeExports=I();this.otherStarExports=I();this.exportPresenceMode=I();this.allStarExports=I();super.deserialize(v)}}Ce(HarmonyExportImportedSpecifierDependency,"webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency");v.exports=HarmonyExportImportedSpecifierDependency;HarmonyExportImportedSpecifierDependency.Template=class HarmonyExportImportedSpecifierDependencyTemplate extends Ye.Template{apply(v,I,P){const{moduleGraph:R,runtime:$,concatenationScope:L}=P;const q=v;const K=q.getMode(R,$);if(L){switch(K.type){case"reexport-undefined":L.registerRawExport(K.name,"/* reexport non-default export from non-harmony */ undefined")}return}if(K.type!=="unused"&&K.type!=="empty-star"){super.apply(v,I,P);this._addExportFragments(P.initFragments,q,K,P.module,R,$,P.runtimeTemplate,P.runtimeRequirements)}}_addExportFragments(v,I,P,$,L,q,be,Ce){const Ne=L.getModule(I);const He=I.getImportVar(L);switch(P.type){case"missing":case"empty-star":v.push(new K("/* empty/unused harmony star reexport */\n",K.STAGE_HARMONY_EXPORTS,1));break;case"unused":v.push(new K(`${ge.toNormalComment(`unused harmony reexport ${P.name}`)}\n`,K.STAGE_HARMONY_EXPORTS,1));break;case"reexport-dynamic-default":v.push(this.getReexportFragment($,"reexport default from dynamic",L.getExportsInfo($).getUsedName(P.name,q),He,null,Ce));break;case"reexport-fake-namespace-object":v.push(...this.getReexportFakeNamespaceObjectFragments($,L.getExportsInfo($).getUsedName(P.name,q),He,P.fakeType,Ce));break;case"reexport-undefined":v.push(this.getReexportFragment($,"reexport non-default export from non-harmony",L.getExportsInfo($).getUsedName(P.name,q),"undefined","",Ce));break;case"reexport-named-default":v.push(this.getReexportFragment($,"reexport default export from named module",L.getExportsInfo($).getUsedName(P.name,q),He,"",Ce));break;case"reexport-namespace-object":v.push(this.getReexportFragment($,"reexport module object",L.getExportsInfo($).getUsedName(P.name,q),He,"",Ce));break;case"normal-reexport":for(const{name:ae,ids:ge,checked:be,hidden:xe}of P.items){if(xe)continue;if(be){const P=L.getConnection(I);const be=`harmony reexport (checked) ${He} ${ae}`;const xe=I.weak?false:P?Ve(q,(v=>P.isTargetActive(v))):true;v.push(new R(`/* harmony reexport (checked) */ ${this.getConditionalReexportStatement($,ae,He,ge,Ce)}`,L.isAsync(Ne)?K.STAGE_ASYNC_HARMONY_IMPORTS:K.STAGE_HARMONY_IMPORTS,I.sourceOrder,be,xe))}else{v.push(this.getReexportFragment($,"reexport safe",L.getExportsInfo($).getUsedName(ae,q),He,L.getExportsInfo(Ne).getUsedName(ge,q),Ce))}}break;case"dynamic-reexport":{const R=P.hidden?ve(P.ignored,P.hidden):P.ignored;const q=be.supportsConst()&&be.supportsArrowFunction();let ge="/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n"+`/* harmony reexport (unknown) */ for(${q?"const":"var"} __WEBPACK_IMPORT_KEY__ in ${He}) `;if(R.size>1){ge+=`if(${JSON.stringify(Array.from(R))}.indexOf(__WEBPACK_IMPORT_KEY__) < 0) `}else if(R.size===1){ge+=`if(__WEBPACK_IMPORT_KEY__ !== ${JSON.stringify(xe(R))}) `}ge+="__WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = ";ge+=q?`() => ${He}[__WEBPACK_IMPORT_KEY__]`:`function(key) { return ${He}[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)`;Ce.add(ae.exports);Ce.add(ae.definePropertyGetters);const Qe=$.exportsArgument;v.push(new K(`${ge}\n/* harmony reexport (unknown) */ ${ae.definePropertyGetters}(${Qe}, __WEBPACK_REEXPORT_OBJECT__);\n`,L.isAsync(Ne)?K.STAGE_ASYNC_HARMONY_IMPORTS:K.STAGE_HARMONY_IMPORTS,I.sourceOrder));break}default:throw new Error(`Unknown mode ${P.type}`)}}getReexportFragment(v,I,P,R,$,L){const q=this.getReturnValue(R,$);L.add(ae.exports);L.add(ae.definePropertyGetters);const K=new Map;K.set(P,`/* ${I} */ ${q}`);return new Ke(v.exportsArgument,K)}getReexportFakeNamespaceObjectFragments(v,I,P,R,$){$.add(ae.exports);$.add(ae.definePropertyGetters);$.add(ae.createFakeNamespaceObject);const L=new Map;L.set(I,`/* reexport fake namespace object from non-harmony */ ${P}_namespace_cache || (${P}_namespace_cache = ${ae.createFakeNamespaceObject}(${P}${R?`, ${R}`:""}))`);return[new K(`var ${P}_namespace_cache;\n`,K.STAGE_CONSTANTS,-1,`${P}_namespace_cache`),new Ke(v.exportsArgument,L)]}getConditionalReexportStatement(v,I,P,R,$){if(R===false){return"/* unused export */\n"}const L=v.exportsArgument;const q=this.getReturnValue(P,R);$.add(ae.exports);$.add(ae.definePropertyGetters);$.add(ae.hasOwnProperty);return`if(${ae.hasOwnProperty}(${P}, ${JSON.stringify(R[0])})) ${ae.definePropertyGetters}(${L}, { ${He(I)}: function() { return ${q}; } });\n`}getReturnValue(v,I){if(I===null){return`${v}_default.a`}if(I===""){return v}if(I===false){return"/* unused export */ undefined"}return`${v}${Ne(I)}`}};class HarmonyStarExportsList{constructor(){this.dependencies=[]}push(v){this.dependencies.push(v)}slice(){return this.dependencies.slice()}serialize({write:v,setCircularReference:I}){I(this);v(this.dependencies)}deserialize({read:v,setCircularReference:I}){I(this);this.dependencies=v()}}Ce(HarmonyStarExportsList,"webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency","HarmonyStarExportsList");v.exports.HarmonyStarExportsList=HarmonyStarExportsList},1272:function(v,I,P){"use strict";const R=P(89959);const $=P(5205);const{first:L}=P(81956);const{propertyName:q}=P(16081);const joinIterableWithComma=v=>{let I="";let P=true;for(const R of v){if(P){P=false}else{I+=", "}I+=R}return I};const K=new Map;const ae=new Set;class HarmonyExportInitFragment extends R{constructor(v,I=K,P=ae){super(undefined,R.STAGE_HARMONY_EXPORTS,1,"harmony-exports");this.exportsArgument=v;this.exportMap=I;this.unusedExports=P}mergeAll(v){let I;let P=false;let R;let $=false;for(const L of v){if(L.exportMap.size!==0){if(I===undefined){I=L.exportMap;P=false}else{if(!P){I=new Map(I);P=true}for(const[v,P]of L.exportMap){if(!I.has(v))I.set(v,P)}}}if(L.unusedExports.size!==0){if(R===undefined){R=L.unusedExports;$=false}else{if(!$){R=new Set(R);$=true}for(const v of L.unusedExports){R.add(v)}}}}return new HarmonyExportInitFragment(this.exportsArgument,I,R)}merge(v){let I;if(this.exportMap.size===0){I=v.exportMap}else if(v.exportMap.size===0){I=this.exportMap}else{I=new Map(v.exportMap);for(const[v,P]of this.exportMap){if(!I.has(v))I.set(v,P)}}let P;if(this.unusedExports.size===0){P=v.unusedExports}else if(v.unusedExports.size===0){P=this.unusedExports}else{P=new Set(v.unusedExports);for(const v of this.unusedExports){P.add(v)}}return new HarmonyExportInitFragment(this.exportsArgument,I,P)}getContent({runtimeTemplate:v,runtimeRequirements:I}){I.add($.exports);I.add($.definePropertyGetters);const P=this.unusedExports.size>1?`/* unused harmony exports ${joinIterableWithComma(this.unusedExports)} */\n`:this.unusedExports.size>0?`/* unused harmony export ${L(this.unusedExports)} */\n`:"";const R=[];const K=Array.from(this.exportMap).sort((([v],[I])=>v<I?-1:1));for(const[I,P]of K){R.push(`\n/* harmony export */   ${q(I)}: ${v.returningFunction(P)}`)}const ae=this.exportMap.size>0?`/* harmony export */ ${$.definePropertyGetters}(${this.exportsArgument}, {${R.join(",")}\n/* harmony export */ });\n`:"";return`${ae}${P}`}}v.exports=HarmonyExportInitFragment},92091:function(v,I,P){"use strict";const R=P(65317);const $=P(1272);const L=P(18941);class HarmonyExportSpecifierDependency extends L{constructor(v,I){super();this.id=v;this.name=I}get type(){return"harmony export specifier"}getExports(v){return{exports:[this.name],priority:1,terminalBinding:true,dependencies:undefined}}getModuleEvaluationSideEffectsState(v){return false}serialize(v){const{write:I}=v;I(this.id);I(this.name);super.serialize(v)}deserialize(v){const{read:I}=v;this.id=I();this.name=I();super.deserialize(v)}}R(HarmonyExportSpecifierDependency,"webpack/lib/dependencies/HarmonyExportSpecifierDependency");HarmonyExportSpecifierDependency.Template=class HarmonyExportSpecifierDependencyTemplate extends L.Template{apply(v,I,{module:P,moduleGraph:R,initFragments:L,runtime:q,concatenationScope:K}){const ae=v;if(K){K.registerExport(ae.name,ae.id);return}const ge=R.getExportsInfo(P).getUsedName(ae.name,q);if(!ge){const v=new Set;v.add(ae.name||"namespace");L.push(new $(P.exportsArgument,undefined,v));return}const be=new Map;be.set(ge,`/* binding */ ${ae.id}`);L.push(new $(P.exportsArgument,be,undefined))}};v.exports=HarmonyExportSpecifierDependency},74618:function(v,I,P){"use strict";const R=P(5205);const $=new WeakMap;v.exports.enable=(v,I)=>{const P=$.get(v);if(P===false)return;$.set(v,true);if(P!==true){const P=v.module.buildMeta;P.exportsType="namespace";const $=v.module.buildInfo;$.strict=true;$.exportsArgument=R.exports;if(I){P.strictHarmonyModule=true;$.moduleArgument="__webpack_module__"}}};v.exports.isEnabled=v=>{const I=$.get(v);return I===true}},33643:function(v,I,P){"use strict";const R=P(73129);const $=P(49790);const L=P(83403);const q=P(89959);const K=P(57227);const ae=P(79524);const{filterRuntime:ge,mergeRuntime:be}=P(86620);const xe=P(39460);const ve={NONE:0,WARN:1,AUTO:2,ERROR:3,fromUserOption(v){switch(v){case"error":return ve.ERROR;case"warn":return ve.WARN;case"auto":return ve.AUTO;case false:return ve.NONE;default:throw new Error(`Invalid export presence value ${v}`)}}};class HarmonyImportDependency extends xe{constructor(v,I,P){super(v);this.sourceOrder=I;this.assertions=P}get category(){return"esm"}getReferencedExports(v,I){return $.NO_EXPORTS_REFERENCED}getImportVar(v){const I=v.getParentModule(this);const P=v.getMeta(I);let R=P.importVarMap;if(!R)P.importVarMap=R=new Map;let $=R.get(v.getModule(this));if($)return $;$=`${K.toIdentifier(`${this.userRequest}`)}__WEBPACK_IMPORTED_MODULE_${R.size}__`;R.set(v.getModule(this),$);return $}getImportStatement(v,{runtimeTemplate:I,module:P,moduleGraph:R,chunkGraph:$,runtimeRequirements:L}){return I.importStatement({update:v,module:R.getModule(this),chunkGraph:$,importVar:this.getImportVar(R),request:this.request,originModule:P,runtimeRequirements:L})}getLinkingErrors(v,I,P){const R=v.getModule(this);if(!R||R.getNumberOfErrors()>0){return}const $=v.getParentModule(this);const q=R.getExportsType(v,$.buildMeta.strictHarmonyModule);if(q==="namespace"||q==="default-with-named"){if(I.length===0){return}if((q!=="default-with-named"||I[0]!=="default")&&v.isExportProvided(R,I)===false){let $=0;let q=v.getExportsInfo(R);while($<I.length&&q){const v=I[$++];const R=q.getReadOnlyExportInfo(v);if(R.provided===false){const v=q.getProvidedExports();const R=!Array.isArray(v)?" (possible exports unknown)":v.length===0?" (module has no exports)":` (possible exports: ${v.join(", ")})`;return[new L(`export ${I.slice(0,$).map((v=>`'${v}'`)).join(".")} ${P} was not found in '${this.userRequest}'${R}`)]}q=R.getNestedExportsInfo()}return[new L(`export ${I.map((v=>`'${v}'`)).join(".")} ${P} was not found in '${this.userRequest}'`)]}}switch(q){case"default-only":if(I.length>0&&I[0]!=="default"){return[new L(`Can't import the named export ${I.map((v=>`'${v}'`)).join(".")} ${P} from default-exporting module (only default export is available)`)]}break;case"default-with-named":if(I.length>0&&I[0]!=="default"&&R.buildMeta.defaultObject==="redirect-warn"){return[new L(`Should not import the named export ${I.map((v=>`'${v}'`)).join(".")} ${P} from default-exporting module (only default export is available soon)`)]}break}}serialize(v){const{write:I}=v;I(this.sourceOrder);I(this.assertions);super.serialize(v)}deserialize(v){const{read:I}=v;this.sourceOrder=I();this.assertions=I();super.deserialize(v)}}v.exports=HarmonyImportDependency;const Ce=new WeakMap;HarmonyImportDependency.Template=class HarmonyImportDependencyTemplate extends xe.Template{apply(v,I,P){const $=v;const{module:L,chunkGraph:K,moduleGraph:xe,runtime:ve}=P;const Ne=xe.getConnection($);if(Ne&&!Ne.isTargetActive(ve))return;const He=Ne&&Ne.module;if(Ne&&Ne.weak&&He&&K.getModuleId(He)===null){return}const Qe=He?He.identifier():$.request;const Je=`harmony import ${Qe}`;const Ve=$.weak?false:Ne?ge(ve,(v=>Ne.isTargetActive(v))):true;if(L&&He){let v=Ce.get(L);if(v===undefined){v=new WeakMap;Ce.set(L,v)}let I=Ve;const P=v.get(He)||false;if(P!==false&&I!==true){if(I===false||P===true){I=P}else{I=be(P,I)}}v.set(He,I)}const Ke=$.getImportStatement(false,P);if(He&&P.moduleGraph.isAsync(He)){P.initFragments.push(new R(Ke[0],q.STAGE_HARMONY_IMPORTS,$.sourceOrder,Je,Ve));P.initFragments.push(new ae(new Set([$.getImportVar(P.moduleGraph)])));P.initFragments.push(new R(Ke[1],q.STAGE_ASYNC_HARMONY_IMPORTS,$.sourceOrder,`${Je} compat`,Ve))}else{P.initFragments.push(new R(Ke[0]+Ke[1],q.STAGE_HARMONY_IMPORTS,$.sourceOrder,Je,Ve))}}static getImportEmittedRuntime(v,I){const P=Ce.get(v);if(P===undefined)return false;return P.get(I)||false}};v.exports.ExportPresenceModes=ve},98994:function(v,I,P){"use strict";const R=P(59035);const{getImportAttributes:$}=P(31384);const L=P(9696);const q=P(34022);const K=P(13826);const ae=P(13268);const ge=P(75508);const be=P(74618);const{ExportPresenceModes:xe}=P(33643);const ve=P(55697);const Ce=P(43319);const Ne=Symbol("harmony import");v.exports=class HarmonyImportDependencyParserPlugin{constructor(v){this.exportPresenceMode=v.importExportsPresence!==undefined?xe.fromUserOption(v.importExportsPresence):v.exportsPresence!==undefined?xe.fromUserOption(v.exportsPresence):v.strictExportPresence?xe.ERROR:xe.AUTO;this.strictThisContextOnImports=v.strictThisContextOnImports}apply(v){const{exportPresenceMode:I}=this;function getNonOptionalPart(v,I){let P=0;while(P<v.length&&I[P]===false)P++;return P!==v.length?v.slice(0,P):v}function getNonOptionalMemberChain(v,I){while(I--)v=v.object;return v}v.hooks.isPure.for("Identifier").tap("HarmonyImportDependencyParserPlugin",(I=>{const P=I;if(v.isVariableDefined(P.name)||v.getTagData(P.name,Ne)){return true}}));v.hooks.import.tap("HarmonyImportDependencyParserPlugin",((I,P)=>{v.state.lastHarmonyImportOrder=(v.state.lastHarmonyImportOrder||0)+1;const R=new q(v.isAsiPosition(I.range[0])?";":"",I.range);R.loc=I.loc;v.state.module.addPresentationalDependency(R);v.unsetAsiPosition(I.range[1]);const L=$(I);const K=new ve(P,v.state.lastHarmonyImportOrder,L);K.loc=I.loc;v.state.module.addDependency(K);return true}));v.hooks.importSpecifier.tap("HarmonyImportDependencyParserPlugin",((I,P,R,L)=>{const q=R===null?[]:[R];v.tagVariable(L,Ne,{name:L,source:P,ids:q,sourceOrder:v.state.lastHarmonyImportOrder,assertions:$(I)});return true}));v.hooks.binaryExpression.tap("HarmonyImportDependencyParserPlugin",(I=>{if(I.operator!=="in")return;const P=v.evaluateExpression(I.left);if(P.couldHaveSideEffects())return;const R=P.asString();if(!R)return;const $=v.evaluateExpression(I.right);if(!$.isIdentifier())return;const q=$.rootInfo;if(typeof q==="string"||!q||!q.tagInfo||q.tagInfo.tag!==Ne)return;const K=q.tagInfo.data;const ae=$.getMembers();const be=new ge(K.source,K.sourceOrder,K.ids.concat(ae).concat([R]),K.name,I.range,K.assertions,"in");be.directImport=ae.length===0;be.asiSafe=!v.isAsiPosition(I.range[0]);be.loc=I.loc;v.state.module.addDependency(be);L.onUsage(v.state,(v=>be.usedByExports=v));return true}));v.hooks.expression.for(Ne).tap("HarmonyImportDependencyParserPlugin",(P=>{const R=v.currentTagData;const $=new Ce(R.source,R.sourceOrder,R.ids,R.name,P.range,I,R.assertions,[]);$.referencedPropertiesInDestructuring=v.destructuringAssignmentPropertiesFor(P);$.shorthand=v.scope.inShorthand;$.directImport=true;$.asiSafe=!v.isAsiPosition(P.range[0]);$.loc=P.loc;$.call=v.scope.inTaggedTemplateTag;v.state.module.addDependency($);L.onUsage(v.state,(v=>$.usedByExports=v));return true}));v.hooks.expressionMemberChain.for(Ne).tap("HarmonyImportDependencyParserPlugin",((P,R,$,q)=>{const K=v.currentTagData;const ae=getNonOptionalPart(R,$);const ge=q.slice(0,q.length-(R.length-ae.length));const be=ae!==R?getNonOptionalMemberChain(P,R.length-ae.length):P;const xe=K.ids.concat(ae);const ve=new Ce(K.source,K.sourceOrder,xe,K.name,be.range,I,K.assertions,ge);ve.referencedPropertiesInDestructuring=v.destructuringAssignmentPropertiesFor(be);ve.asiSafe=!v.isAsiPosition(be.range[0]);ve.loc=be.loc;v.state.module.addDependency(ve);L.onUsage(v.state,(v=>ve.usedByExports=v));return true}));v.hooks.callMemberChain.for(Ne).tap("HarmonyImportDependencyParserPlugin",((P,R,$,q)=>{const{arguments:K,callee:ae}=P;const ge=v.currentTagData;const be=getNonOptionalPart(R,$);const xe=q.slice(0,q.length-(R.length-be.length));const ve=be!==R?getNonOptionalMemberChain(ae,R.length-be.length):ae;const Ne=ge.ids.concat(be);const He=new Ce(ge.source,ge.sourceOrder,Ne,ge.name,ve.range,I,ge.assertions,xe);He.directImport=R.length===0;He.call=true;He.asiSafe=!v.isAsiPosition(ve.range[0]);He.namespaceObjectAsContext=R.length>0&&this.strictThisContextOnImports;He.loc=ve.loc;v.state.module.addDependency(He);if(K)v.walkExpressions(K);L.onUsage(v.state,(v=>He.usedByExports=v));return true}));const{hotAcceptCallback:P,hotAcceptWithoutCallback:xe}=R.getParserHooks(v);P.tap("HarmonyImportDependencyParserPlugin",((I,P)=>{if(!be.isEnabled(v.state)){return}const R=P.map((P=>{const R=new ae(P);R.loc=I.loc;v.state.module.addDependency(R);return R}));if(R.length>0){const P=new K(I.range,R,true);P.loc=I.loc;v.state.module.addDependency(P)}}));xe.tap("HarmonyImportDependencyParserPlugin",((I,P)=>{if(!be.isEnabled(v.state)){return}const R=P.map((P=>{const R=new ae(P);R.loc=I.loc;v.state.module.addDependency(R);return R}));if(R.length>0){const P=new K(I.range,R,false);P.loc=I.loc;v.state.module.addDependency(P)}}))}};v.exports.harmonySpecifierTag=Ne},55697:function(v,I,P){"use strict";const R=P(65317);const $=P(33643);class HarmonyImportSideEffectDependency extends ${constructor(v,I,P){super(v,I,P)}get type(){return"harmony side effect evaluation"}getCondition(v){return I=>{const P=I.resolvedModule;if(!P)return true;return P.getSideEffectsConnectionState(v)}}getModuleEvaluationSideEffectsState(v){const I=v.getModule(this);if(!I)return true;return I.getSideEffectsConnectionState(v)}}R(HarmonyImportSideEffectDependency,"webpack/lib/dependencies/HarmonyImportSideEffectDependency");HarmonyImportSideEffectDependency.Template=class HarmonyImportSideEffectDependencyTemplate extends $.Template{apply(v,I,P){const{moduleGraph:R,concatenationScope:$}=P;if($){const I=R.getModule(v);if($.isModuleInScope(I)){return}}super.apply(v,I,P)}};v.exports=HarmonyImportSideEffectDependency},43319:function(v,I,P){"use strict";const R=P(49790);const $=P(57227);const{getDependencyUsedByExportsCondition:L}=P(9696);const{getTrimmedIdsAndRange:q}=P(82426);const K=P(65317);const ae=P(30158);const ge=P(33643);const be=Symbol("HarmonyImportSpecifierDependency.ids");const{ExportPresenceModes:xe}=ge;class HarmonyImportSpecifierDependency extends ge{constructor(v,I,P,R,$,L,q,K){super(v,I,q);this.ids=P;this.name=R;this.range=$;this.idRanges=K;this.exportPresenceMode=L;this.namespaceObjectAsContext=false;this.call=undefined;this.directImport=undefined;this.shorthand=undefined;this.asiSafe=undefined;this.usedByExports=undefined;this.referencedPropertiesInDestructuring=undefined}get id(){throw new Error("id was renamed to ids and type changed to string[]")}getId(){throw new Error("id was renamed to ids and type changed to string[]")}setId(){throw new Error("id was renamed to ids and type changed to string[]")}get type(){return"harmony import specifier"}getIds(v){const I=v.getMetaIfExisting(this);if(I===undefined)return this.ids;const P=I[be];return P!==undefined?P:this.ids}setIds(v,I){v.getMeta(this)[be]=I}getCondition(v){return L(this,this.usedByExports,v)}getModuleEvaluationSideEffectsState(v){return false}getReferencedExports(v,I){let P=this.getIds(v);if(P.length===0)return this._getReferencedExportsInDestructuring();let $=this.namespaceObjectAsContext;if(P[0]==="default"){const I=v.getParentModule(this);const L=v.getModule(this);switch(L.getExportsType(v,I.buildMeta.strictHarmonyModule)){case"default-only":case"default-with-named":if(P.length===1)return this._getReferencedExportsInDestructuring();P=P.slice(1);$=true;break;case"dynamic":return R.EXPORTS_OBJECT_REFERENCED}}if(this.call&&!this.directImport&&($||P.length>1)){if(P.length===1)return R.EXPORTS_OBJECT_REFERENCED;P=P.slice(0,-1)}return this._getReferencedExportsInDestructuring(P)}_getReferencedExportsInDestructuring(v){if(this.referencedPropertiesInDestructuring){const I=[];for(const{id:P}of this.referencedPropertiesInDestructuring){I.push(v?v.concat([P]):[P])}return I}return v?[v]:R.EXPORTS_OBJECT_REFERENCED}_getEffectiveExportPresenceLevel(v){if(this.exportPresenceMode!==xe.AUTO)return this.exportPresenceMode;const I=v.getParentModule(this).buildMeta;return I.strictHarmonyModule?xe.ERROR:xe.WARN}getWarnings(v){const I=this._getEffectiveExportPresenceLevel(v);if(I===xe.WARN){return this._getErrors(v)}return null}getErrors(v){const I=this._getEffectiveExportPresenceLevel(v);if(I===xe.ERROR){return this._getErrors(v)}return null}_getErrors(v){const I=this.getIds(v);return this.getLinkingErrors(v,I,`(imported as '${this.name}')`)}getNumberOfIdOccurrences(){return 0}serialize(v){const{write:I}=v;I(this.ids);I(this.name);I(this.range);I(this.idRanges);I(this.exportPresenceMode);I(this.namespaceObjectAsContext);I(this.call);I(this.directImport);I(this.shorthand);I(this.asiSafe);I(this.usedByExports);I(this.referencedPropertiesInDestructuring);super.serialize(v)}deserialize(v){const{read:I}=v;this.ids=I();this.name=I();this.range=I();this.idRanges=I();this.exportPresenceMode=I();this.namespaceObjectAsContext=I();this.call=I();this.directImport=I();this.shorthand=I();this.asiSafe=I();this.usedByExports=I();this.referencedPropertiesInDestructuring=I();super.deserialize(v)}}K(HarmonyImportSpecifierDependency,"webpack/lib/dependencies/HarmonyImportSpecifierDependency");HarmonyImportSpecifierDependency.Template=class HarmonyImportSpecifierDependencyTemplate extends ge.Template{apply(v,I,P){const R=v;const{moduleGraph:L,runtime:K}=P;const ae=L.getConnection(R);if(ae&&!ae.isTargetActive(K))return;const ge=R.getIds(L);const{trimmedRange:[be,xe],trimmedIds:ve}=q(ge,R.range,R.idRanges,L,R);const Ce=this._getCodeForIds(R,I,P,ve);if(R.shorthand){I.insert(xe,`: ${Ce}`)}else{I.replace(be,xe-1,Ce)}if(R.referencedPropertiesInDestructuring){let v=ge;if(ge[0]==="default"){const I=L.getParentModule(R);const P=L.getModule(R);const $=P.getExportsType(L,I.buildMeta.strictHarmonyModule);if(($==="default-only"||$==="default-with-named")&&ge.length>=1){v=ge.slice(1)}}for(const{id:P,shorthand:q,range:ae}of R.referencedPropertiesInDestructuring){const ge=v.concat([P]);const be=L.getModule(R);const xe=L.getExportsInfo(be).getUsedName(ge,K);if(!xe)return;const ve=xe[xe.length-1];const Ce=ge[ge.length-1];if(ve===Ce)continue;const Ne=`${$.toNormalComment(Ce)} `;const He=Ne+JSON.stringify(ve);I.replace(ae[0],ae[1]-1,q?`${He}: ${Ce}`:`${He}`)}}}_getCodeForIds(v,I,P,R){const{moduleGraph:$,module:L,runtime:q,concatenationScope:K}=P;const ge=$.getConnection(v);let be;if(ge&&K&&K.isModuleInScope(ge.module)){if(R.length===0){be=K.createModuleReference(ge.module,{asiSafe:v.asiSafe})}else if(v.namespaceObjectAsContext&&R.length===1){be=K.createModuleReference(ge.module,{asiSafe:v.asiSafe})+ae(R)}else{be=K.createModuleReference(ge.module,{ids:R,call:v.call,directImport:v.directImport,asiSafe:v.asiSafe})}}else{super.apply(v,I,P);const{runtimeTemplate:K,initFragments:ae,runtimeRequirements:ge}=P;be=K.exportFromImport({moduleGraph:$,module:$.getModule(v),request:v.request,exportName:R,originModule:L,asiSafe:v.shorthand?true:v.asiSafe,isCall:v.call,callContext:!v.directImport,defaultInterop:true,importVar:v.getImportVar($),initFragments:ae,runtime:q,runtimeRequirements:ge})}return be}};v.exports=HarmonyImportSpecifierDependency},26539:function(v,I,P){"use strict";const R=P(13826);const $=P(13268);const L=P(23948);const q=P(75508);const K=P(81737);const ae=P(566);const ge=P(20709);const be=P(92091);const xe=P(55697);const ve=P(43319);const{JAVASCRIPT_MODULE_TYPE_AUTO:Ce,JAVASCRIPT_MODULE_TYPE_ESM:Ne}=P(6041);const He=P(32842);const Qe=P(10831);const Je=P(98994);const Ve=P(9311);const Ke="HarmonyModulesPlugin";class HarmonyModulesPlugin{constructor(v){this.options=v}apply(v){v.hooks.compilation.tap(Ke,((v,{normalModuleFactory:I})=>{v.dependencyTemplates.set(L,new L.Template);v.dependencyFactories.set(xe,I);v.dependencyTemplates.set(xe,new xe.Template);v.dependencyFactories.set(ve,I);v.dependencyTemplates.set(ve,new ve.Template);v.dependencyFactories.set(q,I);v.dependencyTemplates.set(q,new q.Template);v.dependencyTemplates.set(ae,new ae.Template);v.dependencyTemplates.set(K,new K.Template);v.dependencyTemplates.set(be,new be.Template);v.dependencyFactories.set(ge,I);v.dependencyTemplates.set(ge,new ge.Template);v.dependencyTemplates.set(R,new R.Template);v.dependencyFactories.set($,I);v.dependencyTemplates.set($,new $.Template);const handler=(v,I)=>{if(I.harmony!==undefined&&!I.harmony)return;new He(this.options).apply(v);new Je(I).apply(v);new Qe(I).apply(v);(new Ve).apply(v)};I.hooks.parser.for(Ce).tap(Ke,handler);I.hooks.parser.for(Ne).tap(Ke,handler)}))}}v.exports=HarmonyModulesPlugin},9311:function(v,I,P){"use strict";const R=P(34022);const $=P(74618);class HarmonyTopLevelThisParserPlugin{apply(v){v.hooks.expression.for("this").tap("HarmonyTopLevelThisParserPlugin",(I=>{if(!v.scope.topLevelScope)return;if($.isEnabled(v.state)){const P=new R("undefined",I.range,null);P.loc=I.loc;v.state.module.addPresentationalDependency(P);return true}}))}}v.exports=HarmonyTopLevelThisParserPlugin},86661:function(v,I,P){"use strict";const R=P(65317);const $=P(38768);const L=P(17694);class ImportContextDependency extends ${constructor(v,I,P){super(v);this.range=I;this.valueRange=P}get type(){return`import() context ${this.options.mode}`}get category(){return"esm"}serialize(v){const{write:I}=v;I(this.valueRange);super.serialize(v)}deserialize(v){const{read:I}=v;this.valueRange=I();super.deserialize(v)}}R(ImportContextDependency,"webpack/lib/dependencies/ImportContextDependency");ImportContextDependency.Template=L;v.exports=ImportContextDependency},91879:function(v,I,P){"use strict";const R=P(49790);const $=P(65317);const L=P(39460);class ImportDependency extends L{constructor(v,I,P,R){super(v);this.range=I;this.referencedExports=P;this.assertions=R}get type(){return"import()"}get category(){return"esm"}getReferencedExports(v,I){if(!this.referencedExports)return R.EXPORTS_OBJECT_REFERENCED;const P=[];for(const I of this.referencedExports){if(I[0]==="default"){const I=v.getParentModule(this);const P=v.getModule(this);const $=P.getExportsType(v,I.buildMeta.strictHarmonyModule);if($==="default-only"||$==="default-with-named"){return R.EXPORTS_OBJECT_REFERENCED}}P.push({name:I,canMangle:false})}return P}serialize(v){v.write(this.range);v.write(this.referencedExports);v.write(this.assertions);super.serialize(v)}deserialize(v){this.range=v.read();this.referencedExports=v.read();this.assertions=v.read();super.deserialize(v)}}$(ImportDependency,"webpack/lib/dependencies/ImportDependency");ImportDependency.Template=class ImportDependencyTemplate extends L.Template{apply(v,I,{runtimeTemplate:P,module:R,moduleGraph:$,chunkGraph:L,runtimeRequirements:q}){const K=v;const ae=$.getParentBlock(K);const ge=P.moduleNamespacePromise({chunkGraph:L,block:ae,module:$.getModule(K),request:K.request,strict:R.buildMeta.strictHarmonyModule,message:"import()",runtimeRequirements:q});I.replace(K.range[0],K.range[1]-1,ge)}};v.exports=ImportDependency},30729:function(v,I,P){"use strict";const R=P(65317);const $=P(91879);class ImportEagerDependency extends ${constructor(v,I,P,R){super(v,I,P,R)}get type(){return"import() eager"}get category(){return"esm"}}R(ImportEagerDependency,"webpack/lib/dependencies/ImportEagerDependency");ImportEagerDependency.Template=class ImportEagerDependencyTemplate extends $.Template{apply(v,I,{runtimeTemplate:P,module:R,moduleGraph:$,chunkGraph:L,runtimeRequirements:q}){const K=v;const ae=P.moduleNamespacePromise({chunkGraph:L,module:$.getModule(K),request:K.request,strict:R.buildMeta.strictHarmonyModule,message:"import() eager",runtimeRequirements:q});I.replace(K.range[0],K.range[1]-1,ae)}};v.exports=ImportEagerDependency},96540:function(v,I,P){"use strict";const R=P(65317);const $=P(38768);const L=P(87264);class ImportMetaContextDependency extends ${constructor(v,I){super(v);this.range=I}get category(){return"esm"}get type(){return`import.meta.webpackContext ${this.options.mode}`}}R(ImportMetaContextDependency,"webpack/lib/dependencies/ImportMetaContextDependency");ImportMetaContextDependency.Template=L;v.exports=ImportMetaContextDependency},58832:function(v,I,P){"use strict";const R=P(94252);const{evaluateToIdentifier:$}=P(59932);const L=P(96540);function createPropertyParseError(v,I){return createError(`Parsing import.meta.webpackContext options failed. Unknown value for property ${JSON.stringify(v.key.name)}, expected type ${I}.`,v.value.loc)}function createError(v,I){const P=new R(v);P.name="ImportMetaContextError";P.loc=I;return P}v.exports=class ImportMetaContextDependencyParserPlugin{apply(v){v.hooks.evaluateIdentifier.for("import.meta.webpackContext").tap("ImportMetaContextDependencyParserPlugin",(v=>$("import.meta.webpackContext","import.meta",(()=>["webpackContext"]),true)(v)));v.hooks.call.for("import.meta.webpackContext").tap("ImportMetaContextDependencyParserPlugin",(I=>{if(I.arguments.length<1||I.arguments.length>2)return;const[P,R]=I.arguments;if(R&&R.type!=="ObjectExpression")return;const $=v.evaluateExpression(P);if(!$.isString())return;const q=$.string;const K=[];let ae=/^\.\/.*$/;let ge=true;let be="sync";let xe;let ve;const Ce={};let Ne;let He;if(R){for(const I of R.properties){if(I.type!=="Property"||I.key.type!=="Identifier"){K.push(createError("Parsing import.meta.webpackContext options failed.",R.loc));break}switch(I.key.name){case"regExp":{const P=v.evaluateExpression(I.value);if(!P.isRegExp()){K.push(createPropertyParseError(I,"RegExp"))}else{ae=P.regExp}break}case"include":{const P=v.evaluateExpression(I.value);if(!P.isRegExp()){K.push(createPropertyParseError(I,"RegExp"))}else{xe=P.regExp}break}case"exclude":{const P=v.evaluateExpression(I.value);if(!P.isRegExp()){K.push(createPropertyParseError(I,"RegExp"))}else{ve=P.regExp}break}case"mode":{const P=v.evaluateExpression(I.value);if(!P.isString()){K.push(createPropertyParseError(I,"string"))}else{be=P.string}break}case"chunkName":{const P=v.evaluateExpression(I.value);if(!P.isString()){K.push(createPropertyParseError(I,"string"))}else{Ne=P.string}break}case"exports":{const P=v.evaluateExpression(I.value);if(P.isString()){He=[[P.string]]}else if(P.isArray()){const v=P.items;if(v.every((v=>{if(!v.isArray())return false;const I=v.items;return I.every((v=>v.isString()))}))){He=[];for(const I of v){const v=[];for(const P of I.items){v.push(P.string)}He.push(v)}}else{K.push(createPropertyParseError(I,"string|string[][]"))}}else{K.push(createPropertyParseError(I,"string|string[][]"))}break}case"prefetch":{const P=v.evaluateExpression(I.value);if(P.isBoolean()){Ce.prefetchOrder=0}else if(P.isNumber()){Ce.prefetchOrder=P.number}else{K.push(createPropertyParseError(I,"boolean|number"))}break}case"preload":{const P=v.evaluateExpression(I.value);if(P.isBoolean()){Ce.preloadOrder=0}else if(P.isNumber()){Ce.preloadOrder=P.number}else{K.push(createPropertyParseError(I,"boolean|number"))}break}case"fetchPriority":{const P=v.evaluateExpression(I.value);if(P.isString()&&["high","low","auto"].includes(P.string)){Ce.fetchPriority=P.string}else{K.push(createPropertyParseError(I,'"high"|"low"|"auto"'))}break}case"recursive":{const P=v.evaluateExpression(I.value);if(!P.isBoolean()){K.push(createPropertyParseError(I,"boolean"))}else{ge=P.bool}break}default:K.push(createError(`Parsing import.meta.webpackContext options failed. Unknown property ${JSON.stringify(I.key.name)}.`,R.loc))}}}if(K.length){for(const I of K)v.state.current.addError(I);return}const Qe=new L({request:q,include:xe,exclude:ve,recursive:ge,regExp:ae,groupOptions:Ce,chunkName:Ne,referencedExports:He,mode:be,category:"esm"},I.range);Qe.loc=I.loc;Qe.optional=Boolean(v.scope.inTry);v.state.current.addDependency(Qe);return true}))}}},2306:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_ESM:$}=P(6041);const L=P(10573);const q=P(96540);const K=P(58832);const ae="ImportMetaContextPlugin";class ImportMetaContextPlugin{apply(v){v.hooks.compilation.tap(ae,((v,{contextModuleFactory:I,normalModuleFactory:P})=>{v.dependencyFactories.set(q,I);v.dependencyTemplates.set(q,new q.Template);v.dependencyFactories.set(L,P);const handler=(v,I)=>{if(I.importMetaContext!==undefined&&!I.importMetaContext)return;(new K).apply(v)};P.hooks.parser.for(R).tap(ae,handler);P.hooks.parser.for($).tap(ae,handler)}))}}v.exports=ImportMetaContextPlugin},31894:function(v,I,P){"use strict";const R=P(65317);const $=P(39460);const L=P(73706);class ImportMetaHotAcceptDependency extends ${constructor(v,I){super(v);this.range=I;this.weak=true}get type(){return"import.meta.webpackHot.accept"}get category(){return"esm"}}R(ImportMetaHotAcceptDependency,"webpack/lib/dependencies/ImportMetaHotAcceptDependency");ImportMetaHotAcceptDependency.Template=L;v.exports=ImportMetaHotAcceptDependency},48536:function(v,I,P){"use strict";const R=P(65317);const $=P(39460);const L=P(73706);class ImportMetaHotDeclineDependency extends ${constructor(v,I){super(v);this.range=I;this.weak=true}get type(){return"import.meta.webpackHot.decline"}get category(){return"esm"}}R(ImportMetaHotDeclineDependency,"webpack/lib/dependencies/ImportMetaHotDeclineDependency");ImportMetaHotDeclineDependency.Template=L;v.exports=ImportMetaHotDeclineDependency},34216:function(v,I,P){"use strict";const{pathToFileURL:R}=P(57310);const $=P(96868);const{JAVASCRIPT_MODULE_TYPE_AUTO:L,JAVASCRIPT_MODULE_TYPE_ESM:q}=P(6041);const K=P(57227);const ae=P(28665);const{evaluateToIdentifier:ge,toConstantDependency:be,evaluateToString:xe,evaluateToNumber:ve}=P(59932);const Ce=P(13594);const Ne=P(30158);const He=P(34022);const Qe=Ce((()=>P(38595)));const Je="ImportMetaPlugin";class ImportMetaPlugin{apply(v){v.hooks.compilation.tap(Je,((v,{normalModuleFactory:I})=>{const getUrl=v=>R(v.resource).toString();const parserHandler=(I,{importMeta:R})=>{if(R===false){const{importMetaName:P}=v.outputOptions;if(P==="import.meta")return;I.hooks.expression.for("import.meta").tap(Je,(v=>{const R=new He(P,v.range);R.loc=v.loc;I.state.module.addPresentationalDependency(R);return true}));return}const L=Number.parseInt(P(21923).i8,10);const importMetaUrl=()=>JSON.stringify(getUrl(I.state.module));const importMetaWebpackVersion=()=>JSON.stringify(L);const importMetaUnknownProperty=v=>`${K.toNormalComment(`unsupported import.meta.${v.join(".")}`)} undefined${Ne(v,1)}`;I.hooks.typeof.for("import.meta").tap(Je,be(I,JSON.stringify("object")));I.hooks.expression.for("import.meta").tap(Je,(v=>{const P=I.destructuringAssignmentPropertiesFor(v);if(!P){const P=Qe();I.state.module.addWarning(new $(I.state.module,new P("Accessing import.meta directly is unsupported (only property access or destructuring is supported)"),v.loc));const R=new He(`${I.isAsiPosition(v.range[0])?";":""}({})`,v.range);R.loc=v.loc;I.state.module.addPresentationalDependency(R);return true}let R="";for(const{id:v}of P){switch(v){case"url":R+=`url: ${importMetaUrl()},`;break;case"webpack":R+=`webpack: ${importMetaWebpackVersion()},`;break;default:R+=`[${JSON.stringify(v)}]: ${importMetaUnknownProperty([v])},`;break}}const L=new He(`({${R}})`,v.range);L.loc=v.loc;I.state.module.addPresentationalDependency(L);return true}));I.hooks.evaluateTypeof.for("import.meta").tap(Je,xe("object"));I.hooks.evaluateIdentifier.for("import.meta").tap(Je,ge("import.meta","import.meta",(()=>[]),true));I.hooks.typeof.for("import.meta.url").tap(Je,be(I,JSON.stringify("string")));I.hooks.expression.for("import.meta.url").tap(Je,(v=>{const P=new He(importMetaUrl(),v.range);P.loc=v.loc;I.state.module.addPresentationalDependency(P);return true}));I.hooks.evaluateTypeof.for("import.meta.url").tap(Je,xe("string"));I.hooks.evaluateIdentifier.for("import.meta.url").tap(Je,(v=>(new ae).setString(getUrl(I.state.module)).setRange(v.range)));I.hooks.typeof.for("import.meta.webpack").tap(Je,be(I,JSON.stringify("number")));I.hooks.expression.for("import.meta.webpack").tap(Je,be(I,importMetaWebpackVersion()));I.hooks.evaluateTypeof.for("import.meta.webpack").tap(Je,xe("number"));I.hooks.evaluateIdentifier.for("import.meta.webpack").tap(Je,ve(L));I.hooks.unhandledExpressionMemberChain.for("import.meta").tap(Je,((v,P)=>{const R=new He(importMetaUnknownProperty(P),v.range);R.loc=v.loc;I.state.module.addPresentationalDependency(R);return true}));I.hooks.evaluate.for("MemberExpression").tap(Je,(v=>{const I=v;if(I.object.type==="MetaProperty"&&I.object.meta.name==="import"&&I.object.property.name==="meta"&&I.property.type===(I.computed?"Literal":"Identifier")){return(new ae).setUndefined().setRange(I.range)}}))};I.hooks.parser.for(L).tap(Je,parserHandler);I.hooks.parser.for(q).tap(Je,parserHandler)}))}}v.exports=ImportMetaPlugin},93344:function(v,I,P){"use strict";const R=P(67927);const $=P(14102);const L=P(53966);const{getImportAttributes:q}=P(31384);const K=P(47712);const ae=P(86661);const ge=P(91879);const be=P(30729);const xe=P(4751);class ImportParserPlugin{constructor(v){this.options=v}apply(v){const exportsFromEnumerable=v=>Array.from(v,(v=>[v]));v.hooks.importCall.tap("ImportParserPlugin",(I=>{const P=v.evaluateExpression(I.source);let ve=null;let Ce=this.options.dynamicImportMode;let Ne=null;let He=null;let Qe=null;const Je={};const{dynamicImportPreload:Ve,dynamicImportPrefetch:Ke,dynamicImportFetchPriority:Ye}=this.options;if(Ve!==undefined&&Ve!==false)Je.preloadOrder=Ve===true?0:Ve;if(Ke!==undefined&&Ke!==false)Je.prefetchOrder=Ke===true?0:Ke;if(Ye!==undefined&&Ye!==false)Je.fetchPriority=Ye;const{options:Xe,errors:Ze}=v.parseCommentOptions(I.range);if(Ze){for(const I of Ze){const{comment:P}=I;v.state.module.addWarning(new $(`Compilation error while processing magic comment(-s): /*${P.value}*/: ${I.message}`,P.loc))}}if(Xe){if(Xe.webpackIgnore!==undefined){if(typeof Xe.webpackIgnore!=="boolean"){v.state.module.addWarning(new L(`\`webpackIgnore\` expected a boolean, but received: ${Xe.webpackIgnore}.`,I.loc))}else if(Xe.webpackIgnore){return false}}if(Xe.webpackChunkName!==undefined){if(typeof Xe.webpackChunkName!=="string"){v.state.module.addWarning(new L(`\`webpackChunkName\` expected a string, but received: ${Xe.webpackChunkName}.`,I.loc))}else{ve=Xe.webpackChunkName}}if(Xe.webpackMode!==undefined){if(typeof Xe.webpackMode!=="string"){v.state.module.addWarning(new L(`\`webpackMode\` expected a string, but received: ${Xe.webpackMode}.`,I.loc))}else{Ce=Xe.webpackMode}}if(Xe.webpackPrefetch!==undefined){if(Xe.webpackPrefetch===true){Je.prefetchOrder=0}else if(typeof Xe.webpackPrefetch==="number"){Je.prefetchOrder=Xe.webpackPrefetch}else{v.state.module.addWarning(new L(`\`webpackPrefetch\` expected true or a number, but received: ${Xe.webpackPrefetch}.`,I.loc))}}if(Xe.webpackPreload!==undefined){if(Xe.webpackPreload===true){Je.preloadOrder=0}else if(typeof Xe.webpackPreload==="number"){Je.preloadOrder=Xe.webpackPreload}else{v.state.module.addWarning(new L(`\`webpackPreload\` expected true or a number, but received: ${Xe.webpackPreload}.`,I.loc))}}if(Xe.webpackFetchPriority!==undefined){if(typeof Xe.webpackFetchPriority==="string"&&["high","low","auto"].includes(Xe.webpackFetchPriority)){Je.fetchPriority=Xe.webpackFetchPriority}else{v.state.module.addWarning(new L(`\`webpackFetchPriority\` expected true or "low", "high" or "auto", but received: ${Xe.webpackFetchPriority}.`,I.loc))}}if(Xe.webpackInclude!==undefined){if(!Xe.webpackInclude||!(Xe.webpackInclude instanceof RegExp)){v.state.module.addWarning(new L(`\`webpackInclude\` expected a regular expression, but received: ${Xe.webpackInclude}.`,I.loc))}else{Ne=Xe.webpackInclude}}if(Xe.webpackExclude!==undefined){if(!Xe.webpackExclude||!(Xe.webpackExclude instanceof RegExp)){v.state.module.addWarning(new L(`\`webpackExclude\` expected a regular expression, but received: ${Xe.webpackExclude}.`,I.loc))}else{He=Xe.webpackExclude}}if(Xe.webpackExports!==undefined){if(!(typeof Xe.webpackExports==="string"||Array.isArray(Xe.webpackExports)&&Xe.webpackExports.every((v=>typeof v==="string")))){v.state.module.addWarning(new L(`\`webpackExports\` expected a string or an array of strings, but received: ${Xe.webpackExports}.`,I.loc))}else if(typeof Xe.webpackExports==="string"){Qe=[[Xe.webpackExports]]}else{Qe=exportsFromEnumerable(Xe.webpackExports)}}}if(Ce!=="lazy"&&Ce!=="lazy-once"&&Ce!=="eager"&&Ce!=="weak"){v.state.module.addWarning(new L(`\`webpackMode\` expected 'lazy', 'lazy-once', 'eager' or 'weak', but received: ${Ce}.`,I.loc));Ce="lazy"}const et=v.destructuringAssignmentPropertiesFor(I);if(et){if(Qe){v.state.module.addWarning(new L("`webpackExports` could not be used with destructuring assignment.",I.loc))}Qe=exportsFromEnumerable([...et].map((({id:v})=>v)))}if(P.isString()){const $=q(I);if(Ce==="eager"){const R=new be(P.string,I.range,Qe,$);v.state.current.addDependency(R)}else if(Ce==="weak"){const R=new xe(P.string,I.range,Qe,$);v.state.current.addDependency(R)}else{const L=new R({...Je,name:ve},I.loc,P.string);const q=new ge(P.string,I.range,Qe,$);q.loc=I.loc;q.optional=Boolean(v.scope.inTry);L.addDependency(q);v.state.current.addBlock(L)}return true}if(Ce==="weak"){Ce="async-weak"}const tt=K.create(ae,I.range,P,I,this.options,{chunkName:ve,groupOptions:Je,include:Ne,exclude:He,mode:Ce,namespaceObject:v.state.module.buildMeta.strictHarmonyModule?"strict":true,typePrefix:"import()",category:"esm",referencedExports:Qe,attributes:q(I)},v);if(!tt)return;tt.loc=I.loc;tt.optional=Boolean(v.scope.inTry);v.state.current.addDependency(tt);return true}))}}v.exports=ImportParserPlugin},59882:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$,JAVASCRIPT_MODULE_TYPE_ESM:L}=P(6041);const q=P(86661);const K=P(91879);const ae=P(30729);const ge=P(93344);const be=P(4751);const xe="ImportPlugin";class ImportPlugin{apply(v){v.hooks.compilation.tap(xe,((v,{contextModuleFactory:I,normalModuleFactory:P})=>{v.dependencyFactories.set(K,P);v.dependencyTemplates.set(K,new K.Template);v.dependencyFactories.set(ae,P);v.dependencyTemplates.set(ae,new ae.Template);v.dependencyFactories.set(be,P);v.dependencyTemplates.set(be,new be.Template);v.dependencyFactories.set(q,I);v.dependencyTemplates.set(q,new q.Template);const handler=(v,I)=>{if(I.import!==undefined&&!I.import)return;new ge(I).apply(v)};P.hooks.parser.for(R).tap(xe,handler);P.hooks.parser.for($).tap(xe,handler);P.hooks.parser.for(L).tap(xe,handler)}))}}v.exports=ImportPlugin},4751:function(v,I,P){"use strict";const R=P(65317);const $=P(91879);class ImportWeakDependency extends ${constructor(v,I,P,R){super(v,I,P,R);this.weak=true}get type(){return"import() weak"}}R(ImportWeakDependency,"webpack/lib/dependencies/ImportWeakDependency");ImportWeakDependency.Template=class ImportDependencyTemplate extends $.Template{apply(v,I,{runtimeTemplate:P,module:R,moduleGraph:$,chunkGraph:L,runtimeRequirements:q}){const K=v;const ae=P.moduleNamespacePromise({chunkGraph:L,module:$.getModule(K),request:K.request,strict:R.buildMeta.strictHarmonyModule,message:"import() weak",weak:true,runtimeRequirements:q});I.replace(K.range[0],K.range[1]-1,ae)}};v.exports=ImportWeakDependency},75724:function(v,I,P){"use strict";const R=P(65317);const $=P(18941);const getExportsWithDepth=v=>function getExportsFromData(I,P=1){if(P>v)return undefined;if(I&&typeof I==="object"){if(Array.isArray(I)){return I.length<100?I.map(((v,I)=>({name:`${I}`,canMangle:true,exports:getExportsFromData(v,P+1)}))):undefined}const v=[];for(const R of Object.keys(I)){v.push({name:R,canMangle:true,exports:getExportsFromData(I[R],P+1)})}return v}return undefined};class JsonExportsDependency extends ${constructor(v,I){super();this.data=v;this.exportsDepth=I}get type(){return"json exports"}getExports(v){return{exports:getExportsWithDepth(this.exportsDepth)(this.data&&this.data.get()),dependencies:undefined}}updateHash(v,I){this.data.updateHash(v)}serialize(v){const{write:I}=v;I(this.data);I(this.exportsDepth);super.serialize(v)}deserialize(v){const{read:I}=v;this.data=I();this.exportsDepth=I();super.deserialize(v)}}R(JsonExportsDependency,"webpack/lib/dependencies/JsonExportsDependency");v.exports=JsonExportsDependency},69555:function(v,I,P){"use strict";const R=P(39460);class LoaderDependency extends R{constructor(v){super(v)}get type(){return"loader"}get category(){return"loader"}getCondition(v){return false}}v.exports=LoaderDependency},1801:function(v,I,P){"use strict";const R=P(39460);class LoaderImportDependency extends R{constructor(v){super(v);this.weak=true}get type(){return"loader import"}get category(){return"loaderImport"}getCondition(v){return false}}v.exports=LoaderImportDependency},84816:function(v,I,P){"use strict";const R=P(32594);const $=P(11584);const L=P(69555);const q=P(1801);class LoaderPlugin{constructor(v={}){}apply(v){v.hooks.compilation.tap("LoaderPlugin",((v,{normalModuleFactory:I})=>{v.dependencyFactories.set(L,I);v.dependencyFactories.set(q,I)}));v.hooks.compilation.tap("LoaderPlugin",(v=>{const I=v.moduleGraph;R.getCompilationHooks(v).loader.tap("LoaderPlugin",(P=>{P.loadModule=(R,q)=>{const K=new L(R);K.loc={name:R};const ae=v.dependencyFactories.get(K.constructor);if(ae===undefined){return q(new Error(`No module factory available for dependency type: ${K.constructor.name}`))}const ge=v.factorizeQueue.getContext();v.factorizeQueue.setContext("load-module");const be=v.addModuleQueue.getContext();v.addModuleQueue.setContext("load-module");v.buildQueue.increaseParallelism();v.handleModuleCreation({factory:ae,dependencies:[K],originModule:P._module,context:P.context,recursive:false},(R=>{v.factorizeQueue.setContext(ge);v.addModuleQueue.setContext(be);v.buildQueue.decreaseParallelism();if(R){return q(R)}const L=I.getModule(K);if(!L){return q(new Error("Cannot load the module"))}if(L.getNumberOfErrors()>0){return q(new Error("The loaded module contains errors"))}const ae=L.originalSource();if(!ae){return q(new Error("The module created for a LoaderDependency must have an original source"))}let xe;let ve;if(ae.sourceAndMap){const v=ae.sourceAndMap();xe=v.map;ve=v.source}else{xe=ae.map();ve=ae.source()}const Ce=new $;const Ne=new $;const He=new $;const Qe=new $;L.addCacheDependencies(Ce,Ne,He,Qe);for(const v of Ce){P.addDependency(v)}for(const v of Ne){P.addContextDependency(v)}for(const v of He){P.addMissingDependency(v)}for(const v of Qe){P.addBuildDependency(v)}return q(null,ve,xe,L)}))};const importModule=(R,$,L)=>{const K=new q(R);K.loc={name:R};const ae=v.dependencyFactories.get(K.constructor);if(ae===undefined){return L(new Error(`No module factory available for dependency type: ${K.constructor.name}`))}const ge=v.factorizeQueue.getContext();v.factorizeQueue.setContext("import-module");const be=v.addModuleQueue.getContext();v.addModuleQueue.setContext("import-module");v.buildQueue.increaseParallelism();v.handleModuleCreation({factory:ae,dependencies:[K],originModule:P._module,contextInfo:{issuerLayer:$.layer},context:P.context,connectOrigin:false,checkCycle:true},(R=>{v.factorizeQueue.setContext(ge);v.addModuleQueue.setContext(be);v.buildQueue.decreaseParallelism();if(R){return L(R)}const q=I.getModule(K);if(!q){return L(new Error("Cannot load the module"))}v.buildQueue.increaseParallelism();v.executeModule(q,{entryOptions:{baseUri:$.baseUri,publicPath:$.publicPath}},((I,R)=>{v.buildQueue.decreaseParallelism();if(I)return L(I);const{fileDependencies:$,contextDependencies:q,missingDependencies:K,buildDependencies:ae,cacheable:ge,assets:be,exports:xe}=R;for(const v of $){P.addDependency(v)}for(const v of q){P.addContextDependency(v)}for(const v of K){P.addMissingDependency(v)}for(const v of ae){P.addBuildDependency(v)}if(ge===false)P.cacheable(false);for(const[v,{source:I,info:R}]of be){const $=P._module.buildInfo;if(!$.assets){$.assets=Object.create(null);$.assetsInfo=new Map}$.assets[v]=I;$.assetsInfo.set(v,R)}L(null,xe)}))}))};P.importModule=(v,I,P)=>{if(!P){return new Promise(((P,R)=>{importModule(v,I||{},((v,I)=>{if(v)R(v);else P(I)}))}))}return importModule(v,I||{},P)}}))}))}}v.exports=LoaderPlugin},6494:function(v,I,P){"use strict";const R=P(65317);class LocalModule{constructor(v,I){this.name=v;this.idx=I;this.used=false}flagUsed(){this.used=true}variableName(){return`__WEBPACK_LOCAL_MODULE_${this.idx}__`}serialize(v){const{write:I}=v;I(this.name);I(this.idx);I(this.used)}deserialize(v){const{read:I}=v;this.name=I();this.idx=I();this.used=I()}}R(LocalModule,"webpack/lib/dependencies/LocalModule");v.exports=LocalModule},61219:function(v,I,P){"use strict";const R=P(65317);const $=P(18941);class LocalModuleDependency extends ${constructor(v,I,P){super();this.localModule=v;this.range=I;this.callNew=P}serialize(v){const{write:I}=v;I(this.localModule);I(this.range);I(this.callNew);super.serialize(v)}deserialize(v){const{read:I}=v;this.localModule=I();this.range=I();this.callNew=I();super.deserialize(v)}}R(LocalModuleDependency,"webpack/lib/dependencies/LocalModuleDependency");LocalModuleDependency.Template=class LocalModuleDependencyTemplate extends $.Template{apply(v,I,P){const R=v;if(!R.range)return;const $=R.callNew?`new (function () { return ${R.localModule.variableName()}; })()`:R.localModule.variableName();I.replace(R.range[0],R.range[1]-1,$)}};v.exports=LocalModuleDependency},71356:function(v,I,P){"use strict";const R=P(6494);const lookup=(v,I)=>{if(I.charAt(0)!==".")return I;const P=v.split("/");const R=I.split("/");P.pop();for(let v=0;v<R.length;v++){const I=R[v];if(I===".."){P.pop()}else if(I!=="."){P.push(I)}}return P.join("/")};v.exports.addLocalModule=(v,I)=>{if(!v.localModules){v.localModules=[]}const P=new R(I,v.localModules.length);v.localModules.push(P);return P};v.exports.getLocalModule=(v,I,P)=>{if(!v.localModules)return null;if(P){I=lookup(P,I)}for(let P=0;P<v.localModules.length;P++){if(v.localModules[P].name===I){return v.localModules[P]}}return null}},27420:function(v,I,P){"use strict";const R=P(49790);const $=P(89959);const L=P(5205);const q=P(65317);const K=P(18941);class ModuleDecoratorDependency extends K{constructor(v,I){super();this.decorator=v;this.allowExportsAccess=I;this._hashUpdate=undefined}get type(){return"module decorator"}get category(){return"self"}getResourceIdentifier(){return"self"}getReferencedExports(v,I){return this.allowExportsAccess?R.EXPORTS_OBJECT_REFERENCED:R.NO_EXPORTS_REFERENCED}updateHash(v,I){if(this._hashUpdate===undefined){this._hashUpdate=`${this.decorator}${this.allowExportsAccess}`}v.update(this._hashUpdate)}serialize(v){const{write:I}=v;I(this.decorator);I(this.allowExportsAccess);super.serialize(v)}deserialize(v){const{read:I}=v;this.decorator=I();this.allowExportsAccess=I();super.deserialize(v)}}q(ModuleDecoratorDependency,"webpack/lib/dependencies/ModuleDecoratorDependency");ModuleDecoratorDependency.Template=class ModuleDecoratorDependencyTemplate extends K.Template{apply(v,I,{module:P,chunkGraph:R,initFragments:q,runtimeRequirements:K}){const ae=v;K.add(L.moduleLoaded);K.add(L.moduleId);K.add(L.module);K.add(ae.decorator);q.push(new $(`/* module decorator */ ${P.moduleArgument} = ${ae.decorator}(${P.moduleArgument});\n`,$.STAGE_PROVIDES,0,`module decorator ${R.getModuleId(P)}`))}};v.exports=ModuleDecoratorDependency},39460:function(v,I,P){"use strict";const R=P(49790);const $=P(82034);const L=P(88490);class ModuleDependency extends R{constructor(v){super();this.request=v;this.userRequest=v;this.range=undefined;this.assertions=undefined;this._context=undefined}getContext(){return this._context}getResourceIdentifier(){let v=`context${this._context||""}|module${this.request}`;if(this.assertions!==undefined){v+=JSON.stringify(this.assertions)}return v}couldAffectReferencingModule(){return true}createIgnoredModule(v){return new L("/* (ignored) */",`ignored|${v}|${this.request}`,`${this.request} (ignored)`)}serialize(v){const{write:I}=v;I(this.request);I(this.userRequest);I(this._context);I(this.range);super.serialize(v)}deserialize(v){const{read:I}=v;this.request=I();this.userRequest=I();this._context=I();this.range=I();super.deserialize(v)}}ModuleDependency.Template=$;v.exports=ModuleDependency},73706:function(v,I,P){"use strict";const R=P(39460);class ModuleDependencyTemplateAsId extends R.Template{apply(v,I,{runtimeTemplate:P,moduleGraph:R,chunkGraph:$}){const L=v;if(!L.range)return;const q=P.moduleId({module:R.getModule(L),chunkGraph:$,request:L.request,weak:L.weak});I.replace(L.range[0],L.range[1]-1,q)}}v.exports=ModuleDependencyTemplateAsId},87264:function(v,I,P){"use strict";const R=P(39460);class ModuleDependencyTemplateAsRequireId extends R.Template{apply(v,I,{runtimeTemplate:P,moduleGraph:R,chunkGraph:$,runtimeRequirements:L}){const q=v;if(!q.range)return;const K=P.moduleExports({module:R.getModule(q),chunkGraph:$,request:q.request,weak:q.weak,runtimeRequirements:L});I.replace(q.range[0],q.range[1]-1,K)}}v.exports=ModuleDependencyTemplateAsRequireId},9897:function(v,I,P){"use strict";const R=P(65317);const $=P(39460);const L=P(73706);class ModuleHotAcceptDependency extends ${constructor(v,I){super(v);this.range=I;this.weak=true}get type(){return"module.hot.accept"}get category(){return"commonjs"}}R(ModuleHotAcceptDependency,"webpack/lib/dependencies/ModuleHotAcceptDependency");ModuleHotAcceptDependency.Template=L;v.exports=ModuleHotAcceptDependency},48242:function(v,I,P){"use strict";const R=P(65317);const $=P(39460);const L=P(73706);class ModuleHotDeclineDependency extends ${constructor(v,I){super(v);this.range=I;this.weak=true}get type(){return"module.hot.decline"}get category(){return"commonjs"}}R(ModuleHotDeclineDependency,"webpack/lib/dependencies/ModuleHotDeclineDependency");ModuleHotDeclineDependency.Template=L;v.exports=ModuleHotDeclineDependency},18941:function(v,I,P){"use strict";const R=P(49790);const $=P(82034);class NullDependency extends R{get type(){return"null"}couldAffectReferencingModule(){return false}}NullDependency.Template=class NullDependencyTemplate extends ${apply(v,I,P){}};v.exports=NullDependency},27561:function(v,I,P){"use strict";const R=P(39460);class PrefetchDependency extends R{constructor(v){super(v)}get type(){return"prefetch"}get category(){return"esm"}}v.exports=PrefetchDependency},71434:function(v,I,P){"use strict";const R=P(49790);const $=P(89959);const L=P(65317);const q=P(39460);const pathToString=v=>v!==null&&v.length>0?v.map((v=>`[${JSON.stringify(v)}]`)).join(""):"";class ProvidedDependency extends q{constructor(v,I,P,R){super(v);this.identifier=I;this.ids=P;this.range=R;this._hashUpdate=undefined}get type(){return"provided"}get category(){return"esm"}getReferencedExports(v,I){const P=this.ids;if(P.length===0)return R.EXPORTS_OBJECT_REFERENCED;return[P]}updateHash(v,I){if(this._hashUpdate===undefined){this._hashUpdate=this.identifier+(this.ids?this.ids.join(","):"")}v.update(this._hashUpdate)}serialize(v){const{write:I}=v;I(this.identifier);I(this.ids);super.serialize(v)}deserialize(v){const{read:I}=v;this.identifier=I();this.ids=I();super.deserialize(v)}}L(ProvidedDependency,"webpack/lib/dependencies/ProvidedDependency");class ProvidedDependencyTemplate extends q.Template{apply(v,I,{runtime:P,runtimeTemplate:R,moduleGraph:L,chunkGraph:q,initFragments:K,runtimeRequirements:ae}){const ge=v;const be=L.getConnection(ge);const xe=L.getExportsInfo(be.module);const ve=xe.getUsedName(ge.ids,P);K.push(new $(`/* provided dependency */ var ${ge.identifier} = ${R.moduleExports({module:L.getModule(ge),chunkGraph:q,request:ge.request,runtimeRequirements:ae})}${pathToString(ve)};\n`,$.STAGE_PROVIDES,1,`provided ${ge.identifier}`));I.replace(ge.range[0],ge.range[1]-1,ge.identifier)}}ProvidedDependency.Template=ProvidedDependencyTemplate;v.exports=ProvidedDependency},1706:function(v,I,P){"use strict";const{UsageState:R}=P(21311);const $=P(65317);const{filterRuntime:L,runtimeToString:q}=P(86620);const K=P(18941);class PureExpressionDependency extends K{constructor(v){super();this.range=v;this.usedByExports=false}_getRuntimeCondition(v,I){const P=this.usedByExports;if(P!==false){const $=v.getParentModule(this);const q=v.getExportsInfo($);const K=L(I,(v=>{for(const I of P){if(q.getUsed(I,v)!==R.Unused){return true}}return false}));return K}return false}updateHash(v,I){const P=this._getRuntimeCondition(I.chunkGraph.moduleGraph,I.runtime);if(P===true){return}else if(P===false){v.update("null")}else{v.update(`${q(P)}|${q(I.runtime)}`)}v.update(String(this.range))}getModuleEvaluationSideEffectsState(v){return false}serialize(v){const{write:I}=v;I(this.range);I(this.usedByExports);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();this.usedByExports=I();super.deserialize(v)}}$(PureExpressionDependency,"webpack/lib/dependencies/PureExpressionDependency");PureExpressionDependency.Template=class PureExpressionDependencyTemplate extends K.Template{apply(v,I,{chunkGraph:P,moduleGraph:R,runtime:$,runtimeTemplate:L,runtimeRequirements:q}){const K=v;const ae=K._getRuntimeCondition(R,$);if(ae===true){}else if(ae===false){I.insert(K.range[0],"(/* unused pure expression or super */ null && (");I.insert(K.range[1],"))")}else{const v=L.runtimeConditionExpression({chunkGraph:P,runtime:$,runtimeCondition:ae,runtimeRequirements:q});I.insert(K.range[0],`(/* runtime-dependent pure expression or super */ ${v} ? (`);I.insert(K.range[1],") : null)")}}};v.exports=PureExpressionDependency},74599:function(v,I,P){"use strict";const R=P(65317);const $=P(38768);const L=P(87264);class RequireContextDependency extends ${constructor(v,I){super(v);this.range=I}get type(){return"require.context"}}R(RequireContextDependency,"webpack/lib/dependencies/RequireContextDependency");RequireContextDependency.Template=L;v.exports=RequireContextDependency},47370:function(v,I,P){"use strict";const R=P(74599);v.exports=class RequireContextDependencyParserPlugin{apply(v){v.hooks.call.for("require.context").tap("RequireContextDependencyParserPlugin",(I=>{let P=/^\.\/.*$/;let $=true;let L="sync";switch(I.arguments.length){case 4:{const P=v.evaluateExpression(I.arguments[3]);if(!P.isString())return;L=P.string}case 3:{const R=v.evaluateExpression(I.arguments[2]);if(!R.isRegExp())return;P=R.regExp}case 2:{const P=v.evaluateExpression(I.arguments[1]);if(!P.isBoolean())return;$=P.bool}case 1:{const q=v.evaluateExpression(I.arguments[0]);if(!q.isString())return;const K=new R({request:q.string,recursive:$,regExp:P,mode:L,category:"commonjs"},I.range);K.loc=I.loc;K.optional=Boolean(v.scope.inTry);v.state.current.addDependency(K);return true}}}))}}},31782:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$}=P(6041);const{cachedSetProperty:L}=P(22298);const q=P(10573);const K=P(74599);const ae=P(47370);const ge={};const be="RequireContextPlugin";class RequireContextPlugin{apply(v){v.hooks.compilation.tap(be,((I,{contextModuleFactory:P,normalModuleFactory:xe})=>{I.dependencyFactories.set(K,P);I.dependencyTemplates.set(K,new K.Template);I.dependencyFactories.set(q,xe);const handler=(v,I)=>{if(I.requireContext!==undefined&&!I.requireContext)return;(new ae).apply(v)};xe.hooks.parser.for(R).tap(be,handler);xe.hooks.parser.for($).tap(be,handler);P.hooks.alternativeRequests.tap(be,((I,P)=>{if(I.length===0)return I;const R=v.resolverFactory.get("normal",L(P.resolveOptions||ge,"dependencyType",P.category)).options;let $;if(!R.fullySpecified){$=[];for(const v of I){const{request:I,context:P}=v;for(const v of R.extensions){if(I.endsWith(v)){$.push({context:P,request:I.slice(0,-v.length)})}}if(!R.enforceExtension){$.push(v)}}I=$;$=[];for(const v of I){const{request:I,context:P}=v;for(const v of R.mainFiles){if(I.endsWith(`/${v}`)){$.push({context:P,request:I.slice(0,-v.length)});$.push({context:P,request:I.slice(0,-v.length-1)})}}$.push(v)}I=$}$=[];for(const v of I){let I=false;for(const P of R.modules){if(Array.isArray(P)){for(const R of P){if(v.request.startsWith(`./${R}/`)){$.push({context:v.context,request:v.request.slice(R.length+3)});I=true}}}else{const I=P.replace(/\\/g,"/");const R=v.context.replace(/\\/g,"/")+v.request.slice(1);if(R.startsWith(I)){$.push({context:v.context,request:R.slice(I.length+1)})}}}if(!I){$.push(v)}}return $}))}))}}v.exports=RequireContextPlugin},62074:function(v,I,P){"use strict";const R=P(67927);const $=P(65317);class RequireEnsureDependenciesBlock extends R{constructor(v,I){super(v,I,null)}}$(RequireEnsureDependenciesBlock,"webpack/lib/dependencies/RequireEnsureDependenciesBlock");v.exports=RequireEnsureDependenciesBlock},60366:function(v,I,P){"use strict";const R=P(62074);const $=P(39756);const L=P(84420);const q=P(75363);v.exports=class RequireEnsureDependenciesBlockParserPlugin{apply(v){v.hooks.call.for("require.ensure").tap("RequireEnsureDependenciesBlockParserPlugin",(I=>{let P=null;let K=null;let ae=null;switch(I.arguments.length){case 4:{const R=v.evaluateExpression(I.arguments[3]);if(!R.isString())return;P=R.string}case 3:{K=I.arguments[2];ae=q(K);if(!ae&&!P){const R=v.evaluateExpression(I.arguments[2]);if(!R.isString())return;P=R.string}}case 2:{const ge=v.evaluateExpression(I.arguments[0]);const be=ge.isArray()?ge.items:[ge];const xe=I.arguments[1];const ve=q(xe);if(ve){v.walkExpressions(ve.expressions)}if(ae){v.walkExpressions(ae.expressions)}const Ce=new R(P,I.loc);const Ne=I.arguments.length===4||!P&&I.arguments.length===3;const He=new $(I.range,I.arguments[1].range,Ne&&I.arguments[2].range);He.loc=I.loc;Ce.addDependency(He);const Qe=v.state.current;v.state.current=Ce;try{let P=false;v.inScope([],(()=>{for(const v of be){if(v.isString()){const P=new L(v.string);P.loc=I.loc;Ce.addDependency(P)}else{P=true}}}));if(P){return}if(ve){if(ve.fn.body.type==="BlockStatement"){v.walkStatement(ve.fn.body)}else{v.walkExpression(ve.fn.body)}}Qe.addBlock(Ce)}finally{v.state.current=Qe}if(!ve){v.walkExpression(xe)}if(ae){if(ae.fn.body.type==="BlockStatement"){v.walkStatement(ae.fn.body)}else{v.walkExpression(ae.fn.body)}}else if(K){v.walkExpression(K)}return true}}}))}}},39756:function(v,I,P){"use strict";const R=P(5205);const $=P(65317);const L=P(18941);class RequireEnsureDependency extends L{constructor(v,I,P){super();this.range=v;this.contentRange=I;this.errorHandlerRange=P}get type(){return"require.ensure"}serialize(v){const{write:I}=v;I(this.range);I(this.contentRange);I(this.errorHandlerRange);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();this.contentRange=I();this.errorHandlerRange=I();super.deserialize(v)}}$(RequireEnsureDependency,"webpack/lib/dependencies/RequireEnsureDependency");RequireEnsureDependency.Template=class RequireEnsureDependencyTemplate extends L.Template{apply(v,I,{runtimeTemplate:P,moduleGraph:$,chunkGraph:L,runtimeRequirements:q}){const K=v;const ae=$.getParentBlock(K);const ge=P.blockPromise({chunkGraph:L,block:ae,message:"require.ensure",runtimeRequirements:q});const be=K.range;const xe=K.contentRange;const ve=K.errorHandlerRange;I.replace(be[0],xe[0]-1,`${ge}.then((`);if(ve){I.replace(xe[1],ve[0]-1,`).bind(null, ${R.require}))['catch'](`);I.replace(ve[1],be[1]-1,")")}else{I.replace(xe[1],be[1]-1,`).bind(null, ${R.require}))['catch'](${R.uncaughtErrorHandler})`)}}};v.exports=RequireEnsureDependency},84420:function(v,I,P){"use strict";const R=P(65317);const $=P(39460);const L=P(18941);class RequireEnsureItemDependency extends ${constructor(v){super(v)}get type(){return"require.ensure item"}get category(){return"commonjs"}}R(RequireEnsureItemDependency,"webpack/lib/dependencies/RequireEnsureItemDependency");RequireEnsureItemDependency.Template=L.Template;v.exports=RequireEnsureItemDependency},69987:function(v,I,P){"use strict";const R=P(39756);const $=P(84420);const L=P(60366);const{JAVASCRIPT_MODULE_TYPE_AUTO:q,JAVASCRIPT_MODULE_TYPE_DYNAMIC:K}=P(6041);const{evaluateToString:ae,toConstantDependency:ge}=P(59932);const be="RequireEnsurePlugin";class RequireEnsurePlugin{apply(v){v.hooks.compilation.tap(be,((v,{normalModuleFactory:I})=>{v.dependencyFactories.set($,I);v.dependencyTemplates.set($,new $.Template);v.dependencyTemplates.set(R,new R.Template);const handler=(v,I)=>{if(I.requireEnsure!==undefined&&!I.requireEnsure)return;(new L).apply(v);v.hooks.evaluateTypeof.for("require.ensure").tap(be,ae("function"));v.hooks.typeof.for("require.ensure").tap(be,ge(v,JSON.stringify("function")))};I.hooks.parser.for(q).tap(be,handler);I.hooks.parser.for(K).tap(be,handler)}))}}v.exports=RequireEnsurePlugin},22740:function(v,I,P){"use strict";const R=P(5205);const $=P(65317);const L=P(18941);class RequireHeaderDependency extends L{constructor(v){super();if(!Array.isArray(v))throw new Error("range must be valid");this.range=v}serialize(v){const{write:I}=v;I(this.range);super.serialize(v)}static deserialize(v){const I=new RequireHeaderDependency(v.read());I.deserialize(v);return I}}$(RequireHeaderDependency,"webpack/lib/dependencies/RequireHeaderDependency");RequireHeaderDependency.Template=class RequireHeaderDependencyTemplate extends L.Template{apply(v,I,{runtimeRequirements:P}){const $=v;P.add(R.require);I.replace($.range[0],$.range[1]-1,R.require)}};v.exports=RequireHeaderDependency},9587:function(v,I,P){"use strict";const R=P(49790);const $=P(57227);const L=P(65317);const q=P(39460);class RequireIncludeDependency extends q{constructor(v,I){super(v);this.range=I}getReferencedExports(v,I){return R.NO_EXPORTS_REFERENCED}get type(){return"require.include"}get category(){return"commonjs"}}L(RequireIncludeDependency,"webpack/lib/dependencies/RequireIncludeDependency");RequireIncludeDependency.Template=class RequireIncludeDependencyTemplate extends q.Template{apply(v,I,{runtimeTemplate:P}){const R=v;const L=P.outputOptions.pathinfo?$.toComment(`require.include ${P.requestShortener.shorten(R.request)}`):"";I.replace(R.range[0],R.range[1]-1,`undefined${L}`)}};v.exports=RequireIncludeDependency},35698:function(v,I,P){"use strict";const R=P(94252);const{evaluateToString:$,toConstantDependency:L}=P(59932);const q=P(65317);const K=P(9587);v.exports=class RequireIncludeDependencyParserPlugin{constructor(v){this.warn=v}apply(v){const{warn:I}=this;v.hooks.call.for("require.include").tap("RequireIncludeDependencyParserPlugin",(P=>{if(P.arguments.length!==1)return;const R=v.evaluateExpression(P.arguments[0]);if(!R.isString())return;if(I){v.state.module.addWarning(new RequireIncludeDeprecationWarning(P.loc))}const $=new K(R.string,P.range);$.loc=P.loc;v.state.current.addDependency($);return true}));v.hooks.evaluateTypeof.for("require.include").tap("RequireIncludePlugin",(P=>{if(I){v.state.module.addWarning(new RequireIncludeDeprecationWarning(P.loc))}return $("function")(P)}));v.hooks.typeof.for("require.include").tap("RequireIncludePlugin",(P=>{if(I){v.state.module.addWarning(new RequireIncludeDeprecationWarning(P.loc))}return L(v,JSON.stringify("function"))(P)}))}};class RequireIncludeDeprecationWarning extends R{constructor(v){super("require.include() is deprecated and will be removed soon.");this.name="RequireIncludeDeprecationWarning";this.loc=v}}q(RequireIncludeDeprecationWarning,"webpack/lib/dependencies/RequireIncludeDependencyParserPlugin","RequireIncludeDeprecationWarning")},90325:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$}=P(6041);const L=P(9587);const q=P(35698);const K="RequireIncludePlugin";class RequireIncludePlugin{apply(v){v.hooks.compilation.tap(K,((v,{normalModuleFactory:I})=>{v.dependencyFactories.set(L,I);v.dependencyTemplates.set(L,new L.Template);const handler=(v,I)=>{if(I.requireInclude===false)return;const P=I.requireInclude===undefined;new q(P).apply(v)};I.hooks.parser.for(R).tap(K,handler);I.hooks.parser.for($).tap(K,handler)}))}}v.exports=RequireIncludePlugin},85499:function(v,I,P){"use strict";const R=P(65317);const $=P(38768);const L=P(36363);class RequireResolveContextDependency extends ${constructor(v,I,P,R){super(v,R);this.range=I;this.valueRange=P}get type(){return"amd require context"}serialize(v){const{write:I}=v;I(this.range);I(this.valueRange);super.serialize(v)}deserialize(v){const{read:I}=v;this.range=I();this.valueRange=I();super.deserialize(v)}}R(RequireResolveContextDependency,"webpack/lib/dependencies/RequireResolveContextDependency");RequireResolveContextDependency.Template=L;v.exports=RequireResolveContextDependency},77964:function(v,I,P){"use strict";const R=P(49790);const $=P(65317);const L=P(39460);const q=P(73706);class RequireResolveDependency extends L{constructor(v,I,P){super(v);this.range=I;this._context=P}get type(){return"require.resolve"}get category(){return"commonjs"}getReferencedExports(v,I){return R.NO_EXPORTS_REFERENCED}}$(RequireResolveDependency,"webpack/lib/dependencies/RequireResolveDependency");RequireResolveDependency.Template=q;v.exports=RequireResolveDependency},16138:function(v,I,P){"use strict";const R=P(65317);const $=P(18941);class RequireResolveHeaderDependency extends ${constructor(v){super();if(!Array.isArray(v))throw new Error("range must be valid");this.range=v}serialize(v){const{write:I}=v;I(this.range);super.serialize(v)}static deserialize(v){const I=new RequireResolveHeaderDependency(v.read());I.deserialize(v);return I}}R(RequireResolveHeaderDependency,"webpack/lib/dependencies/RequireResolveHeaderDependency");RequireResolveHeaderDependency.Template=class RequireResolveHeaderDependencyTemplate extends $.Template{apply(v,I,P){const R=v;I.replace(R.range[0],R.range[1]-1,"/*require.resolve*/")}applyAsTemplateArgument(v,I,P){P.replace(I.range[0],I.range[1]-1,"/*require.resolve*/")}};v.exports=RequireResolveHeaderDependency},56711:function(v,I,P){"use strict";const R=P(65317);const $=P(18941);class RuntimeRequirementsDependency extends ${constructor(v){super();this.runtimeRequirements=new Set(v);this._hashUpdate=undefined}updateHash(v,I){if(this._hashUpdate===undefined){this._hashUpdate=`${Array.from(this.runtimeRequirements).join()}`}v.update(this._hashUpdate)}serialize(v){const{write:I}=v;I(this.runtimeRequirements);super.serialize(v)}deserialize(v){const{read:I}=v;this.runtimeRequirements=I();super.deserialize(v)}}R(RuntimeRequirementsDependency,"webpack/lib/dependencies/RuntimeRequirementsDependency");RuntimeRequirementsDependency.Template=class RuntimeRequirementsDependencyTemplate extends $.Template{apply(v,I,{runtimeRequirements:P}){const R=v;for(const v of R.runtimeRequirements){P.add(v)}}};v.exports=RuntimeRequirementsDependency},92296:function(v,I,P){"use strict";const R=P(65317);const $=P(18941);class StaticExportsDependency extends ${constructor(v,I){super();this.exports=v;this.canMangle=I}get type(){return"static exports"}getExports(v){return{exports:this.exports,canMangle:this.canMangle,dependencies:undefined}}serialize(v){const{write:I}=v;I(this.exports);I(this.canMangle);super.serialize(v)}deserialize(v){const{read:I}=v;this.exports=I();this.canMangle=I();super.deserialize(v)}}R(StaticExportsDependency,"webpack/lib/dependencies/StaticExportsDependency");v.exports=StaticExportsDependency},39648:function(v,I,P){"use strict";const{JAVASCRIPT_MODULE_TYPE_AUTO:R,JAVASCRIPT_MODULE_TYPE_DYNAMIC:$}=P(6041);const L=P(5205);const q=P(94252);const{evaluateToString:K,expressionIsUnsupported:ae,toConstantDependency:ge}=P(59932);const be=P(65317);const xe=P(34022);const ve=P(49021);const Ce="SystemPlugin";class SystemPlugin{apply(v){v.hooks.compilation.tap(Ce,((v,{normalModuleFactory:I})=>{v.hooks.runtimeRequirementInModule.for(L.system).tap(Ce,((v,I)=>{I.add(L.requireScope)}));v.hooks.runtimeRequirementInTree.for(L.system).tap(Ce,((I,P)=>{v.addRuntimeModule(I,new ve)}));const handler=(v,I)=>{if(I.system===undefined||!I.system){return}const setNotSupported=I=>{v.hooks.evaluateTypeof.for(I).tap(Ce,K("undefined"));v.hooks.expression.for(I).tap(Ce,ae(v,`${I} is not supported by webpack.`))};v.hooks.typeof.for("System.import").tap(Ce,ge(v,JSON.stringify("function")));v.hooks.evaluateTypeof.for("System.import").tap(Ce,K("function"));v.hooks.typeof.for("System").tap(Ce,ge(v,JSON.stringify("object")));v.hooks.evaluateTypeof.for("System").tap(Ce,K("object"));setNotSupported("System.set");setNotSupported("System.get");setNotSupported("System.register");v.hooks.expression.for("System").tap(Ce,(I=>{const P=new xe(L.system,I.range,[L.system]);P.loc=I.loc;v.state.module.addPresentationalDependency(P);return true}));v.hooks.call.for("System.import").tap(Ce,(I=>{v.state.module.addWarning(new SystemImportDeprecationWarning(I.loc));return v.hooks.importCall.call({type:"ImportExpression",source:I.arguments[0],loc:I.loc,range:I.range,options:null})}))};I.hooks.parser.for(R).tap(Ce,handler);I.hooks.parser.for($).tap(Ce,handler)}))}}class SystemImportDeprecationWarning extends q{constructor(v){super("System.import() is deprecated and will be removed soon. Use import() instead.\n"+"For more info visit https://webpack.js.org/guides/code-splitting/");this.name="SystemImportDeprecationWarning";this.loc=v}}be(SystemImportDeprecationWarning,"webpack/lib/dependencies/SystemPlugin","SystemImportDeprecationWarning");v.exports=SystemPlugin;v.exports.SystemImportDeprecationWarning=SystemImportDeprecationWarning},49021:function(v,I,P){"use strict";const R=P(5205);const $=P(78994);const L=P(57227);class SystemRuntimeModule extends ${constructor(){super("system")}generate(){return L.asString([`${R.system} = {`,L.indent(["import: function () {",L.indent("throw new Error('System.import cannot be used indirectly');"),"}"]),"};"])}}v.exports=SystemRuntimeModule},39544:function(v,I,P){"use strict";const R=P(5205);const $=P(18966);const{getDependencyUsedByExportsCondition:L}=P(9696);const q=P(65317);const K=P(13594);const ae=P(39460);const ge=K((()=>new $("data:,","ignored-asset","(ignored asset)")));class URLDependency extends ae{constructor(v,I,P,R){super(v);this.range=I;this.outerRange=P;this.relative=R||false;this.usedByExports=undefined}get type(){return"new URL()"}get category(){return"url"}getCondition(v){return L(this,this.usedByExports,v)}createIgnoredModule(v){return ge()}serialize(v){const{write:I}=v;I(this.outerRange);I(this.relative);I(this.usedByExports);super.serialize(v)}deserialize(v){const{read:I}=v;this.outerRange=I();this.relative=I();this.usedByExports=I();super.deserialize(v)}}URLDependency.Template=class URLDependencyTemplate extends ae.Template{apply(v,I,P){const{chunkGraph:$,moduleGraph:L,runtimeRequirements:q,runtimeTemplate:K,runtime:ae}=P;const ge=v;const be=L.getConnection(ge);if(be&&!be.isTargetActive(ae)){I.replace(ge.outerRange[0],ge.outerRange[1]-1,"/* unused asset import */ undefined");return}q.add(R.require);if(ge.relative){q.add(R.relativeUrl);I.replace(ge.outerRange[0],ge.outerRange[1]-1,`/* asset import */ new ${R.relativeUrl}(${K.moduleRaw({chunkGraph:$,module:L.getModule(ge),request:ge.request,runtimeRequirements:q,weak:false})})`)}else{q.add(R.baseURI);I.replace(ge.range[0],ge.range[1]-1,`/* asset import */ ${K.moduleRaw({chunkGraph:$,module:L.getModule(ge),request:ge.request,runtimeRequirements:q,weak:false})}, ${R.baseURI}`)}}};q(URLDependency,"webpack/lib/dependencies/URLDependency");v.exports=URLDependency},65954:function(v,I,P){"use strict";const{pathToFileURL:R}=P(57310);const $=P(14102);const{JAVASCRIPT_MODULE_TYPE_AUTO:L,JAVASCRIPT_MODULE_TYPE_ESM:q}=P(6041);const K=P(5205);const ae=P(53966);const ge=P(28665);const{approve:be}=P(59932);const xe=P(9696);const ve=P(34022);const Ce=P(39544);const Ne="URLPlugin";class URLPlugin{apply(v){v.hooks.compilation.tap(Ne,((v,{normalModuleFactory:I})=>{v.dependencyFactories.set(Ce,I);v.dependencyTemplates.set(Ce,new Ce.Template);const getUrl=v=>R(v.resource);const isMetaUrl=(v,I)=>{const P=v.extractMemberExpressionChain(I);if(P.members.length!==1||P.object.type!=="MetaProperty"||P.object.meta.name!=="import"||P.object.property.name!=="meta"||P.members[0]!=="url")return false;return true};const parserCallback=(v,I)=>{if(I.url===false)return;const P=I.url==="relative";const getUrlRequest=I=>{if(I.arguments.length!==2)return;const[P,R]=I.arguments;if(R.type!=="MemberExpression"||P.type==="SpreadElement")return;if(!isMetaUrl(v,R))return;return v.evaluateExpression(P).asString()};v.hooks.canRename.for("URL").tap(Ne,be);v.hooks.evaluateNewExpression.for("URL").tap(Ne,(I=>{const P=getUrlRequest(I);if(!P)return;const R=new URL(P,getUrl(v.state.module));return(new ge).setString(R.toString()).setRange(I.range)}));v.hooks.new.for("URL").tap(Ne,(I=>{const R=I;const{options:L,errors:q}=v.parseCommentOptions(R.range);if(q){for(const I of q){const{comment:P}=I;v.state.module.addWarning(new $(`Compilation error while processing magic comment(-s): /*${P.value}*/: ${I.message}`,P.loc))}}if(L&&L.webpackIgnore!==undefined){if(typeof L.webpackIgnore!=="boolean"){v.state.module.addWarning(new ae(`\`webpackIgnore\` expected a boolean, but received: ${L.webpackIgnore}.`,R.loc));return}else if(L.webpackIgnore){if(R.arguments.length!==2)return;const[,I]=R.arguments;if(I.type!=="MemberExpression"||!isMetaUrl(v,I))return;const P=new ve(K.baseURI,I.range,[K.baseURI]);P.loc=R.loc;v.state.module.addPresentationalDependency(P);return true}}const ge=getUrlRequest(R);if(!ge)return;const[be,Ne]=R.arguments;const He=new Ce(ge,[be.range[0],Ne.range[1]],R.range,P);He.loc=R.loc;v.state.current.addDependency(He);xe.onUsage(v.state,(v=>He.usedByExports=v));return true}));v.hooks.isPure.for("NewExpression").tap(Ne,(I=>{const P=I;const{callee:R}=P;if(R.type!=="Identifier")return;const $=v.getFreeInfoFromVariable(R.name);if(!$||$.name!=="URL")return;const L=getUrlRequest(P);if(L)return true}))};I.hooks.parser.for(L).tap(Ne,parserCallback);I.hooks.parser.for(q).tap(Ne,parserCallback)}))}}v.exports=URLPlugin},58793:function(v,I,P){"use strict";const R=P(65317);const $=P(18941);class UnsupportedDependency extends ${constructor(v,I){super();this.request=v;this.range=I}serialize(v){const{write:I}=v;I(this.request);I(this.range);super.serialize(v)}deserialize(v){const{read:I}=v;this.request=I();this.range=I();super.deserialize(v)}}R(UnsupportedDependency,"webpack/lib/dependencies/UnsupportedDependency");UnsupportedDependency.Template=class UnsupportedDependencyTemplate extends $.Template{apply(v,I,{runtimeTemplate:P}){const R=v;I.replace(R.range[0],R.range[1],P.missingModule({request:R.request}))}};v.exports=UnsupportedDependency},10676:function(v,I,P){"use strict";const R=P(49790);const $=P(65317);const L=P(39460);class WebAssemblyExportImportedDependency extends L{constructor(v,I,P,R){super(I);this.exportName=v;this.name=P;this.valueType=R}couldAffectReferencingModule(){return R.TRANSITIVE}getReferencedExports(v,I){return[[this.name]]}get type(){return"wasm export import"}get category(){return"wasm"}serialize(v){const{write:I}=v;I(this.exportName);I(this.name);I(this.valueType);super.serialize(v)}deserialize(v){const{read:I}=v;this.exportName=I();this.name=I();this.valueType=I();super.deserialize(v)}}$(WebAssemblyExportImportedDependency,"webpack/lib/dependencies/WebAssemblyExportImportedDependency");v.exports=WebAssemblyExportImportedDependency},54308:function(v,I,P){"use strict";const R=P(65317);const $=P(98116);const L=P(39460);class WebAssemblyImportDependency extends L{constructor(v,I,P,R){super(v);this.name=I;this.description=P;this.onlyDirectImport=R}get type(){return"wasm import"}get category(){return"wasm"}getReferencedExports(v,I){return[[this.name]]}getErrors(v){const I=v.getModule(this);if(this.onlyDirectImport&&I&&!I.type.startsWith("webassembly")){return[new $(`Import "${this.name}" from "${this.request}" with ${this.onlyDirectImport} can only be used for direct wasm to wasm dependencies`)]}}serialize(v){const{write:I}=v;I(this.name);I(this.description);I(this.onlyDirectImport);super.serialize(v)}deserialize(v){const{read:I}=v;this.name=I();this.description=I();this.onlyDirectImport=I();super.deserialize(v)}}R(WebAssemblyImportDependency,"webpack/lib/dependencies/WebAssemblyImportDependency");v.exports=WebAssemblyImportDependency},33170:function(v,I,P){"use strict";const R=P(49790);const $=P(57227);const L=P(65317);const q=P(39460);class WebpackIsIncludedDependency extends q{constructor(v,I){super(v);this.weak=true;this.range=I}getReferencedExports(v,I){return R.NO_EXPORTS_REFERENCED}get type(){return"__webpack_is_included__"}}L(WebpackIsIncludedDependency,"webpack/lib/dependencies/WebpackIsIncludedDependency");WebpackIsIncludedDependency.Template=class WebpackIsIncludedDependencyTemplate extends q.Template{apply(v,I,{runtimeTemplate:P,chunkGraph:R,moduleGraph:L}){const q=v;const K=L.getConnection(q);const ae=K?R.getNumberOfModuleChunks(K.module)>0:false;const ge=P.outputOptions.pathinfo?$.toComment(`__webpack_is_included__ ${P.requestShortener.shorten(q.request)}`):"";I.replace(q.range[0],q.range[1]-1,`${ge}${JSON.stringify(ae)}`)}};v.exports=WebpackIsIncludedDependency},831:function(v,I,P){"use strict";const R=P(49790);const $=P(5205);const L=P(65317);const q=P(39460);class WorkerDependency extends q{constructor(v,I,P){super(v);this.range=I;this.options=P;this._hashUpdate=undefined}getReferencedExports(v,I){return R.NO_EXPORTS_REFERENCED}get type(){return"new Worker()"}get category(){return"worker"}updateHash(v,I){if(this._hashUpdate===undefined){this._hashUpdate=JSON.stringify(this.options)}v.update(this._hashUpdate)}serialize(v){const{write:I}=v;I(this.options);super.serialize(v)}deserialize(v){const{read:I}=v;this.options=I();super.deserialize(v)}}WorkerDependency.Template=class WorkerDependencyTemplate extends q.Template{apply(v,I,P){const{chunkGraph:R,moduleGraph:L,runtimeRequirements:q}=P;const K=v;const ae=L.getParentBlock(v);const ge=R.getBlockChunkGroup(ae);const be=ge.getEntrypointChunk();const xe=K.options.publicPath?`"${K.options.publicPath}"`:$.publicPath;q.add($.publicPath);q.add($.baseURI);q.add($.getChunkScriptFilename);I.replace(K.range[0],K.range[1]-1,`/* worker import */ ${xe} + ${$.getChunkScriptFilename}(${JSON.stringify(be.id)}), ${$.baseURI}`)}};L(WorkerDependency,"webpack/lib/dependencies/WorkerDependency");v.exports=WorkerDependency},10160:function(v,I,P){"use strict";const{pathToFileURL:R}=P(57310);const $=P(67927);const L=P(14102);const{JAVASCRIPT_MODULE_TYPE_AUTO:q,JAVASCRIPT_MODULE_TYPE_ESM:K}=P(6041);const ae=P(53966);const ge=P(19353);const{equals:be}=P(29179);const xe=P(12471);const{contextify:ve}=P(46579);const Ce=P(13872);const Ne=P(34022);const He=P(33369);const{harmonySpecifierTag:Qe}=P(98994);const Je=P(831);const getUrl=v=>R(v.resource).toString();const Ve=Symbol("worker specifier tag");const Ke=["Worker","SharedWorker","navigator.serviceWorker.register()","Worker from worker_threads"];const Ye=new WeakMap;const Xe="WorkerPlugin";class WorkerPlugin{constructor(v,I,P,R){this._chunkLoading=v;this._wasmLoading=I;this._module=P;this._workerPublicPath=R}apply(v){if(this._chunkLoading){new ge(this._chunkLoading).apply(v)}if(this._wasmLoading){new Ce(this._wasmLoading).apply(v)}const I=ve.bindContextCache(v.context,v.root);v.hooks.thisCompilation.tap(Xe,((v,{normalModuleFactory:P})=>{v.dependencyFactories.set(Je,P);v.dependencyTemplates.set(Je,new Je.Template);v.dependencyTemplates.set(He,new He.Template);const parseModuleUrl=(v,I)=>{if(I.type!=="NewExpression"||I.callee.type==="Super"||I.arguments.length!==2)return;const[P,R]=I.arguments;if(P.type==="SpreadElement")return;if(R.type==="SpreadElement")return;const $=v.evaluateExpression(I.callee);if(!$.isIdentifier()||$.identifier!=="URL")return;const L=v.evaluateExpression(R);if(!L.isString()||!L.string.startsWith("file://")||L.string!==getUrl(v.state.module)){return}const q=v.evaluateExpression(P);return[q,[P.range[0],R.range[1]]]};const parseObjectExpression=(v,I)=>{const P={};const R={};const $=[];let L=false;for(const q of I.properties){if(q.type==="SpreadElement"){L=true}else if(q.type==="Property"&&!q.method&&!q.computed&&q.key.type==="Identifier"){R[q.key.name]=q.value;if(!q.shorthand&&!q.value.type.endsWith("Pattern")){const I=v.evaluateExpression(q.value);if(I.isCompileTimeValue())P[q.key.name]=I.asCompileTimeValue()}}else{$.push(q)}}const q=I.properties.length>0?"comma":"single";const K=I.properties[I.properties.length-1].range[1];return{expressions:R,otherElements:$,values:P,spread:L,insertType:q,insertLocation:K}};const parserPlugin=(P,R)=>{if(R.worker===false)return;const q=!Array.isArray(R.worker)?["..."]:R.worker;const handleNewWorker=R=>{if(R.arguments.length===0||R.arguments.length>2)return;const[q,K]=R.arguments;if(q.type==="SpreadElement")return;if(K&&K.type==="SpreadElement")return;const ge=parseModuleUrl(P,q);if(!ge)return;const[be,ve]=ge;if(!be.isString())return;const{expressions:Ce,otherElements:Qe,values:Ve,spread:Ke,insertType:Xe,insertLocation:Ze}=K&&K.type==="ObjectExpression"?parseObjectExpression(P,K):{expressions:{},otherElements:[],values:{},spread:false,insertType:K?"spread":"argument",insertLocation:K?K.range:q.range[1]};const{options:et,errors:tt}=P.parseCommentOptions(R.range);if(tt){for(const v of tt){const{comment:I}=v;P.state.module.addWarning(new L(`Compilation error while processing magic comment(-s): /*${I.value}*/: ${v.message}`,I.loc))}}const nt={};if(et){if(et.webpackIgnore!==undefined){if(typeof et.webpackIgnore!=="boolean"){P.state.module.addWarning(new ae(`\`webpackIgnore\` expected a boolean, but received: ${et.webpackIgnore}.`,R.loc))}else if(et.webpackIgnore){return false}}if(et.webpackEntryOptions!==undefined){if(typeof et.webpackEntryOptions!=="object"||et.webpackEntryOptions===null){P.state.module.addWarning(new ae(`\`webpackEntryOptions\` expected a object, but received: ${et.webpackEntryOptions}.`,R.loc))}else{Object.assign(nt,et.webpackEntryOptions)}}if(et.webpackChunkName!==undefined){if(typeof et.webpackChunkName!=="string"){P.state.module.addWarning(new ae(`\`webpackChunkName\` expected a string, but received: ${et.webpackChunkName}.`,R.loc))}else{nt.name=et.webpackChunkName}}}if(!Object.prototype.hasOwnProperty.call(nt,"name")&&Ve&&typeof Ve.name==="string"){nt.name=Ve.name}if(nt.runtime===undefined){const R=Ye.get(P.state)||0;Ye.set(P.state,R+1);const $=`${I(P.state.module.identifier())}|${R}`;const L=xe(v.outputOptions.hashFunction);L.update($);const q=L.digest(v.outputOptions.hashDigest);nt.runtime=q.slice(0,v.outputOptions.hashDigestLength)}const st=new $({name:nt.name,entryOptions:{chunkLoading:this._chunkLoading,wasmLoading:this._wasmLoading,...nt}});st.loc=R.loc;const rt=new Je(be.string,ve,{publicPath:this._workerPublicPath});rt.loc=R.loc;st.addDependency(rt);P.state.module.addBlock(st);if(v.outputOptions.trustedTypes){const v=new He(R.arguments[0].range);v.loc=R.loc;P.state.module.addDependency(v)}if(Ce.type){const v=Ce.type;if(Ve.type!==false){const I=new Ne(this._module?'"module"':"undefined",v.range);I.loc=v.loc;P.state.module.addPresentationalDependency(I);Ce.type=undefined}}else if(Xe==="comma"){if(this._module||Ke){const v=new Ne(`, type: ${this._module?'"module"':"undefined"}`,Ze);v.loc=R.loc;P.state.module.addPresentationalDependency(v)}}else if(Xe==="spread"){const v=new Ne("Object.assign({}, ",Ze[0]);const I=new Ne(`, { type: ${this._module?'"module"':"undefined"} })`,Ze[1]);v.loc=R.loc;I.loc=R.loc;P.state.module.addPresentationalDependency(v);P.state.module.addPresentationalDependency(I)}else if(Xe==="argument"&&this._module){const v=new Ne(', { type: "module" }',Ze);v.loc=R.loc;P.state.module.addPresentationalDependency(v)}P.walkExpression(R.callee);for(const v of Object.keys(Ce)){if(Ce[v])P.walkExpression(Ce[v])}for(const v of Qe){P.walkProperty(v)}if(Xe==="spread"){P.walkExpression(K)}return true};const processItem=v=>{if(v.startsWith("*")&&v.includes(".")&&v.endsWith("()")){const I=v.indexOf(".");const R=v.slice(1,I);const $=v.slice(I+1,-2);P.hooks.preDeclarator.tap(Xe,((v,I)=>{if(v.id.type==="Identifier"&&v.id.name===R){P.tagVariable(v.id.name,Ve);return true}}));P.hooks.pattern.for(R).tap(Xe,(v=>{P.tagVariable(v.name,Ve);return true}));P.hooks.callMemberChain.for(Ve).tap(Xe,((v,I)=>{if($!==I.join(".")){return}return handleNewWorker(v)}))}else if(v.endsWith("()")){P.hooks.call.for(v.slice(0,-2)).tap(Xe,handleNewWorker)}else{const I=/^(.+?)(\(\))?\s+from\s+(.+)$/.exec(v);if(I){const v=I[1].split(".");const R=I[2];const $=I[3];(R?P.hooks.call:P.hooks.new).for(Qe).tap(Xe,(I=>{const R=P.currentTagData;if(!R||R.source!==$||!be(R.ids,v)){return}return handleNewWorker(I)}))}else{P.hooks.new.for(v).tap(Xe,handleNewWorker)}}};for(const v of q){if(v==="..."){for(const v of Ke){processItem(v)}}else processItem(v)}};P.hooks.parser.for(q).tap(Xe,parserPlugin);P.hooks.parser.for(K).tap(Xe,parserPlugin)}))}}v.exports=WorkerPlugin},75363:function(v){"use strict";v.exports=v=>{if(v.type==="FunctionExpression"||v.type==="ArrowFunctionExpression"){return{fn:v,expressions:[],needThis:false}}if(v.type==="CallExpression"&&v.callee.type==="MemberExpression"&&v.callee.object.type==="FunctionExpression"&&v.callee.property.type==="Identifier"&&v.callee.property.name==="bind"&&v.arguments.length===1){return{fn:v.callee.object,expressions:[v.arguments[0]],needThis:undefined}}if(v.type==="CallExpression"&&v.callee.type==="FunctionExpression"&&v.callee.body.type==="BlockStatement"&&v.arguments.length===1&&v.arguments[0].type==="ThisExpression"&&v.callee.body.body&&v.callee.body.body.length===1&&v.callee.body.body[0].type==="ReturnStatement"&&v.callee.body.body[0].argument&&v.callee.body.body[0].argument.type==="FunctionExpression"){return{fn:v.callee.body.body[0].argument,expressions:[],needThis:true}}}},8655:function(v,I,P){"use strict";const{UsageState:R}=P(21311);const processExportInfo=(v,I,P,$,L=false,q=new Set)=>{if(!$){I.push(P);return}const K=$.getUsed(v);if(K===R.Unused)return;if(q.has($)){I.push(P);return}q.add($);if(K!==R.OnlyPropertiesUsed||!$.exportsInfo||$.exportsInfo.otherExportsInfo.getUsed(v)!==R.Unused){q.delete($);I.push(P);return}const ae=$.exportsInfo;for(const R of ae.orderedExports){processExportInfo(v,I,L&&R.name==="default"?P:P.concat(R.name),R,false,q)}q.delete($)};v.exports=processExportInfo},17191:function(v,I,P){"use strict";const R=P(52925);class ElectronTargetPlugin{constructor(v){this._context=v}apply(v){new R("node-commonjs",["clipboard","crash-reporter","electron","ipc","native-image","original-fs","screen","shell"]).apply(v);switch(this._context){case"main":new R("node-commonjs",["app","auto-updater","browser-window","content-tracing","dialog","global-shortcut","ipc-main","menu","menu-item","power-monitor","power-save-blocker","protocol","session","tray","web-contents"]).apply(v);break;case"preload":case"renderer":new R("node-commonjs",["desktop-capturer","ipc-renderer","remote","web-frame"]).apply(v);break}}}v.exports=ElectronTargetPlugin},43459:function(v,I,P){"use strict";const R=P(94252);class BuildCycleError extends R{constructor(v){super("There is a circular build dependency, which makes it impossible to create this module");this.name="BuildCycleError";this.module=v}}v.exports=BuildCycleError},18625:function(v,I,P){"use strict";const R=P(5205);const $=P(78994);class ExportWebpackRequireRuntimeModule extends ${constructor(){super("export webpack runtime",$.STAGE_ATTACH)}shouldIsolate(){return false}generate(){return`export default ${R.require};`}}v.exports=ExportWebpackRequireRuntimeModule},3636:function(v,I,P){"use strict";const{ConcatSource:R}=P(51255);const{RuntimeGlobals:$}=P(24378);const L=P(59336);const q=P(57227);const{getAllChunks:K}=P(52326);const{chunkHasJs:ae,getCompilationHooks:ge,getChunkFilenameTemplate:be}=P(36926);const{updateHashForEntryStartup:xe}=P(46511);const{getUndoPath:ve}=P(46579);class ModuleChunkFormatPlugin{apply(v){v.hooks.thisCompilation.tap("ModuleChunkFormatPlugin",(v=>{v.hooks.additionalChunkRuntimeRequirements.tap("ModuleChunkFormatPlugin",((I,P)=>{if(I.hasRuntime())return;if(v.chunkGraph.getNumberOfEntryModules(I)>0){P.add($.require);P.add($.startupEntrypoint);P.add($.externalInstallChunk)}}));const I=ge(v);I.renderChunk.tap("ModuleChunkFormatPlugin",((P,ge)=>{const{chunk:xe,chunkGraph:Ce,runtimeTemplate:Ne}=ge;const He=xe instanceof L?xe:null;const Qe=new R;if(He){throw new Error("HMR is not implemented for module chunk format yet")}else{Qe.add(`export const __webpack_id__ = ${JSON.stringify(xe.id)};\n`);Qe.add(`export const __webpack_ids__ = ${JSON.stringify(xe.ids)};\n`);Qe.add("export const __webpack_modules__ = ");Qe.add(P);Qe.add(";\n");const L=Ce.getChunkRuntimeModulesInOrder(xe);if(L.length>0){Qe.add("export const __webpack_runtime__ =\n");Qe.add(q.renderChunkRuntimeModules(L,ge))}const He=Array.from(Ce.getChunkEntryModulesWithChunkGroupIterable(xe));if(He.length>0){const P=He[0][1].getRuntimeChunk();const L=v.getPath(be(xe,v.outputOptions),{chunk:xe,contentHashType:"javascript"}).replace(/^\/+/g,"").split("/");const getRelativePath=I=>{const P=L.slice();const R=v.getPath(be(I,v.outputOptions),{chunk:I,contentHashType:"javascript"}).replace(/^\/+/g,"").split("/");while(P.length>1&&R.length>1&&P[0]===R[0]){P.shift();R.shift()}const $=R.join("/");return ve(P.join("/"),$,true)+$};const q=new R;q.add(Qe);q.add(";\n\n// load runtime\n");q.add(`import ${$.require} from ${JSON.stringify(getRelativePath(P))};\n`);const Je=new R;Je.add(`var __webpack_exec__ = ${Ne.returningFunction(`${$.require}(${$.entryModuleId} = moduleId)`,"moduleId")}\n`);const Ve=new Set;let Ke=0;for(let v=0;v<He.length;v++){const[I,R]=He[v];const L=v+1===He.length;const q=Ce.getModuleId(I);const ge=K(R,P,undefined);for(const v of ge){if(Ve.has(v)||!ae(v,Ce))continue;Ve.add(v);Je.add(`import * as __webpack_chunk_${Ke}__ from ${JSON.stringify(getRelativePath(v))};\n`);Je.add(`${$.externalInstallChunk}(__webpack_chunk_${Ke}__);\n`);Ke++}Je.add(`${L?`var ${$.exports} = `:""}__webpack_exec__(${JSON.stringify(q)});\n`)}q.add(I.renderStartup.call(Je,He[He.length-1][0],{...ge,inlined:false}));return q}}return Qe}));I.chunkHash.tap("ModuleChunkFormatPlugin",((v,I,{chunkGraph:P,runtimeTemplate:R})=>{if(v.hasRuntime())return;I.update("ModuleChunkFormatPlugin");I.update("1");const $=Array.from(P.getChunkEntryModulesWithChunkGroupIterable(v));xe(I,P,$,v)}))}))}}v.exports=ModuleChunkFormatPlugin},44329:function(v,I,P){"use strict";const R=P(5205);const $=P(18625);const L=P(21821);class ModuleChunkLoadingPlugin{apply(v){v.hooks.thisCompilation.tap("ModuleChunkLoadingPlugin",(v=>{const I=v.outputOptions.chunkLoading;const isEnabledForChunk=v=>{const P=v.getEntryOptions();const R=P&&P.chunkLoading!==undefined?P.chunkLoading:I;return R==="import"};const P=new WeakSet;const handler=(I,$)=>{if(P.has(I))return;P.add(I);if(!isEnabledForChunk(I))return;$.add(R.moduleFactoriesAddOnly);$.add(R.hasOwnProperty);v.addRuntimeModule(I,new L($))};v.hooks.runtimeRequirementInTree.for(R.ensureChunkHandlers).tap("ModuleChunkLoadingPlugin",handler);v.hooks.runtimeRequirementInTree.for(R.baseURI).tap("ModuleChunkLoadingPlugin",handler);v.hooks.runtimeRequirementInTree.for(R.externalInstallChunk).tap("ModuleChunkLoadingPlugin",handler);v.hooks.runtimeRequirementInTree.for(R.onChunksLoaded).tap("ModuleChunkLoadingPlugin",handler);v.hooks.runtimeRequirementInTree.for(R.externalInstallChunk).tap("ModuleChunkLoadingPlugin",((I,P)=>{if(!isEnabledForChunk(I))return;v.addRuntimeModule(I,new $)}));v.hooks.runtimeRequirementInTree.for(R.ensureChunkHandlers).tap("ModuleChunkLoadingPlugin",((v,I)=>{if(!isEnabledForChunk(v))return;I.add(R.getChunkScriptFilename)}))}))}}v.exports=ModuleChunkLoadingPlugin},21821:function(v,I,P){"use strict";const{SyncWaterfallHook:R}=P(84891);const $=P(29327);const L=P(5205);const q=P(78994);const K=P(57227);const{getChunkFilenameTemplate:ae,chunkHasJs:ge}=P(36926);const{getInitialChunkIds:be}=P(46511);const xe=P(61935);const{getUndoPath:ve}=P(46579);const Ce=new WeakMap;class ModuleChunkLoadingRuntimeModule extends q{static getCompilationHooks(v){if(!(v instanceof $)){throw new TypeError("The 'compilation' argument must be an instance of Compilation")}let I=Ce.get(v);if(I===undefined){I={linkPreload:new R(["source","chunk"]),linkPrefetch:new R(["source","chunk"])};Ce.set(v,I)}return I}constructor(v){super("import chunk loading",q.STAGE_ATTACH);this._runtimeRequirements=v}_generateBaseUri(v,I){const P=v.getEntryOptions();if(P&&P.baseUri){return`${L.baseURI} = ${JSON.stringify(P.baseUri)};`}const R=this.compilation;const{outputOptions:{importMetaName:$}}=R;return`${L.baseURI} = new URL(${JSON.stringify(I)}, ${$}.url);`}generate(){const v=this.compilation;const I=this.chunkGraph;const P=this.chunk;const R=v.outputOptions.environment;const{runtimeTemplate:$,outputOptions:{importFunctionName:q,crossOriginLoading:Ce,charset:Ne}}=v;const He=L.ensureChunkHandlers;const Qe=this._runtimeRequirements.has(L.baseURI);const Je=this._runtimeRequirements.has(L.externalInstallChunk);const Ve=this._runtimeRequirements.has(L.ensureChunkHandlers);const Ke=this._runtimeRequirements.has(L.onChunksLoaded);const Ye=this._runtimeRequirements.has(L.hmrDownloadUpdateHandlers);const{linkPreload:Xe,linkPrefetch:Ze}=ModuleChunkLoadingRuntimeModule.getCompilationHooks(v);const et=$.isNeutralPlatform();const tt=(R.document||et)&&this._runtimeRequirements.has(L.prefetchChunkHandlers)&&P.hasChildByOrder(I,"prefetch",true,ge);const nt=(R.document||et)&&this._runtimeRequirements.has(L.preloadChunkHandlers)&&P.hasChildByOrder(I,"preload",true,ge);const st=I.getChunkConditionMap(P,ge);const rt=xe(st);const ot=be(P,I,ge);const it=v.getPath(ae(P,v.outputOptions),{chunk:P,contentHashType:"javascript"});const at=ve(it,v.outputOptions.path,true);const ct=Ye?`${L.hmrRuntimeStatePrefix}_module`:undefined;return K.asString([Qe?this._generateBaseUri(P,at):"// no baseURI","","// object to store loaded and loading chunks","// undefined = chunk not loaded, null = chunk preloaded/prefetched","// [resolve, Promise] = chunk loading, 0 = chunk loaded",`var installedChunks = ${ct?`${ct} = ${ct} || `:""}{`,K.indent(Array.from(ot,(v=>`${JSON.stringify(v)}: 0`)).join(",\n")),"};","",Ve||Je?`var installChunk = ${$.basicFunction("data",[$.destructureObject(["__webpack_ids__","__webpack_modules__","__webpack_runtime__"],"data"),'// add "modules" to the modules object,','// then flag all "ids" as loaded and fire callback',"var moduleId, chunkId, i = 0;","for(moduleId in __webpack_modules__) {",K.indent([`if(${L.hasOwnProperty}(__webpack_modules__, moduleId)) {`,K.indent(`${L.moduleFactories}[moduleId] = __webpack_modules__[moduleId];`),"}"]),"}",`if(__webpack_runtime__) __webpack_runtime__(${L.require});`,"for(;i < __webpack_ids__.length; i++) {",K.indent(["chunkId = __webpack_ids__[i];",`if(${L.hasOwnProperty}(installedChunks, chunkId) && installedChunks[chunkId]) {`,K.indent("installedChunks[chunkId][0]();"),"}","installedChunks[__webpack_ids__[i]] = 0;"]),"}",Ke?`${L.onChunksLoaded}();`:""])}`:"// no install chunk","",Ve?K.asString([`${He}.j = ${$.basicFunction("chunkId, promises",rt!==false?K.indent(["// import() chunk loading for javascript",`var installedChunkData = ${L.hasOwnProperty}(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;`,'if(installedChunkData !== 0) { // 0 means "already installed".',K.indent(["",'// a Promise means "currently loading".',"if(installedChunkData) {",K.indent(["promises.push(installedChunkData[1]);"]),"} else {",K.indent([rt===true?"if(true) { // all chunks have JS":`if(${rt("chunkId")}) {`,K.indent(["// setup Promise in chunk cache",`var promise = ${q}(${JSON.stringify(at)} + ${L.getChunkScriptFilename}(chunkId)).then(installChunk, ${$.basicFunction("e",["if(installedChunks[chunkId] !== 0) installedChunks[chunkId] = undefined;","throw e;"])});`,`var promise = Promise.race([promise, new Promise(${$.expressionFunction("installedChunkData = installedChunks[chunkId] = [resolve]","resolve")})])`,"promises.push(installedChunkData[1] = promise);"]),rt===true?"}":"} else installedChunks[chunkId] = 0;"]),"}"]),"}"]):K.indent(["installedChunks[chunkId] = 0;"]))};`]):"// no chunk on demand loading","",tt&&rt!==false?`${L.prefetchChunkHandlers}.j = ${$.basicFunction("chunkId",[`if((!${L.hasOwnProperty}(installedChunks, chunkId) || installedChunks[chunkId] === undefined) && ${rt===true?"true":rt("chunkId")}) {`,K.indent(["installedChunks[chunkId] = null;",et?"if (typeof document === 'undefined') return;":"",Ze.call(K.asString(["var link = document.createElement('link');",Ne?"link.charset = 'utf-8';":"",Ce?`link.crossOrigin = ${JSON.stringify(Ce)};`:"",`if (${L.scriptNonce}) {`,K.indent(`link.setAttribute("nonce", ${L.scriptNonce});`),"}",'link.rel = "prefetch";','link.as = "script";',`link.href = ${L.publicPath} + ${L.getChunkScriptFilename}(chunkId);`]),P),"document.head.appendChild(link);"]),"}"])};`:"// no prefetching","",nt&&rt!==false?`${L.preloadChunkHandlers}.j = ${$.basicFunction("chunkId",[`if((!${L.hasOwnProperty}(installedChunks, chunkId) || installedChunks[chunkId] === undefined) && ${rt===true?"true":rt("chunkId")}) {`,K.indent(["installedChunks[chunkId] = null;",et?"if (typeof document === 'undefined') return;":"",Xe.call(K.asString(["var link = document.createElement('link');",Ne?"link.charset = 'utf-8';":"",`if (${L.scriptNonce}) {`,K.indent(`link.setAttribute("nonce", ${L.scriptNonce});`),"}",'link.rel = "modulepreload";',`link.href = ${L.publicPath} + ${L.getChunkScriptFilename}(chunkId);`,Ce?Ce==="use-credentials"?'link.crossOrigin = "use-credentials";':K.asString(["if (link.href.indexOf(window.location.origin + '/') !== 0) {",K.indent(`link.crossOrigin = ${JSON.stringify(Ce)};`),"}"]):""]),P),"document.head.appendChild(link);"]),"}"])};`:"// no preloaded","",Je?K.asString([`${L.externalInstallChunk} = installChunk;`]):"// no external install chunk","",Ke?`${L.onChunksLoaded}.j = ${$.returningFunction("installedChunks[chunkId] === 0","chunkId")};`:"// no on chunks loaded"])}}v.exports=ModuleChunkLoadingRuntimeModule},28408:function(v){"use strict";const formatPosition=v=>{if(v&&typeof v==="object"){if("line"in v&&"column"in v){return`${v.line}:${v.column}`}else if("line"in v){return`${v.line}:?`}}return""};const formatLocation=v=>{if(v&&typeof v==="object"){if("start"in v&&v.start&&"end"in v&&v.end){if(typeof v.start==="object"&&typeof v.start.line==="number"&&typeof v.end==="object"&&typeof v.end.line==="number"&&typeof v.end.column==="number"&&v.start.line===v.end.line){return`${formatPosition(v.start)}-${v.end.column}`}else if(typeof v.start==="object"&&typeof v.start.line==="number"&&typeof v.start.column!=="number"&&typeof v.end==="object"&&typeof v.end.line==="number"&&typeof v.end.column!=="number"){return`${v.start.line}-${v.end.line}`}return`${formatPosition(v.start)}-${formatPosition(v.end)}`}if("start"in v&&v.start){return formatPosition(v.start)}if("name"in v&&"index"in v){return`${v.name}[${v.index}]`}if("name"in v){return v.name}}return""};v.exports=formatLocation},6457:function(v,I,P){"use strict";const R=P(5205);const $=P(78994);const L=P(57227);class HotModuleReplacementRuntimeModule extends ${constructor(){super("hot module replacement",$.STAGE_BASIC)}generate(){return L.getFunctionContent(require("./HotModuleReplacement.runtime.js")).replace(/\$interceptModuleExecution\$/g,R.interceptModuleExecution).replace(/\$moduleCache\$/g,R.moduleCache).replace(/\$hmrModuleData\$/g,R.hmrModuleData).replace(/\$hmrDownloadManifest\$/g,R.hmrDownloadManifest).replace(/\$hmrInvalidateModuleHandlers\$/g,R.hmrInvalidateModuleHandlers).replace(/\$hmrDownloadUpdateHandlers\$/g,R.hmrDownloadUpdateHandlers)}}v.exports=HotModuleReplacementRuntimeModule},72035:function(v,I,P){"use strict";const{RawSource:R}=P(51255);const $=P(67927);const L=P(49790);const q=P(34803);const K=P(8412);const{JS_TYPES:ae}=P(30021);const{WEBPACK_MODULE_TYPE_LAZY_COMPILATION_PROXY:ge}=P(6041);const be=P(5205);const xe=P(57227);const ve=P(60667);const{registerNotSerializable:Ce}=P(32589);const Ne=new Set(["import.meta.webpackHot.accept","import.meta.webpackHot.decline","module.hot.accept","module.hot.decline"]);const checkTest=(v,I)=>{if(v===undefined)return true;if(typeof v==="function"){return v(I)}if(typeof v==="string"){const P=I.nameForCondition();return P&&P.startsWith(v)}if(v instanceof RegExp){const P=I.nameForCondition();return P&&v.test(P)}return false};class LazyCompilationDependency extends L{constructor(v){super();this.proxyModule=v}get category(){return"esm"}get type(){return"lazy import()"}getResourceIdentifier(){return this.proxyModule.originalModule.identifier()}}Ce(LazyCompilationDependency);class LazyCompilationProxyModule extends q{constructor(v,I,P,R,$,L){super(ge,v,I.layer);this.originalModule=I;this.request=P;this.client=R;this.data=$;this.active=L}identifier(){return`${ge}|${this.originalModule.identifier()}`}readableIdentifier(v){return`${ge} ${this.originalModule.readableIdentifier(v)}`}updateCacheModule(v){super.updateCacheModule(v);const I=v;this.originalModule=I.originalModule;this.request=I.request;this.client=I.client;this.data=I.data;this.active=I.active}libIdent(v){return`${this.originalModule.libIdent(v)}!${ge}`}needBuild(v,I){I(null,!this.buildInfo||this.buildInfo.active!==this.active)}build(v,I,P,R,L){this.buildInfo={active:this.active};this.buildMeta={};this.clearDependenciesAndBlocks();const q=new ve(this.client);this.addDependency(q);if(this.active){const v=new LazyCompilationDependency(this);const I=new $({});I.addDependency(v);this.addBlock(I)}L()}getSourceTypes(){return ae}size(v){return 200}codeGeneration({runtimeTemplate:v,chunkGraph:I,moduleGraph:P}){const $=new Map;const L=new Set;L.add(be.module);const q=this.dependencies[0];const K=P.getModule(q);const ae=this.blocks[0];const ge=xe.asString([`var client = ${v.moduleExports({module:K,chunkGraph:I,request:q.userRequest,runtimeRequirements:L})}`,`var data = ${JSON.stringify(this.data)};`]);const ve=xe.asString([`var dispose = client.keepAlive({ data: data, active: ${JSON.stringify(Boolean(ae))}, module: module, onError: onError });`]);let Ce;if(ae){const R=ae.dependencies[0];const $=P.getModule(R);Ce=xe.asString([ge,`module.exports = ${v.moduleNamespacePromise({chunkGraph:I,block:ae,module:$,request:this.request,strict:false,message:"import()",runtimeRequirements:L})};`,"if (module.hot) {",xe.indent(["module.hot.accept();",`module.hot.accept(${JSON.stringify(I.getModuleId($))}, function() { module.hot.invalidate(); });`,"module.hot.dispose(function(data) { delete data.resolveSelf; dispose(data); });","if (module.hot.data && module.hot.data.resolveSelf) module.hot.data.resolveSelf(module.exports);"]),"}","function onError() { /* ignore */ }",ve])}else{Ce=xe.asString([ge,"var resolveSelf, onError;","module.exports = new Promise(function(resolve, reject) { resolveSelf = resolve; onError = reject; });","if (module.hot) {",xe.indent(["module.hot.accept();","if (module.hot.data && module.hot.data.resolveSelf) module.hot.data.resolveSelf(module.exports);","module.hot.dispose(function(data) { data.resolveSelf = resolveSelf; dispose(data); });"]),"}",ve])}$.set("javascript",new R(Ce));return{sources:$,runtimeRequirements:L}}updateHash(v,I){super.updateHash(v,I);v.update(this.active?"active":"");v.update(JSON.stringify(this.data))}}Ce(LazyCompilationProxyModule);class LazyCompilationDependencyFactory extends K{constructor(){super()}create(v,I){const P=v.dependencies[0];I(null,{module:P.proxyModule.originalModule})}}class LazyCompilationPlugin{constructor({backend:v,entries:I,imports:P,test:R}){this.backend=v;this.entries=I;this.imports=P;this.test=R}apply(v){let I;v.hooks.beforeCompile.tapAsync("LazyCompilationPlugin",((P,R)=>{if(I!==undefined)return R();const $=this.backend(v,((v,P)=>{if(v)return R(v);I=P;R()}));if($&&$.then){$.then((v=>{I=v;R()}),R)}}));v.hooks.thisCompilation.tap("LazyCompilationPlugin",((P,{normalModuleFactory:R})=>{R.hooks.module.tap("LazyCompilationPlugin",((R,$,L)=>{if(L.dependencies.every((v=>Ne.has(v.type)))){const v=L.dependencies[0];const I=P.moduleGraph.getParentModule(v);const R=I.blocks.some((I=>I.dependencies.some((I=>I.type==="import()"&&I.request===v.request))));if(!R)return}else if(!L.dependencies.every((v=>Ne.has(v.type)||this.imports&&(v.type==="import()"||v.type==="import() context element")||this.entries&&v.type==="entry")))return;if(/webpack[/\\]hot[/\\]|webpack-dev-server[/\\]client|webpack-hot-middleware[/\\]client/.test(L.request)||!checkTest(this.test,R))return;const q=I.module(R);if(!q)return;const{client:K,data:ae,active:ge}=q;return new LazyCompilationProxyModule(v.context,R,L.request,K,ae,ge)}));P.dependencyFactories.set(LazyCompilationDependency,new LazyCompilationDependencyFactory)}));v.hooks.shutdown.tapAsync("LazyCompilationPlugin",(v=>{I.dispose(v)}))}}v.exports=LazyCompilationPlugin},3102:function(v,I,P){"use strict";v.exports=v=>(I,R)=>{const $=I.getInfrastructureLogger("LazyCompilationBackend");const L=new Map;const q="/lazy-compilation-using-";const K=v.protocol==="https"||typeof v.server==="object"&&("key"in v.server||"pfx"in v.server);const ae=typeof v.server==="function"?v.server:(()=>{const I=K?P(95687):P(13685);return I.createServer.bind(I,v.server)})();const ge=typeof v.listen==="function"?v.listen:I=>{let P=v.listen;if(typeof P==="object"&&!("port"in P))P={...P,port:undefined};I.listen(P)};const be=v.protocol||(K?"https":"http");const requestListener=(v,P)=>{if(v.url===undefined)return;const R=v.url.slice(q.length).split("@");v.socket.on("close",(()=>{setTimeout((()=>{for(const v of R){const I=L.get(v)||0;L.set(v,I-1);if(I===1){$.log(`${v} is no longer in use. Next compilation will skip this module.`)}}}),12e4)}));v.socket.setNoDelay(true);P.writeHead(200,{"content-type":"text/event-stream","Access-Control-Allow-Origin":"*","Access-Control-Allow-Methods":"*","Access-Control-Allow-Headers":"*"});P.write("\n");let K=false;for(const v of R){const I=L.get(v)||0;L.set(v,I+1);if(I===0){$.log(`${v} is now in use and will be compiled.`);K=true}}if(K&&I.watching)I.watching.invalidate()};const xe=ae();xe.on("request",requestListener);let ve=false;const Ce=new Set;xe.on("connection",(v=>{Ce.add(v);v.on("close",(()=>{Ce.delete(v)}));if(ve)v.destroy()}));xe.on("clientError",(v=>{if(v.message!=="Server is disposing")$.warn(v)}));xe.on("listening",(I=>{if(I)return R(I);const P=xe.address();if(typeof P==="string")throw new Error("addr must not be a string");const K=P;const ae=K.address==="::"||K.address==="0.0.0.0"?`${be}://localhost:${K.port}`:K.family==="IPv6"?`${be}://[${K.address}]:${K.port}`:`${be}://${K.address}:${K.port}`;$.log(`Server-Sent-Events server for lazy compilation open at ${ae}.`);R(null,{dispose(v){ve=true;xe.off("request",requestListener);xe.close((I=>{v(I)}));for(const v of Ce){v.destroy(new Error("Server is disposing"))}},module(I){const P=`${encodeURIComponent(I.identifier().replace(/\\/g,"/").replace(/@/g,"_")).replace(/%(2F|3A|24|26|2B|2C|3B|3D)/g,decodeURIComponent)}`;const R=L.get(P)>0;return{client:`${v.client}?${encodeURIComponent(ae+q)}`,data:P,active:R}}})}));ge(xe)}},91845:function(v,I,P){"use strict";const{find:R}=P(81956);const{compareModulesByPreOrderIndexOrIdentifier:$,compareModulesByPostOrderIndexOrIdentifier:L}=P(21398);class ChunkModuleIdRangePlugin{constructor(v){this.options=v}apply(v){const I=this.options;v.hooks.compilation.tap("ChunkModuleIdRangePlugin",(v=>{const P=v.moduleGraph;v.hooks.moduleIds.tap("ChunkModuleIdRangePlugin",(q=>{const K=v.chunkGraph;const ae=R(v.chunks,(v=>v.name===I.name));if(!ae){throw new Error(`ChunkModuleIdRangePlugin: Chunk with name '${I.name}"' was not found`)}let ge;if(I.order){let v;switch(I.order){case"index":case"preOrderIndex":v=$(P);break;case"index2":case"postOrderIndex":v=L(P);break;default:throw new Error("ChunkModuleIdRangePlugin: unexpected value of order")}ge=K.getOrderedChunkModules(ae,v)}else{ge=Array.from(q).filter((v=>K.isModuleInChunk(v,ae))).sort($(P))}let be=I.start||0;for(let v=0;v<ge.length;v++){const P=ge[v];if(P.needId&&K.getModuleId(P)===null){K.setModuleId(P,be++)}if(I.end&&be>I.end)break}}))}))}}v.exports=ChunkModuleIdRangePlugin},39621:function(v,I,P){"use strict";const{compareChunksNatural:R}=P(21398);const{getFullChunkName:$,getUsedChunkIds:L,assignDeterministicIds:q}=P(28878);class DeterministicChunkIdsPlugin{constructor(v={}){this.options=v}apply(v){v.hooks.compilation.tap("DeterministicChunkIdsPlugin",(I=>{I.hooks.chunkIds.tap("DeterministicChunkIdsPlugin",(P=>{const K=I.chunkGraph;const ae=this.options.context?this.options.context:v.context;const ge=this.options.maxLength||3;const be=R(K);const xe=L(I);q(Array.from(P).filter((v=>v.id===null)),(I=>$(I,K,ae,v.root)),be,((v,I)=>{const P=xe.size;xe.add(`${I}`);if(P===xe.size)return false;v.id=I;v.ids=[I];return true}),[10**ge],10,xe.size)}))}))}}v.exports=DeterministicChunkIdsPlugin},55761:function(v,I,P){"use strict";const{compareModulesByPreOrderIndexOrIdentifier:R}=P(21398);const{getUsedModuleIdsAndModules:$,getFullModuleName:L,assignDeterministicIds:q}=P(28878);class DeterministicModuleIdsPlugin{constructor(v={}){this.options=v}apply(v){v.hooks.compilation.tap("DeterministicModuleIdsPlugin",(I=>{I.hooks.moduleIds.tap("DeterministicModuleIdsPlugin",(()=>{const P=I.chunkGraph;const K=this.options.context?this.options.context:v.context;const ae=this.options.maxLength||3;const ge=this.options.failOnConflict||false;const be=this.options.fixedLength||false;const xe=this.options.salt||0;let ve=0;const[Ce,Ne]=$(I,this.options.test);q(Ne,(I=>L(I,K,v.root)),ge?()=>0:R(I.moduleGraph),((v,I)=>{const R=Ce.size;Ce.add(`${I}`);if(R===Ce.size){ve++;return false}P.setModuleId(v,I);return true}),[10**ae],be?0:10,Ce.size,xe);if(ge&&ve)throw new Error(`Assigning deterministic module ids has lead to ${ve} conflict${ve>1?"s":""}.\nIncrease the 'maxLength' to increase the id space and make conflicts less likely (recommended when there are many conflicts or application is expected to grow), or add an 'salt' number to try another hash starting value in the same id space (recommended when there is only a single conflict).`)}))}))}}v.exports=DeterministicModuleIdsPlugin},95120:function(v,I,P){"use strict";const{compareModulesByPreOrderIndexOrIdentifier:R}=P(21398);const $=P(86750);const L=P(12471);const{getUsedModuleIdsAndModules:q,getFullModuleName:K}=P(28878);const ae=$(P(52904),(()=>P(78018)),{name:"Hashed Module Ids Plugin",baseDataPath:"options"});class HashedModuleIdsPlugin{constructor(v={}){ae(v);this.options={context:undefined,hashFunction:"md4",hashDigest:"base64",hashDigestLength:4,...v}}apply(v){const I=this.options;v.hooks.compilation.tap("HashedModuleIdsPlugin",(P=>{P.hooks.moduleIds.tap("HashedModuleIdsPlugin",(()=>{const $=P.chunkGraph;const ae=this.options.context?this.options.context:v.context;const[ge,be]=q(P);const xe=be.sort(R(P.moduleGraph));for(const P of xe){const R=K(P,ae,v.root);const q=L(I.hashFunction);q.update(R||"");const be=q.digest(I.hashDigest);let xe=I.hashDigestLength;while(ge.has(be.slice(0,xe)))xe++;const ve=be.slice(0,xe);$.setModuleId(P,ve);ge.add(ve)}}))}))}}v.exports=HashedModuleIdsPlugin},28878:function(v,I,P){"use strict";const R=P(12471);const{makePathsRelative:$}=P(46579);const L=P(23845);const getHash=(v,I,P)=>{const $=R(P);$.update(v);const L=$.digest("hex");return L.slice(0,I)};const avoidNumber=v=>{if(v.length>21)return v;const I=v.charCodeAt(0);if(I<49){if(I!==45)return v}else if(I>57){return v}if(v===String(Number(v))){return`_${v}`}return v};const requestToId=v=>v.replace(/^(\.\.?\/)+/,"").replace(/(^[.-]|[^a-zA-Z0-9_-])+/g,"_");v.exports.requestToId=requestToId;const shortenLongString=(v,I,P)=>{if(v.length<100)return v;return v.slice(0,100-6-I.length)+I+getHash(v,6,P)};const getShortModuleName=(v,I,P)=>{const R=v.libIdent({context:I,associatedObjectForCache:P});if(R)return avoidNumber(R);const L=v.nameForCondition();if(L)return avoidNumber($(I,L,P));return""};v.exports.getShortModuleName=getShortModuleName;const getLongModuleName=(v,I,P,R,$)=>{const L=getFullModuleName(I,P,$);return`${v}?${getHash(L,4,R)}`};v.exports.getLongModuleName=getLongModuleName;const getFullModuleName=(v,I,P)=>$(I,v.identifier(),P);v.exports.getFullModuleName=getFullModuleName;const getShortChunkName=(v,I,P,R,$,L)=>{const q=I.getChunkRootModules(v);const K=q.map((v=>requestToId(getShortModuleName(v,P,L))));v.idNameHints.sort();const ae=Array.from(v.idNameHints).concat(K).filter(Boolean).join(R);return shortenLongString(ae,R,$)};v.exports.getShortChunkName=getShortChunkName;const getLongChunkName=(v,I,P,R,$,L)=>{const q=I.getChunkRootModules(v);const K=q.map((v=>requestToId(getShortModuleName(v,P,L))));const ae=q.map((v=>requestToId(getLongModuleName("",v,P,$,L))));v.idNameHints.sort();const ge=Array.from(v.idNameHints).concat(K,ae).filter(Boolean).join(R);return shortenLongString(ge,R,$)};v.exports.getLongChunkName=getLongChunkName;const getFullChunkName=(v,I,P,R)=>{if(v.name)return v.name;const L=I.getChunkRootModules(v);const q=L.map((v=>$(P,v.identifier(),R)));return q.join()};v.exports.getFullChunkName=getFullChunkName;const addToMapOfItems=(v,I,P)=>{let R=v.get(I);if(R===undefined){R=[];v.set(I,R)}R.push(P)};const getUsedModuleIdsAndModules=(v,I)=>{const P=v.chunkGraph;const R=[];const $=new Set;if(v.usedModuleIds){for(const I of v.usedModuleIds){$.add(String(I))}}for(const L of v.modules){if(!L.needId)continue;const v=P.getModuleId(L);if(v!==null){$.add(String(v))}else if((!I||I(L))&&P.getNumberOfModuleChunks(L)!==0){R.push(L)}}return[$,R]};v.exports.getUsedModuleIdsAndModules=getUsedModuleIdsAndModules;const getUsedChunkIds=v=>{const I=new Set;if(v.usedChunkIds){for(const P of v.usedChunkIds){I.add(String(P))}}for(const P of v.chunks){const v=P.id;if(v!==null){I.add(String(v))}}return I};v.exports.getUsedChunkIds=getUsedChunkIds;const assignNames=(v,I,P,R,$,L)=>{const q=new Map;for(const P of v){const v=I(P);addToMapOfItems(q,v,P)}const K=new Map;for(const[v,I]of q){if(I.length>1||!v){for(const R of I){const I=P(R,v);addToMapOfItems(K,I,R)}}else{addToMapOfItems(K,v,I[0])}}const ae=[];for(const[v,I]of K){if(!v){for(const v of I){ae.push(v)}}else if(I.length===1&&!$.has(v)){L(I[0],v);$.add(v)}else{I.sort(R);let P=0;for(const R of I){while(K.has(v+P)&&$.has(v+P))P++;L(R,v+P);$.add(v+P);P++}}}ae.sort(R);return ae};v.exports.assignNames=assignNames;const assignDeterministicIds=(v,I,P,R,$=[10],q=10,K=0,ae=0)=>{v.sort(P);const ge=Math.min(v.length*20+K,Number.MAX_SAFE_INTEGER);let be=0;let xe=$[be];while(xe<ge){be++;if(be<$.length){xe=Math.min($[be],Number.MAX_SAFE_INTEGER)}else if(q){xe=Math.min(xe*q,Number.MAX_SAFE_INTEGER)}else{break}}for(const P of v){const v=I(P);let $;let q=ae;do{$=L(v+q++,xe)}while(!R(P,$))}};v.exports.assignDeterministicIds=assignDeterministicIds;const assignAscendingModuleIds=(v,I,P)=>{const R=P.chunkGraph;let $=0;let L;if(v.size>0){L=I=>{if(R.getModuleId(I)===null){while(v.has(String($)))$++;R.setModuleId(I,$++)}}}else{L=v=>{if(R.getModuleId(v)===null){R.setModuleId(v,$++)}}}for(const v of I){L(v)}};v.exports.assignAscendingModuleIds=assignAscendingModuleIds;const assignAscendingChunkIds=(v,I)=>{const P=getUsedChunkIds(I);let R=0;if(P.size>0){for(const I of v){if(I.id===null){while(P.has(String(R)))R++;I.id=R;I.ids=[R];R++}}}else{for(const I of v){if(I.id===null){I.id=R;I.ids=[R];R++}}}};v.exports.assignAscendingChunkIds=assignAscendingChunkIds},97802:function(v,I,P){"use strict";const{compareChunksNatural:R}=P(21398);const{getShortChunkName:$,getLongChunkName:L,assignNames:q,getUsedChunkIds:K,assignAscendingChunkIds:ae}=P(28878);class NamedChunkIdsPlugin{constructor(v){this.delimiter=v&&v.delimiter||"-";this.context=v&&v.context}apply(v){v.hooks.compilation.tap("NamedChunkIdsPlugin",(I=>{const P=I.outputOptions.hashFunction;I.hooks.chunkIds.tap("NamedChunkIdsPlugin",(ge=>{const be=I.chunkGraph;const xe=this.context?this.context:v.context;const ve=this.delimiter;const Ce=q(Array.from(ge).filter((v=>{if(v.name){v.id=v.name;v.ids=[v.name]}return v.id===null})),(I=>$(I,be,xe,ve,P,v.root)),(I=>L(I,be,xe,ve,P,v.root)),R(be),K(I),((v,I)=>{v.id=I;v.ids=[I]}));if(Ce.length>0){ae(Ce,I)}}))}))}}v.exports=NamedChunkIdsPlugin},45602:function(v,I,P){"use strict";const{compareModulesByIdentifier:R}=P(21398);const{getShortModuleName:$,getLongModuleName:L,assignNames:q,getUsedModuleIdsAndModules:K,assignAscendingModuleIds:ae}=P(28878);class NamedModuleIdsPlugin{constructor(v={}){this.options=v}apply(v){const{root:I}=v;v.hooks.compilation.tap("NamedModuleIdsPlugin",(P=>{const ge=P.outputOptions.hashFunction;P.hooks.moduleIds.tap("NamedModuleIdsPlugin",(()=>{const be=P.chunkGraph;const xe=this.options.context?this.options.context:v.context;const[ve,Ce]=K(P);const Ne=q(Ce,(v=>$(v,xe,I)),((v,P)=>L(P,v,xe,ge,I)),R,ve,((v,I)=>be.setModuleId(v,I)));if(Ne.length>0){ae(ve,Ne,P)}}))}))}}v.exports=NamedModuleIdsPlugin},70676:function(v,I,P){"use strict";const{compareChunksNatural:R}=P(21398);const{assignAscendingChunkIds:$}=P(28878);class NaturalChunkIdsPlugin{apply(v){v.hooks.compilation.tap("NaturalChunkIdsPlugin",(v=>{v.hooks.chunkIds.tap("NaturalChunkIdsPlugin",(I=>{const P=v.chunkGraph;const L=R(P);const q=Array.from(I).sort(L);$(q,v)}))}))}}v.exports=NaturalChunkIdsPlugin},43391:function(v,I,P){"use strict";const{compareModulesByPreOrderIndexOrIdentifier:R}=P(21398);const{assignAscendingModuleIds:$,getUsedModuleIdsAndModules:L}=P(28878);class NaturalModuleIdsPlugin{apply(v){v.hooks.compilation.tap("NaturalModuleIdsPlugin",(v=>{v.hooks.moduleIds.tap("NaturalModuleIdsPlugin",(I=>{const[P,q]=L(v);q.sort(R(v.moduleGraph));$(P,q,v)}))}))}}v.exports=NaturalModuleIdsPlugin},54170:function(v,I,P){"use strict";const{compareChunksNatural:R}=P(21398);const $=P(86750);const{assignAscendingChunkIds:L}=P(28878);const q=$(P(74316),(()=>P(33228)),{name:"Occurrence Order Chunk Ids Plugin",baseDataPath:"options"});class OccurrenceChunkIdsPlugin{constructor(v={}){q(v);this.options=v}apply(v){const I=this.options.prioritiseInitial;v.hooks.compilation.tap("OccurrenceChunkIdsPlugin",(v=>{v.hooks.chunkIds.tap("OccurrenceChunkIdsPlugin",(P=>{const $=v.chunkGraph;const q=new Map;const K=R($);for(const v of P){let I=0;for(const P of v.groupsIterable){for(const v of P.parentsIterable){if(v.isInitial())I++}}q.set(v,I)}const ae=Array.from(P).sort(((v,P)=>{if(I){const I=q.get(v);const R=q.get(P);if(I>R)return-1;if(I<R)return 1}const R=v.getNumberOfGroups();const $=P.getNumberOfGroups();if(R>$)return-1;if(R<$)return 1;return K(v,P)}));L(ae,v)}))}))}}v.exports=OccurrenceChunkIdsPlugin},47507:function(v,I,P){"use strict";const{compareModulesByPreOrderIndexOrIdentifier:R}=P(21398);const $=P(86750);const{assignAscendingModuleIds:L,getUsedModuleIdsAndModules:q}=P(28878);const K=$(P(5886),(()=>P(99908)),{name:"Occurrence Order Module Ids Plugin",baseDataPath:"options"});class OccurrenceModuleIdsPlugin{constructor(v={}){K(v);this.options=v}apply(v){const I=this.options.prioritiseInitial;v.hooks.compilation.tap("OccurrenceModuleIdsPlugin",(v=>{const P=v.moduleGraph;v.hooks.moduleIds.tap("OccurrenceModuleIdsPlugin",(()=>{const $=v.chunkGraph;const[K,ae]=q(v);const ge=new Map;const be=new Map;const xe=new Map;const ve=new Map;for(const v of ae){let I=0;let P=0;for(const R of $.getModuleChunksIterable(v)){if(R.canBeInitial())I++;if($.isEntryModuleInChunk(v,R))P++}xe.set(v,I);ve.set(v,P)}const countOccursInEntry=v=>{let I=0;for(const[R,$]of P.getIncomingConnectionsByOriginModule(v)){if(!R)continue;if(!$.some((v=>v.isTargetActive(undefined))))continue;I+=xe.get(R)||0}return I};const countOccurs=v=>{let I=0;for(const[R,L]of P.getIncomingConnectionsByOriginModule(v)){if(!R)continue;const v=$.getNumberOfModuleChunks(R);for(const P of L){if(!P.isTargetActive(undefined))continue;if(!P.dependency)continue;const R=P.dependency.getNumberOfIdOccurrences();if(R===0)continue;I+=R*v}}return I};if(I){for(const v of ae){const I=countOccursInEntry(v)+xe.get(v)+ve.get(v);ge.set(v,I)}}for(const v of ae){const I=countOccurs(v)+$.getNumberOfModuleChunks(v)+ve.get(v);be.set(v,I)}const Ce=R(v.moduleGraph);ae.sort(((v,P)=>{if(I){const I=ge.get(v);const R=ge.get(P);if(I>R)return-1;if(I<R)return 1}const R=be.get(v);const $=be.get(P);if(R>$)return-1;if(R<$)return 1;return Ce(v,P)}));L(K,ae,v)}))}))}}v.exports=OccurrenceModuleIdsPlugin},41324:function(v,I,P){"use strict";const{WebpackError:R}=P(24378);const{getUsedModuleIdsAndModules:$}=P(28878);const L="SyncModuleIdsPlugin";class SyncModuleIdsPlugin{constructor({path:v,context:I,test:P,mode:R}){this._path=v;this._context=I;this._test=P||(()=>true);const $=!R||R==="merge"||R==="update";this._read=$||R==="read";this._write=$||R==="create";this._prune=R==="update"}apply(v){let I;let P=false;if(this._read){v.hooks.readRecords.tapAsync(L,(R=>{const $=v.intermediateFileSystem;$.readFile(this._path,((v,$)=>{if(v){if(v.code!=="ENOENT"){return R(v)}return R()}const L=JSON.parse($.toString());I=new Map;for(const v of Object.keys(L)){I.set(v,L[v])}P=false;return R()}))}))}if(this._write){v.hooks.emitRecords.tapAsync(L,(R=>{if(!I||!P)return R();const $={};const L=Array.from(I).sort((([v],[I])=>v<I?-1:1));for(const[v,I]of L){$[v]=I}const q=v.intermediateFileSystem;q.writeFile(this._path,JSON.stringify($),R)}))}v.hooks.thisCompilation.tap(L,(q=>{const K=v.root;const ae=this._context||v.context;if(this._read){q.hooks.reviveModules.tap(L,((v,P)=>{if(!I)return;const{chunkGraph:L}=q;const[ge,be]=$(q,this._test);for(const v of be){const P=v.libIdent({context:ae,associatedObjectForCache:K});if(!P)continue;const $=I.get(P);const be=`${$}`;if(ge.has(be)){const I=new R(`SyncModuleIdsPlugin: Unable to restore id '${$}' from '${this._path}' as it's already used.`);I.module=v;q.errors.push(I)}L.setModuleId(v,$);ge.add(be)}}))}if(this._write){q.hooks.recordModules.tap(L,(v=>{const{chunkGraph:R}=q;let $=I;if(!$){$=I=new Map}else if(this._prune){I=new Map}for(const L of v){if(this._test(L)){const v=L.libIdent({context:ae,associatedObjectForCache:K});if(!v)continue;const q=R.getModuleId(L);if(q===null)continue;const ge=$.get(v);if(ge!==q){P=true}else if(I===$){continue}I.set(v,q)}}if(I.size!==$.size)P=true}))}}))}}v.exports=SyncModuleIdsPlugin},24378:function(v,I,P){"use strict";const R=P(73837);const $=P(13594);const lazyFunction=v=>{const I=$(v);const f=(...v)=>I()(...v);return f};const mergeExports=(v,I)=>{const P=Object.getOwnPropertyDescriptors(I);for(const I of Object.keys(P)){const R=P[I];if(R.get){const P=R.get;Object.defineProperty(v,I,{configurable:false,enumerable:true,get:$(P)})}else if(typeof R.value==="object"){Object.defineProperty(v,I,{configurable:false,enumerable:true,writable:false,value:mergeExports({},R.value)})}else{throw new Error("Exposed values must be either a getter or an nested object")}}return Object.freeze(v)};const L=lazyFunction((()=>P(7948)));v.exports=mergeExports(L,{get webpack(){return P(7948)},get validate(){const v=P(24171);const I=$((()=>{const v=P(10483);const I=P(59992);return P=>v(I,P)}));return P=>{if(!v(P))I()(P)}},get validateSchema(){const v=P(10483);return v},get version(){return P(21923).i8},get cli(){return P(53305)},get AutomaticPrefetchPlugin(){return P(88920)},get AsyncDependenciesBlock(){return P(67927)},get BannerPlugin(){return P(34748)},get Cache(){return P(37292)},get Chunk(){return P(56754)},get ChunkGraph(){return P(23630)},get CleanPlugin(){return P(26075)},get Compilation(){return P(29327)},get Compiler(){return P(46251)},get ConcatenationScope(){return P(40255)},get ContextExclusionPlugin(){return P(35105)},get ContextReplacementPlugin(){return P(91743)},get DefinePlugin(){return P(64448)},get DelegatedPlugin(){return P(71207)},get Dependency(){return P(49790)},get DllPlugin(){return P(72785)},get DllReferencePlugin(){return P(45662)},get DynamicEntryPlugin(){return P(14973)},get EntryOptionPlugin(){return P(77529)},get EntryPlugin(){return P(80142)},get EnvironmentPlugin(){return P(32925)},get EvalDevToolModulePlugin(){return P(56625)},get EvalSourceMapDevToolPlugin(){return P(22202)},get ExternalModule(){return P(98138)},get ExternalsPlugin(){return P(52925)},get Generator(){return P(52402)},get HotUpdateChunk(){return P(59336)},get HotModuleReplacementPlugin(){return P(59035)},get InitFragment(){return P(89959)},get IgnorePlugin(){return P(28421)},get JavascriptModulesPlugin(){return R.deprecate((()=>P(36926)),"webpack.JavascriptModulesPlugin has moved to webpack.javascript.JavascriptModulesPlugin","DEP_WEBPACK_JAVASCRIPT_MODULES_PLUGIN")()},get LibManifestPlugin(){return P(72853)},get LibraryTemplatePlugin(){return R.deprecate((()=>P(22946)),"webpack.LibraryTemplatePlugin is deprecated and has been replaced by compilation.outputOptions.library or compilation.addEntry + passing a library option","DEP_WEBPACK_LIBRARY_TEMPLATE_PLUGIN")()},get LoaderOptionsPlugin(){return P(89681)},get LoaderTargetPlugin(){return P(91855)},get Module(){return P(34803)},get ModuleFilenameHelpers(){return P(20610)},get ModuleGraph(){return P(48101)},get ModuleGraphConnection(){return P(73418)},get NoEmitOnErrorsPlugin(){return P(48489)},get NormalModule(){return P(32594)},get NormalModuleReplacementPlugin(){return P(53339)},get MultiCompiler(){return P(34324)},get OptimizationStages(){return P(64152)},get Parser(){return P(33157)},get PlatformPlugin(){return P(95392)},get PrefetchPlugin(){return P(41598)},get ProgressPlugin(){return P(17531)},get ProvidePlugin(){return P(27336)},get RuntimeGlobals(){return P(5205)},get RuntimeModule(){return P(78994)},get SingleEntryPlugin(){return R.deprecate((()=>P(80142)),"SingleEntryPlugin was renamed to EntryPlugin","DEP_WEBPACK_SINGLE_ENTRY_PLUGIN")()},get SourceMapDevToolPlugin(){return P(58425)},get Stats(){return P(74951)},get Template(){return P(57227)},get UsageState(){return P(21311).UsageState},get WatchIgnorePlugin(){return P(80488)},get WebpackError(){return P(94252)},get WebpackOptionsApply(){return P(41569)},get WebpackOptionsDefaulter(){return R.deprecate((()=>P(81355)),"webpack.WebpackOptionsDefaulter is deprecated and has been replaced by webpack.config.getNormalizedWebpackOptions and webpack.config.applyWebpackOptionsDefaults","DEP_WEBPACK_OPTIONS_DEFAULTER")()},get WebpackOptionsValidationError(){return P(38476).ValidationError},get ValidationError(){return P(38476).ValidationError},cache:{get MemoryCachePlugin(){return P(99012)}},config:{get getNormalizedWebpackOptions(){return P(92043).getNormalizedWebpackOptions},get applyWebpackOptionsDefaults(){return P(52525).applyWebpackOptionsDefaults}},dependencies:{get ModuleDependency(){return P(39460)},get HarmonyImportDependency(){return P(33643)},get ConstDependency(){return P(34022)},get NullDependency(){return P(18941)}},ids:{get ChunkModuleIdRangePlugin(){return P(91845)},get NaturalModuleIdsPlugin(){return P(43391)},get OccurrenceModuleIdsPlugin(){return P(47507)},get NamedModuleIdsPlugin(){return P(45602)},get DeterministicChunkIdsPlugin(){return P(39621)},get DeterministicModuleIdsPlugin(){return P(55761)},get NamedChunkIdsPlugin(){return P(97802)},get OccurrenceChunkIdsPlugin(){return P(54170)},get HashedModuleIdsPlugin(){return P(95120)}},javascript:{get EnableChunkLoadingPlugin(){return P(19353)},get JavascriptModulesPlugin(){return P(36926)},get JavascriptParser(){return P(31384)}},optimize:{get AggressiveMergingPlugin(){return P(61536)},get AggressiveSplittingPlugin(){return R.deprecate((()=>P(43431)),"AggressiveSplittingPlugin is deprecated in favor of SplitChunksPlugin","DEP_WEBPACK_AGGRESSIVE_SPLITTING_PLUGIN")()},get InnerGraph(){return P(9696)},get LimitChunkCountPlugin(){return P(25310)},get MergeDuplicateChunksPlugin(){return P(28688)},get MinChunkSizePlugin(){return P(34350)},get ModuleConcatenationPlugin(){return P(85811)},get RealContentHashPlugin(){return P(92638)},get RuntimeChunkPlugin(){return P(85859)},get SideEffectsFlagPlugin(){return P(65886)},get SplitChunksPlugin(){return P(55346)}},runtime:{get GetChunkFilenameRuntimeModule(){return P(2075)},get LoadScriptRuntimeModule(){return P(28706)}},prefetch:{get ChunkPrefetchPreloadPlugin(){return P(36514)}},web:{get FetchCompileWasmPlugin(){return P(76546)},get FetchCompileAsyncWasmPlugin(){return P(99095)},get JsonpChunkLoadingRuntimeModule(){return P(23753)},get JsonpTemplatePlugin(){return P(51672)},get CssLoadingRuntimeModule(){return P(80928)}},esm:{get ModuleChunkLoadingRuntimeModule(){return P(21821)}},webworker:{get WebWorkerTemplatePlugin(){return P(66990)}},node:{get NodeEnvironmentPlugin(){return P(32878)},get NodeSourcePlugin(){return P(94164)},get NodeTargetPlugin(){return P(26076)},get NodeTemplatePlugin(){return P(18364)},get ReadFileCompileWasmPlugin(){return P(94840)},get ReadFileCompileAsyncWasmPlugin(){return P(67151)}},electron:{get ElectronTargetPlugin(){return P(17191)}},wasm:{get AsyncWebAssemblyModulesPlugin(){return P(26302)},get EnableWasmLoadingPlugin(){return P(13872)}},css:{get CssModulesPlugin(){return P(53296)}},library:{get AbstractLibraryPlugin(){return P(75918)},get EnableLibraryPlugin(){return P(48296)}},container:{get ContainerPlugin(){return P(16258)},get ContainerReferencePlugin(){return P(19674)},get ModuleFederationPlugin(){return P(79533)},get scope(){return P(96336).scope}},sharing:{get ConsumeSharedPlugin(){return P(1435)},get ProvideSharedPlugin(){return P(5586)},get SharePlugin(){return P(15033)},get scope(){return P(96336).scope}},debug:{get ProfilingPlugin(){return P(49605)}},util:{get createHash(){return P(12471)},get comparators(){return P(21398)},get runtime(){return P(86620)},get serialization(){return P(32589)},get cleverMerge(){return P(22298).cachedCleverMerge},get LazySet(){return P(11584)},get compileBooleanMatcher(){return P(61935)}},get sources(){return P(51255)},experiments:{schemes:{get HttpUriPlugin(){return P(55495)}},ids:{get SyncModuleIdsPlugin(){return P(41324)}}}})},7131:function(v,I,P){"use strict";const{ConcatSource:R,PrefixSource:$,RawSource:L}=P(51255);const{RuntimeGlobals:q}=P(24378);const K=P(59336);const ae=P(57227);const{getCompilationHooks:ge}=P(36926);const{generateEntryStartup:be,updateHashForEntryStartup:xe}=P(46511);class ArrayPushCallbackChunkFormatPlugin{apply(v){v.hooks.thisCompilation.tap("ArrayPushCallbackChunkFormatPlugin",(v=>{v.hooks.additionalChunkRuntimeRequirements.tap("ArrayPushCallbackChunkFormatPlugin",((v,I,{chunkGraph:P})=>{if(v.hasRuntime())return;if(P.getNumberOfEntryModules(v)>0){I.add(q.onChunksLoaded);I.add(q.exports);I.add(q.require)}I.add(q.chunkCallback)}));const I=ge(v);I.renderChunk.tap("ArrayPushCallbackChunkFormatPlugin",((P,ge)=>{const{chunk:xe,chunkGraph:ve,runtimeTemplate:Ce}=ge;const Ne=xe instanceof K?xe:null;const He=Ce.globalObject;const Qe=new R;const Je=ve.getChunkRuntimeModulesInOrder(xe);if(Ne){const v=Ce.outputOptions.hotUpdateGlobal;Qe.add(`${He}[${JSON.stringify(v)}](`);Qe.add(`${JSON.stringify(xe.id)},`);Qe.add(P);if(Je.length>0){Qe.add(",\n");const v=ae.renderChunkRuntimeModules(Je,ge);Qe.add(v)}Qe.add(")")}else{const K=Ce.outputOptions.chunkLoadingGlobal;Qe.add(`(${He}[${JSON.stringify(K)}] = ${He}[${JSON.stringify(K)}] || []).push([`);Qe.add(`${JSON.stringify(xe.ids)},`);Qe.add(P);const Ne=Array.from(ve.getChunkEntryModulesWithChunkGroupIterable(xe));if(Je.length>0||Ne.length>0){const P=new R(`${Ce.supportsArrowFunction()?`${q.require} =>`:`function(${q.require})`} { // webpackRuntimeModules\n`);if(Je.length>0){P.add(ae.renderRuntimeModules(Je,{...ge,codeGenerationResults:v.codeGenerationResults}))}if(Ne.length>0){const v=new L(be(ve,Ce,Ne,xe,true));P.add(I.renderStartup.call(v,Ne[Ne.length-1][0],{...ge,inlined:false}));if(ve.getChunkRuntimeRequirements(xe).has(q.returnExportsFromRuntime)){P.add(`return ${q.exports};\n`)}}P.add("}\n");Qe.add(",\n");Qe.add(new $("/******/ ",P))}Qe.add("])")}return Qe}));I.chunkHash.tap("ArrayPushCallbackChunkFormatPlugin",((v,I,{chunkGraph:P,runtimeTemplate:R})=>{if(v.hasRuntime())return;I.update(`ArrayPushCallbackChunkFormatPlugin1${R.outputOptions.chunkLoadingGlobal}${R.outputOptions.hotUpdateGlobal}${R.globalObject}`);const $=Array.from(P.getChunkEntryModulesWithChunkGroupIterable(v));xe(I,P,$,v)}))}))}}v.exports=ArrayPushCallbackChunkFormatPlugin},28665:function(v){"use strict";const I=0;const P=1;const R=2;const $=3;const L=4;const q=5;const K=6;const ae=7;const ge=8;const be=9;const xe=10;const ve=11;const Ce=12;const Ne=13;class BasicEvaluatedExpression{constructor(){this.type=I;this.range=undefined;this.falsy=false;this.truthy=false;this.nullish=undefined;this.sideEffects=true;this.bool=undefined;this.number=undefined;this.bigint=undefined;this.regExp=undefined;this.string=undefined;this.quasis=undefined;this.parts=undefined;this.array=undefined;this.items=undefined;this.options=undefined;this.prefix=undefined;this.postfix=undefined;this.wrappedInnerExpressions=undefined;this.identifier=undefined;this.rootInfo=undefined;this.getMembers=undefined;this.getMembersOptionals=undefined;this.getMemberRanges=undefined;this.expression=undefined}isUnknown(){return this.type===I}isNull(){return this.type===R}isUndefined(){return this.type===P}isString(){return this.type===$}isNumber(){return this.type===L}isBigInt(){return this.type===Ne}isBoolean(){return this.type===q}isRegExp(){return this.type===K}isConditional(){return this.type===ae}isArray(){return this.type===ge}isConstArray(){return this.type===be}isIdentifier(){return this.type===xe}isWrapped(){return this.type===ve}isTemplateString(){return this.type===Ce}isPrimitiveType(){switch(this.type){case P:case R:case $:case L:case q:case Ne:case ve:case Ce:return true;case K:case ge:case be:return false;default:return undefined}}isCompileTimeValue(){switch(this.type){case P:case R:case $:case L:case q:case K:case be:case Ne:return true;default:return false}}asCompileTimeValue(){switch(this.type){case P:return;case R:return null;case $:return this.string;case L:return this.number;case q:return this.bool;case K:return this.regExp;case be:return this.array;case Ne:return this.bigint;default:throw new Error("asCompileTimeValue must only be called for compile-time values")}}isTruthy(){return this.truthy}isFalsy(){return this.falsy}isNullish(){return this.nullish}couldHaveSideEffects(){return this.sideEffects}asBool(){if(this.truthy)return true;if(this.falsy||this.nullish)return false;if(this.isBoolean())return this.bool;if(this.isNull())return false;if(this.isUndefined())return false;if(this.isString())return this.string!=="";if(this.isNumber())return this.number!==0;if(this.isBigInt())return this.bigint!==BigInt(0);if(this.isRegExp())return true;if(this.isArray())return true;if(this.isConstArray())return true;if(this.isWrapped()){return this.prefix&&this.prefix.asBool()||this.postfix&&this.postfix.asBool()?true:undefined}if(this.isTemplateString()){const v=this.asString();if(typeof v==="string")return v!==""}}asNullish(){const v=this.isNullish();if(v===true||this.isNull()||this.isUndefined())return true;if(v===false)return false;if(this.isTruthy())return false;if(this.isBoolean())return false;if(this.isString())return false;if(this.isNumber())return false;if(this.isBigInt())return false;if(this.isRegExp())return false;if(this.isArray())return false;if(this.isConstArray())return false;if(this.isTemplateString())return false;if(this.isRegExp())return false}asString(){if(this.isBoolean())return`${this.bool}`;if(this.isNull())return"null";if(this.isUndefined())return"undefined";if(this.isString())return this.string;if(this.isNumber())return`${this.number}`;if(this.isBigInt())return`${this.bigint}`;if(this.isRegExp())return`${this.regExp}`;if(this.isArray()){const v=[];for(const I of this.items){const P=I.asString();if(P===undefined)return;v.push(P)}return`${v}`}if(this.isConstArray())return`${this.array}`;if(this.isTemplateString()){let v="";for(const I of this.parts){const P=I.asString();if(P===undefined)return;v+=P}return v}}setString(v){this.type=$;this.string=v;this.sideEffects=false;return this}setUndefined(){this.type=P;this.sideEffects=false;return this}setNull(){this.type=R;this.sideEffects=false;return this}setNumber(v){this.type=L;this.number=v;this.sideEffects=false;return this}setBigInt(v){this.type=Ne;this.bigint=v;this.sideEffects=false;return this}setBoolean(v){this.type=q;this.bool=v;this.sideEffects=false;return this}setRegExp(v){this.type=K;this.regExp=v;this.sideEffects=false;return this}setIdentifier(v,I,P,R,$){this.type=xe;this.identifier=v;this.rootInfo=I;this.getMembers=P;this.getMembersOptionals=R;this.getMemberRanges=$;this.sideEffects=true;return this}setWrapped(v,I,P){this.type=ve;this.prefix=v;this.postfix=I;this.wrappedInnerExpressions=P;this.sideEffects=true;return this}setOptions(v){this.type=ae;this.options=v;this.sideEffects=true;return this}addOptions(v){if(!this.options){this.type=ae;this.options=[];this.sideEffects=true}for(const I of v){this.options.push(I)}return this}setItems(v){this.type=ge;this.items=v;this.sideEffects=v.some((v=>v.couldHaveSideEffects()));return this}setArray(v){this.type=be;this.array=v;this.sideEffects=false;return this}setTemplateString(v,I,P){this.type=Ce;this.quasis=v;this.parts=I;this.templateStringKind=P;this.sideEffects=I.some((v=>v.sideEffects));return this}setTruthy(){this.falsy=false;this.truthy=true;this.nullish=false;return this}setFalsy(){this.falsy=true;this.truthy=false;return this}setNullish(v){this.nullish=v;if(v)return this.setFalsy();return this}setRange(v){this.range=v;return this}setSideEffects(v=true){this.sideEffects=v;return this}setExpression(v){this.expression=v;return this}}BasicEvaluatedExpression.isValidRegExpFlags=v=>{const I=v.length;if(I===0)return true;if(I>4)return false;let P=0;for(let R=0;R<I;R++)switch(v.charCodeAt(R)){case 103:if(P&8)return false;P|=8;break;case 105:if(P&4)return false;P|=4;break;case 109:if(P&2)return false;P|=2;break;case 121:if(P&1)return false;P|=1;break;default:return false}return true};v.exports=BasicEvaluatedExpression},52326:function(v,I,P){"use strict";const R=P(59818);const getAllChunks=(v,I,P)=>{const $=new Set([v]);const L=new Set;for(const v of $){for(const R of v.chunks){if(R===I)continue;if(R===P)continue;L.add(R)}for(const I of v.parentsIterable){if(I instanceof R)$.add(I)}}return L};v.exports.getAllChunks=getAllChunks},7947:function(v,I,P){"use strict";const{ConcatSource:R,RawSource:$}=P(51255);const L=P(5205);const q=P(57227);const{getUndoPath:K}=P(46579);const{getChunkFilenameTemplate:ae,getCompilationHooks:ge}=P(36926);const{generateEntryStartup:be,updateHashForEntryStartup:xe}=P(46511);class CommonJsChunkFormatPlugin{apply(v){v.hooks.thisCompilation.tap("CommonJsChunkFormatPlugin",(v=>{v.hooks.additionalChunkRuntimeRequirements.tap("CommonJsChunkFormatPlugin",((v,I,{chunkGraph:P})=>{if(v.hasRuntime())return;if(P.getNumberOfEntryModules(v)>0){I.add(L.require);I.add(L.startupEntrypoint);I.add(L.externalInstallChunk)}}));const I=ge(v);I.renderChunk.tap("CommonJsChunkFormatPlugin",((P,ge)=>{const{chunk:xe,chunkGraph:ve,runtimeTemplate:Ce}=ge;const Ne=new R;Ne.add(`exports.id = ${JSON.stringify(xe.id)};\n`);Ne.add(`exports.ids = ${JSON.stringify(xe.ids)};\n`);Ne.add("exports.modules = ");Ne.add(P);Ne.add(";\n");const He=ve.getChunkRuntimeModulesInOrder(xe);if(He.length>0){Ne.add("exports.runtime =\n");Ne.add(q.renderChunkRuntimeModules(He,ge))}const Qe=Array.from(ve.getChunkEntryModulesWithChunkGroupIterable(xe));if(Qe.length>0){const P=Qe[0][1].getRuntimeChunk();const q=v.getPath(ae(xe,v.outputOptions),{chunk:xe,contentHashType:"javascript"}).replace(/^\/+/g,"").split("/");const He=v.getPath(ae(P,v.outputOptions),{chunk:P,contentHashType:"javascript"}).replace(/^\/+/g,"").split("/");while(q.length>1&&He.length>1&&q[0]===He[0]){q.shift();He.shift()}const Je=He.join("/");const Ve=K(q.join("/"),Je,true)+Je;const Ke=new R;Ke.add(`(${Ce.supportsArrowFunction()?"() => ":"function() "}{\n`);Ke.add("var exports = {};\n");Ke.add(Ne);Ke.add(";\n\n// load runtime\n");Ke.add(`var ${L.require} = require(${JSON.stringify(Ve)});\n`);Ke.add(`${L.externalInstallChunk}(exports);\n`);const Ye=new $(be(ve,Ce,Qe,xe,false));Ke.add(I.renderStartup.call(Ye,Qe[Qe.length-1][0],{...ge,inlined:false}));Ke.add("\n})()");return Ke}return Ne}));I.chunkHash.tap("CommonJsChunkFormatPlugin",((v,I,{chunkGraph:P})=>{if(v.hasRuntime())return;I.update("CommonJsChunkFormatPlugin");I.update("1");const R=Array.from(P.getChunkEntryModulesWithChunkGroupIterable(v));xe(I,P,R,v)}))}))}}v.exports=CommonJsChunkFormatPlugin},19353:function(v,I,P){"use strict";const R=new WeakMap;const getEnabledTypes=v=>{let I=R.get(v);if(I===undefined){I=new Set;R.set(v,I)}return I};class EnableChunkLoadingPlugin{constructor(v){this.type=v}static setEnabled(v,I){getEnabledTypes(v).add(I)}static checkEnabled(v,I){if(!getEnabledTypes(v).has(I)){throw new Error(`Chunk loading type "${I}" is not enabled. `+"EnableChunkLoadingPlugin need to be used to enable this type of chunk loading. "+'This usually happens through the "output.enabledChunkLoadingTypes" option. '+'If you are using a function as entry which sets "chunkLoading", you need to add all potential chunk loading types to "output.enabledChunkLoadingTypes". '+`These types are enabled: ${Array.from(getEnabledTypes(v)).join(", ")}`)}}apply(v){const{type:I}=this;const R=getEnabledTypes(v);if(R.has(I))return;R.add(I);if(typeof I==="string"){switch(I){case"jsonp":{const I=P(1503);(new I).apply(v);break}case"import-scripts":{const I=P(61086);(new I).apply(v);break}case"require":{const I=P(6241);new I({asyncChunkLoading:false}).apply(v);break}case"async-node":{const I=P(6241);new I({asyncChunkLoading:true}).apply(v);break}case"import":case"universal":{const I=P(44329);(new I).apply(v);break}default:throw new Error(`Unsupported chunk loading type ${I}.\nPlugins which provide custom chunk loading types must call EnableChunkLoadingPlugin.setEnabled(compiler, type) to disable this error.`)}}else{}}}v.exports=EnableChunkLoadingPlugin},85014:function(v,I,P){"use strict";const R=P(73837);const{RawSource:$,ReplaceSource:L}=P(51255);const q=P(52402);const K=P(89959);const{JS_TYPES:ae}=P(30021);const ge=P(23948);const be=R.deprecate(((v,I,P)=>v.getInitFragments(I,P)),"DependencyTemplate.getInitFragment is deprecated (use apply(dep, source, { initFragments }) instead)","DEP_WEBPACK_JAVASCRIPT_GENERATOR_GET_INIT_FRAGMENTS");class JavascriptGenerator extends q{getTypes(v){return ae}getSize(v,I){const P=v.originalSource();if(!P){return 39}return P.size()}getConcatenationBailoutReason(v,I){if(!v.buildMeta||v.buildMeta.exportsType!=="namespace"||v.presentationalDependencies===undefined||!v.presentationalDependencies.some((v=>v instanceof ge))){return"Module is not an ECMAScript module"}if(v.buildInfo&&v.buildInfo.moduleConcatenationBailout){return`Module uses ${v.buildInfo.moduleConcatenationBailout}`}}generate(v,I){const P=v.originalSource();if(!P){return new $("throw new Error('No source available');")}const R=new L(P);const q=[];this.sourceModule(v,q,R,I);return K.addToSource(R,q,I)}sourceModule(v,I,P,R){for(const $ of v.dependencies){this.sourceDependency(v,$,I,P,R)}if(v.presentationalDependencies!==undefined){for(const $ of v.presentationalDependencies){this.sourceDependency(v,$,I,P,R)}}for(const $ of v.blocks){this.sourceBlock(v,$,I,P,R)}}sourceBlock(v,I,P,R,$){for(const L of I.dependencies){this.sourceDependency(v,L,P,R,$)}for(const L of I.blocks){this.sourceBlock(v,L,P,R,$)}}sourceDependency(v,I,P,R,$){const L=I.constructor;const q=$.dependencyTemplates.get(L);if(!q){throw new Error(`No template for dependency: ${I.constructor.name}`)}let K;const ae={runtimeTemplate:$.runtimeTemplate,dependencyTemplates:$.dependencyTemplates,moduleGraph:$.moduleGraph,chunkGraph:$.chunkGraph,module:v,runtime:$.runtime,runtimeRequirements:$.runtimeRequirements,concatenationScope:$.concatenationScope,codeGenerationResults:$.codeGenerationResults,initFragments:P,get chunkInitFragments(){if(!K){const v=$.getData();K=v.get("chunkInitFragments");if(!K){K=[];v.set("chunkInitFragments",K)}}return K}};q.apply(I,R,ae);if("getInitFragments"in q){const v=be(q,I,ae);if(v){for(const I of v){P.push(I)}}}}}v.exports=JavascriptGenerator},36926:function(v,I,P){"use strict";const R=P(12836);const{SyncWaterfallHook:$,SyncHook:L,SyncBailHook:q}=P(84891);const K=P(26144);const{ConcatSource:ae,OriginalSource:ge,PrefixSource:be,RawSource:xe,CachedSource:ve,ReplaceSource:Ce}=P(51255);const Ne=P(29327);const{tryRunOrWebpackError:He}=P(73404);const Qe=P(59336);const Je=P(89959);const{JAVASCRIPT_MODULE_TYPE_AUTO:Ve,JAVASCRIPT_MODULE_TYPE_DYNAMIC:Ke,JAVASCRIPT_MODULE_TYPE_ESM:Ye,WEBPACK_MODULE_TYPE_RUNTIME:Xe}=P(6041);const Ze=P(5205);const et=P(57227);const{last:tt,someInIterable:nt}=P(57031);const st=P(89453);const{compareModulesByIdOrIdentifier:rt}=P(21398);const{getPathInAst:ot,getAllReferences:it,RESERVED_NAMES:at,findNewName:ct,addScopeSymbols:lt,getUsedNamesInScopeInfo:ut}=P(27297);const pt=P(12471);const dt=P(64307);const{intersectRuntime:ft}=P(86620);const ht=P(85014);const mt=P(31384);const chunkHasJs=(v,I)=>{if(I.getNumberOfEntryModules(v)>0)return true;return Boolean(I.getChunkModulesIterableBySourceType(v,"javascript"))};const chunkHasRuntimeOrJs=(v,I)=>{if(I.getChunkModulesIterableBySourceType(v,Xe))return true;return Boolean(I.getChunkModulesIterableBySourceType(v,"javascript"))};const printGeneratedCodeForStack=(v,I)=>{const P=I.split("\n");const R=`${P.length}`.length;return`\n\nGenerated code for ${v.identifier()}\n${P.map(((v,I,P)=>{const $=`${I+1}`;return`${" ".repeat(R-$.length)}${$} | ${v}`})).join("\n")}`};const gt=new WeakMap;const yt="JavascriptModulesPlugin";class JavascriptModulesPlugin{static getCompilationHooks(v){if(!(v instanceof Ne)){throw new TypeError("The 'compilation' argument must be an instance of Compilation")}let I=gt.get(v);if(I===undefined){I={renderModuleContent:new $(["source","module","renderContext"]),renderModuleContainer:new $(["source","module","renderContext"]),renderModulePackage:new $(["source","module","renderContext"]),render:new $(["source","renderContext"]),renderContent:new $(["source","renderContext"]),renderStartup:new $(["source","module","startupRenderContext"]),renderChunk:new $(["source","renderContext"]),renderMain:new $(["source","renderContext"]),renderRequire:new $(["code","renderContext"]),inlineInRuntimeBailout:new q(["module","renderContext"]),embedInRuntimeBailout:new q(["module","renderContext"]),strictRuntimeBailout:new q(["renderContext"]),chunkHash:new L(["chunk","hash","context"]),useSourceMap:new q(["chunk","renderContext"])};gt.set(v,I)}return I}constructor(v={}){this.options=v;this._moduleFactoryCache=new WeakMap}apply(v){v.hooks.compilation.tap(yt,((v,{normalModuleFactory:I})=>{const P=JavascriptModulesPlugin.getCompilationHooks(v);I.hooks.createParser.for(Ve).tap(yt,(v=>new mt("auto")));I.hooks.createParser.for(Ke).tap(yt,(v=>new mt("script")));I.hooks.createParser.for(Ye).tap(yt,(v=>new mt("module")));I.hooks.createGenerator.for(Ve).tap(yt,(()=>new ht));I.hooks.createGenerator.for(Ke).tap(yt,(()=>new ht));I.hooks.createGenerator.for(Ye).tap(yt,(()=>new ht));v.hooks.renderManifest.tap(yt,((I,R)=>{const{hash:$,chunk:L,chunkGraph:q,moduleGraph:K,runtimeTemplate:ae,dependencyTemplates:ge,outputOptions:be,codeGenerationResults:xe}=R;const ve=L instanceof Qe?L:null;const Ce=JavascriptModulesPlugin.getChunkFilenameTemplate(L,be);let Ne;if(ve){Ne=()=>this.renderChunk({chunk:L,dependencyTemplates:ge,runtimeTemplate:ae,moduleGraph:K,chunkGraph:q,codeGenerationResults:xe,strictMode:ae.isModule()},P)}else if(L.hasRuntime()){if(!chunkHasRuntimeOrJs(L,q)){return I}Ne=()=>this.renderMain({hash:$,chunk:L,dependencyTemplates:ge,runtimeTemplate:ae,moduleGraph:K,chunkGraph:q,codeGenerationResults:xe,strictMode:ae.isModule()},P,v)}else{if(!chunkHasJs(L,q)){return I}Ne=()=>this.renderChunk({chunk:L,dependencyTemplates:ge,runtimeTemplate:ae,moduleGraph:K,chunkGraph:q,codeGenerationResults:xe,strictMode:ae.isModule()},P)}I.push({render:Ne,filenameTemplate:Ce,pathOptions:{hash:$,runtime:L.runtime,chunk:L,contentHashType:"javascript"},info:{javascriptModule:v.runtimeTemplate.isModule()},identifier:ve?`hotupdatechunk${L.id}`:`chunk${L.id}`,hash:L.contentHash.javascript});return I}));v.hooks.chunkHash.tap(yt,((v,I,R)=>{P.chunkHash.call(v,I,R);if(v.hasRuntime()){this.updateHashWithBootstrap(I,{hash:"0000",chunk:v,codeGenerationResults:R.codeGenerationResults,chunkGraph:R.chunkGraph,moduleGraph:R.moduleGraph,runtimeTemplate:R.runtimeTemplate},P)}}));v.hooks.contentHash.tap(yt,(I=>{const{chunkGraph:R,codeGenerationResults:$,moduleGraph:L,runtimeTemplate:q,outputOptions:{hashSalt:K,hashDigest:ae,hashDigestLength:ge,hashFunction:be}}=v;const xe=pt(be);if(K)xe.update(K);if(I.hasRuntime()){this.updateHashWithBootstrap(xe,{hash:"0000",chunk:I,codeGenerationResults:$,chunkGraph:v.chunkGraph,moduleGraph:v.moduleGraph,runtimeTemplate:v.runtimeTemplate},P)}else{xe.update(`${I.id} `);xe.update(I.ids?I.ids.join(","):"")}P.chunkHash.call(I,xe,{chunkGraph:R,codeGenerationResults:$,moduleGraph:L,runtimeTemplate:q});const ve=R.getChunkModulesIterableBySourceType(I,"javascript");if(ve){const v=new st;for(const P of ve){v.add(R.getModuleHash(P,I.runtime))}v.updateHash(xe)}const Ce=R.getChunkModulesIterableBySourceType(I,Xe);if(Ce){const v=new st;for(const P of Ce){v.add(R.getModuleHash(P,I.runtime))}v.updateHash(xe)}const Ne=xe.digest(ae);I.contentHash.javascript=dt(Ne,ge)}));v.hooks.additionalTreeRuntimeRequirements.tap(yt,((v,I,{chunkGraph:P})=>{if(!I.has(Ze.startupNoDefault)&&P.hasChunkEntryDependentChunks(v)){I.add(Ze.onChunksLoaded);I.add(Ze.exports);I.add(Ze.require)}}));v.hooks.executeModule.tap(yt,((v,I)=>{const P=v.codeGenerationResult.sources.get("javascript");if(P===undefined)return;const{module:R}=v;const $=P.source();const L=K.runInThisContext(`(function(${R.moduleArgument}, ${R.exportsArgument}, ${Ze.require}) {\n${$}\n/**/})`,{filename:R.identifier(),lineOffset:-1});const q=v.moduleObject;try{L.call(q.exports,q,q.exports,I.__webpack_require__)}catch(I){I.stack+=printGeneratedCodeForStack(v.module,$);throw I}}));v.hooks.executeModule.tap(yt,((v,I)=>{const P=v.codeGenerationResult.sources.get("runtime");if(P===undefined)return;let R=P.source();if(typeof R!=="string")R=R.toString();const $=K.runInThisContext(`(function(${Ze.require}) {\n${R}\n/**/})`,{filename:v.module.identifier(),lineOffset:-1});try{$.call(null,I.__webpack_require__)}catch(I){I.stack+=printGeneratedCodeForStack(v.module,R);throw I}}))}))}static getChunkFilenameTemplate(v,I){if(v.filenameTemplate){return v.filenameTemplate}else if(v instanceof Qe){return I.hotUpdateChunkFilename}else if(v.canBeInitial()){return I.filename}return I.chunkFilename}renderModule(v,I,P,R){const{chunk:$,chunkGraph:L,runtimeTemplate:q,codeGenerationResults:K,strictMode:ge}=I;try{const be=K.get(v,$.runtime);const xe=be.sources.get("javascript");if(!xe)return null;if(be.data!==undefined){const v=be.data.get("chunkInitFragments");if(v){for(const P of v)I.chunkInitFragments.push(P)}}const Ce=He((()=>P.renderModuleContent.call(xe,v,I)),"JavascriptModulesPlugin.getCompilationHooks().renderModuleContent");let Ne;if(R){const R=L.getModuleRuntimeRequirements(v,$.runtime);const K=R.has(Ze.module);const be=R.has(Ze.exports);const xe=R.has(Ze.require)||R.has(Ze.requireScope);const Qe=R.has(Ze.thisAsExports);const Je=v.buildInfo.strict&&!ge;const Ve=this._moduleFactoryCache.get(Ce);let Ke;if(Ve&&Ve.needModule===K&&Ve.needExports===be&&Ve.needRequire===xe&&Ve.needThisAsExports===Qe&&Ve.needStrict===Je){Ke=Ve.source}else{const I=new ae;const P=[];if(be||xe||K)P.push(K?v.moduleArgument:`__unused_webpack_${v.moduleArgument}`);if(be||xe)P.push(be?v.exportsArgument:`__unused_webpack_${v.exportsArgument}`);if(xe)P.push(Ze.require);if(!Qe&&q.supportsArrowFunction()){I.add(`/***/ ((${P.join(", ")}) => {\n\n`)}else{I.add(`/***/ (function(${P.join(", ")}) {\n\n`)}if(Je){I.add('"use strict";\n')}I.add(Ce);I.add("\n\n/***/ })");Ke=new ve(I);this._moduleFactoryCache.set(Ce,{source:Ke,needModule:K,needExports:be,needRequire:xe,needThisAsExports:Qe,needStrict:Je})}Ne=He((()=>P.renderModuleContainer.call(Ke,v,I)),"JavascriptModulesPlugin.getCompilationHooks().renderModuleContainer")}else{Ne=Ce}return He((()=>P.renderModulePackage.call(Ne,v,I)),"JavascriptModulesPlugin.getCompilationHooks().renderModulePackage")}catch(I){I.module=v;throw I}}renderChunk(v,I){const{chunk:P,chunkGraph:R}=v;const $=R.getOrderedChunkModulesIterableBySourceType(P,"javascript",rt(R));const L=$?Array.from($):[];let q;let K=v.strictMode;if(!K&&L.every((v=>v.buildInfo.strict))){const P=I.strictRuntimeBailout.call(v);q=P?`// runtime can't be in strict mode because ${P}.\n`:'"use strict";\n';if(!P)K=true}const ge={...v,chunkInitFragments:[],strictMode:K};const be=et.renderChunkModules(ge,L,(v=>this.renderModule(v,ge,I,true)))||new xe("{}");let ve=He((()=>I.renderChunk.call(be,ge)),"JavascriptModulesPlugin.getCompilationHooks().renderChunk");ve=He((()=>I.renderContent.call(ve,ge)),"JavascriptModulesPlugin.getCompilationHooks().renderContent");if(!ve){throw new Error("JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderContent plugins should return something")}ve=Je.addToSource(ve,ge.chunkInitFragments,ge);ve=He((()=>I.render.call(ve,ge)),"JavascriptModulesPlugin.getCompilationHooks().render");if(!ve){throw new Error("JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().render plugins should return something")}P.rendered=true;return q?new ae(q,ve,";"):v.runtimeTemplate.isModule()?ve:new ae(ve,";")}renderMain(v,I,P){const{chunk:R,chunkGraph:$,runtimeTemplate:L}=v;const q=$.getTreeRuntimeRequirements(R);const K=L.isIIFE();const ve=this.renderBootstrap(v,I);const Ce=I.useSourceMap.call(R,v);const Ne=Array.from($.getOrderedChunkModulesIterableBySourceType(R,"javascript",rt($))||[]);const Qe=$.getNumberOfEntryModules(R)>0;let Ve;if(ve.allowInlineStartup&&Qe){Ve=new Set($.getChunkEntryModulesIterable(R))}const Ke=new ae;let Ye;if(K){if(L.supportsArrowFunction()){Ke.add("/******/ (() => { // webpackBootstrap\n")}else{Ke.add("/******/ (function() { // webpackBootstrap\n")}Ye="/******/ \t"}else{Ye="/******/ "}let Xe=v.strictMode;if(!Xe&&Ne.every((v=>v.buildInfo.strict))){const P=I.strictRuntimeBailout.call(v);if(P){Ke.add(`${Ye}// runtime can't be in strict mode because ${P}.\n`)}else{Xe=true;Ke.add(`${Ye}"use strict";\n`)}}const nt={...v,chunkInitFragments:[],strictMode:Xe};const st=et.renderChunkModules(nt,Ve?Ne.filter((v=>!Ve.has(v))):Ne,(v=>this.renderModule(v,nt,I,true)),Ye);if(st||q.has(Ze.moduleFactories)||q.has(Ze.moduleFactoriesAddOnly)||q.has(Ze.require)){Ke.add(`${Ye}var __webpack_modules__ = (`);Ke.add(st||"{}");Ke.add(");\n");Ke.add("/************************************************************************/\n")}if(ve.header.length>0){const v=`${et.asString(ve.header)}\n`;Ke.add(new be(Ye,Ce?new ge(v,"webpack/bootstrap"):new xe(v)));Ke.add("/************************************************************************/\n")}const ot=v.chunkGraph.getChunkRuntimeModulesInOrder(R);if(ot.length>0){Ke.add(new be(Ye,et.renderRuntimeModules(ot,nt)));Ke.add("/************************************************************************/\n");for(const v of ot){P.codeGeneratedModules.add(v)}}if(Ve){if(ve.beforeStartup.length>0){const v=`${et.asString(ve.beforeStartup)}\n`;Ke.add(new be(Ye,Ce?new ge(v,"webpack/before-startup"):new xe(v)))}const K=tt(Ve);const He=new ae;if(q.has(Ze.exports)){He.add(`var ${Ze.exports} = {};\n`)}const Qe=P.options.optimization.avoidEntryIife;let Je=false;if(Qe){Je=this.getRenamedInlineModule(Ne,v,Ve,nt,I,Xe,Boolean(st))}for(const P of Ve){const q=Je?Je.get(P):this.renderModule(P,nt,I,false);if(q){const ae=!Xe&&P.buildInfo.strict;const ge=$.getModuleRuntimeRequirements(P,R.runtime);const be=ge.has(Ze.exports);const xe=be&&P.exportsArgument===Ze.exports;const ve=ae?"it needs to be in strict mode.":Ve.size>1?"it needs to be isolated against other entry modules.":st&&!Je?"it needs to be isolated against other modules in the chunk.":be&&!xe?`it uses a non-standard name for the exports (${P.exportsArgument}).`:I.embedInRuntimeBailout.call(P,v);let Ce;if(ve!==undefined){He.add(`// This entry needs to be wrapped in an IIFE because ${ve}\n`);const v=L.supportsArrowFunction();if(v){He.add("(() => {\n");Ce="\n})();\n\n"}else{He.add("!function() {\n");Ce="\n}();\n"}if(ae)He.add('"use strict";\n')}else{Ce="\n"}if(be){if(P!==K)He.add(`var ${P.exportsArgument} = {};\n`);else if(P.exportsArgument!==Ze.exports)He.add(`var ${P.exportsArgument} = ${Ze.exports};\n`)}He.add(q);He.add(Ce)}}if(q.has(Ze.onChunksLoaded)){He.add(`${Ze.exports} = ${Ze.onChunksLoaded}(${Ze.exports});\n`)}Ke.add(I.renderStartup.call(He,K,{...v,inlined:true}));if(ve.afterStartup.length>0){const v=`${et.asString(ve.afterStartup)}\n`;Ke.add(new be(Ye,Ce?new ge(v,"webpack/after-startup"):new xe(v)))}}else{const P=tt($.getChunkEntryModulesIterable(R));const L=Ce?(v,I)=>new ge(et.asString(v),I):v=>new xe(et.asString(v));Ke.add(new be(Ye,new ae(L(ve.beforeStartup,"webpack/before-startup"),"\n",I.renderStartup.call(L(ve.startup.concat(""),"webpack/startup"),P,{...v,inlined:false}),L(ve.afterStartup,"webpack/after-startup"),"\n")))}if(Qe&&q.has(Ze.returnExportsFromRuntime)){Ke.add(`${Ye}return ${Ze.exports};\n`)}if(K){Ke.add("/******/ })()\n")}let it=He((()=>I.renderMain.call(Ke,v)),"JavascriptModulesPlugin.getCompilationHooks().renderMain");if(!it){throw new Error("JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderMain plugins should return something")}it=He((()=>I.renderContent.call(it,v)),"JavascriptModulesPlugin.getCompilationHooks().renderContent");if(!it){throw new Error("JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderContent plugins should return something")}it=Je.addToSource(it,nt.chunkInitFragments,nt);it=He((()=>I.render.call(it,v)),"JavascriptModulesPlugin.getCompilationHooks().render");if(!it){throw new Error("JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().render plugins should return something")}R.rendered=true;return K?new ae(it,";"):it}updateHashWithBootstrap(v,I,P){const R=this.renderBootstrap(I,P);for(const I of Object.keys(R)){const P=I;v.update(P);if(Array.isArray(R[P])){for(const I of R[P]){v.update(I)}}else{v.update(JSON.stringify(R[P]))}}}renderBootstrap(v,I){const{chunkGraph:P,codeGenerationResults:R,moduleGraph:$,chunk:L,runtimeTemplate:q}=v;const K=P.getTreeRuntimeRequirements(L);const ae=K.has(Ze.require);const ge=K.has(Ze.moduleCache);const be=K.has(Ze.moduleFactories);const xe=K.has(Ze.module);const ve=K.has(Ze.requireScope);const Ce=K.has(Ze.interceptModuleExecution);const Ne=ae||Ce||xe;const He={header:[],beforeStartup:[],startup:[],afterStartup:[],allowInlineStartup:true};const{header:Qe,startup:Je,beforeStartup:Ve,afterStartup:Ke}=He;if(He.allowInlineStartup&&be){Je.push("// module factories are used so entry inlining is disabled");He.allowInlineStartup=false}if(He.allowInlineStartup&&ge){Je.push("// module cache are used so entry inlining is disabled");He.allowInlineStartup=false}if(He.allowInlineStartup&&Ce){Je.push("// module execution is intercepted so entry inlining is disabled");He.allowInlineStartup=false}if(Ne||ge){Qe.push("// The module cache");Qe.push("var __webpack_module_cache__ = {};");Qe.push("")}if(Ne){Qe.push("// The require function");Qe.push(`function ${Ze.require}(moduleId) {`);Qe.push(et.indent(this.renderRequire(v,I)));Qe.push("}");Qe.push("")}else if(K.has(Ze.requireScope)){Qe.push("// The require scope");Qe.push(`var ${Ze.require} = {};`);Qe.push("")}if(be||K.has(Ze.moduleFactoriesAddOnly)){Qe.push("// expose the modules object (__webpack_modules__)");Qe.push(`${Ze.moduleFactories} = __webpack_modules__;`);Qe.push("")}if(ge){Qe.push("// expose the module cache");Qe.push(`${Ze.moduleCache} = __webpack_module_cache__;`);Qe.push("")}if(Ce){Qe.push("// expose the module execution interceptor");Qe.push(`${Ze.interceptModuleExecution} = [];`);Qe.push("")}if(!K.has(Ze.startupNoDefault)){if(P.getNumberOfEntryModules(L)>0){const K=[];const ae=P.getTreeRuntimeRequirements(L);K.push("// Load entry module and return exports");let ge=P.getNumberOfEntryModules(L);for(const[be,xe]of P.getChunkEntryModulesWithChunkGroupIterable(L)){if(!P.getModuleSourceTypes(be).has("javascript")){ge--;continue}const Ce=xe.chunks.filter((v=>v!==L));if(He.allowInlineStartup&&Ce.length>0){K.push("// This entry module depends on other loaded chunks and execution need to be delayed");He.allowInlineStartup=false}if(He.allowInlineStartup&&nt($.getIncomingConnectionsByOriginModule(be),(([v,I])=>v&&I.some((v=>v.isTargetActive(L.runtime)))&&nt(P.getModuleRuntimes(v),(v=>ft(v,L.runtime)!==undefined))))){K.push("// This entry module is referenced by other modules so it can't be inlined");He.allowInlineStartup=false}let Qe;if(R.has(be,L.runtime)){const v=R.get(be,L.runtime);Qe=v.data}if(He.allowInlineStartup&&(!Qe||!Qe.get("topLevelDeclarations"))&&(!be.buildInfo||!be.buildInfo.topLevelDeclarations)){K.push("// This entry module doesn't tell about it's top-level declarations so it can't be inlined");He.allowInlineStartup=false}if(He.allowInlineStartup){const P=I.inlineInRuntimeBailout.call(be,v);if(P!==undefined){K.push(`// This entry module can't be inlined because ${P}`);He.allowInlineStartup=false}}ge--;const Je=P.getModuleId(be);const Ve=P.getModuleRuntimeRequirements(be,L.runtime);let Ke=JSON.stringify(Je);if(ae.has(Ze.entryModuleId)){Ke=`${Ze.entryModuleId} = ${Ke}`}if(He.allowInlineStartup&&Ve.has(Ze.module)){He.allowInlineStartup=false;K.push("// This entry module used 'module' so it can't be inlined")}if(Ce.length>0){K.push(`${ge===0?`var ${Ze.exports} = `:""}${Ze.onChunksLoaded}(undefined, ${JSON.stringify(Ce.map((v=>v.id)))}, ${q.returningFunction(`${Ze.require}(${Ke})`)})`)}else if(Ne){K.push(`${ge===0?`var ${Ze.exports} = `:""}${Ze.require}(${Ke});`)}else{if(ge===0)K.push(`var ${Ze.exports} = {};`);if(ve){K.push(`__webpack_modules__[${Ke}](0, ${ge===0?Ze.exports:"{}"}, ${Ze.require});`)}else if(Ve.has(Ze.exports)){K.push(`__webpack_modules__[${Ke}](0, ${ge===0?Ze.exports:"{}"});`)}else{K.push(`__webpack_modules__[${Ke}]();`)}}}if(ae.has(Ze.onChunksLoaded)){K.push(`${Ze.exports} = ${Ze.onChunksLoaded}(${Ze.exports});`)}if(ae.has(Ze.startup)||ae.has(Ze.startupOnlyBefore)&&ae.has(Ze.startupOnlyAfter)){He.allowInlineStartup=false;Qe.push("// the startup function");Qe.push(`${Ze.startup} = ${q.basicFunction("",[...K,`return ${Ze.exports};`])};`);Qe.push("");Je.push("// run startup");Je.push(`var ${Ze.exports} = ${Ze.startup}();`)}else if(ae.has(Ze.startupOnlyBefore)){Qe.push("// the startup function");Qe.push(`${Ze.startup} = ${q.emptyFunction()};`);Ve.push("// run runtime startup");Ve.push(`${Ze.startup}();`);Je.push("// startup");Je.push(et.asString(K))}else if(ae.has(Ze.startupOnlyAfter)){Qe.push("// the startup function");Qe.push(`${Ze.startup} = ${q.emptyFunction()};`);Je.push("// startup");Je.push(et.asString(K));Ke.push("// run runtime startup");Ke.push(`${Ze.startup}();`)}else{Je.push("// startup");Je.push(et.asString(K))}}else if(K.has(Ze.startup)||K.has(Ze.startupOnlyBefore)||K.has(Ze.startupOnlyAfter)){Qe.push("// the startup function","// It's empty as no entry modules are in this chunk",`${Ze.startup} = ${q.emptyFunction()};`,"")}}else if(K.has(Ze.startup)||K.has(Ze.startupOnlyBefore)||K.has(Ze.startupOnlyAfter)){He.allowInlineStartup=false;Qe.push("// the startup function","// It's empty as some runtime module handles the default behavior",`${Ze.startup} = ${q.emptyFunction()};`);Je.push("// run startup");Je.push(`var ${Ze.exports} = ${Ze.startup}();`)}return He}renderRequire(v,I){const{chunk:P,chunkGraph:R,runtimeTemplate:{outputOptions:$}}=v;const L=R.getTreeRuntimeRequirements(P);const q=L.has(Ze.interceptModuleExecution)?et.asString([`var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: ${Ze.require} };`,`${Ze.interceptModuleExecution}.forEach(function(handler) { handler(execOptions); });`,"module = execOptions.module;","execOptions.factory.call(module.exports, module, module.exports, execOptions.require);"]):L.has(Ze.thisAsExports)?et.asString([`__webpack_modules__[moduleId].call(module.exports, module, module.exports, ${Ze.require});`]):et.asString([`__webpack_modules__[moduleId](module, module.exports, ${Ze.require});`]);const K=L.has(Ze.moduleId);const ae=L.has(Ze.moduleLoaded);const ge=et.asString(["// Check if module is in cache","var cachedModule = __webpack_module_cache__[moduleId];","if (cachedModule !== undefined) {",$.strictModuleErrorHandling?et.indent(["if (cachedModule.error !== undefined) throw cachedModule.error;","return cachedModule.exports;"]):et.indent("return cachedModule.exports;"),"}","// Create a new module (and put it into the cache)","var module = __webpack_module_cache__[moduleId] = {",et.indent([K?"id: moduleId,":"// no module.id needed",ae?"loaded: false,":"// no module.loaded needed","exports: {}"]),"};","",$.strictModuleExceptionHandling?et.asString(["// Execute the module function","var threw = true;","try {",et.indent([q,"threw = false;"]),"} finally {",et.indent(["if(threw) delete __webpack_module_cache__[moduleId];"]),"}"]):$.strictModuleErrorHandling?et.asString(["// Execute the module function","try {",et.indent(q),"} catch(e) {",et.indent(["module.error = e;","throw e;"]),"}"]):et.asString(["// Execute the module function",q]),ae?et.asString(["","// Flag the module as loaded",`${Ze.moduleLoaded} = true;`,""]):"","// Return the exports of the module","return module.exports;"]);return He((()=>I.renderRequire.call(ge,v)),"JavascriptModulesPlugin.getCompilationHooks().renderRequire")}getRenamedInlineModule(v,I,P,$,L,q,K){const ae=!q&&v.every((v=>v.buildInfo.strict));const ge=P.size>1;const be=P.size===1&&K;if(ge||ae||!be){return false}const xe=new Map;const{runtimeTemplate:ve}=I;const Ne=new Map;const He=new Set;for(const I of v){const v=P&&P.has(I);const q=this.renderModule(I,$,L,!v);if(!q)continue;const K=q.source();const ae=mt._parse(K,{sourceType:"auto"});const ge=R.analyze(ae,{ecmaVersion:6,sourceType:"module",optimistic:true,ignoreEval:true});const be=ge.acquire(ae);if(P&&P.has(I)){const v=be.childScopes[0];Ne.set(I,{source:q,ast:ae,module:I,variables:new Set(v.variables),through:new Set(v.through),usedInNonInlined:new Set,moduleScope:v})}else{for(const v of be.through){He.add(v.identifier.name)}}}for(const[,{variables:v,usedInNonInlined:I}]of Ne){for(const P of v){if(He.has(P.name)||at.has(P.name)){I.add(P)}}}for(const[v,I]of Ne){const{ast:P,source:R,usedInNonInlined:$}=I;const L=new Ce(R);if($.size===0){xe.set(v,L);continue}const q=Ne.get(v);const K=new Set(Array.from(q.through,(v=>v.identifier.name)));for(const v of $){K.add(v.name)}for(const I of q.variables){K.add(I.name);const R=it(I);const $=new Set(R.map((v=>v.identifier)).concat(I.identifiers));const ae=new Map;const ge=new Set;const be=I.name;const{usedNames:xe,alreadyCheckedScopes:Ce}=ut(ae,q.module.identifier(),be);if(K.has(be)||xe.has(be)){const R=it(I);for(const v of R){lt(v.from,xe,Ce,ge)}const q=ct(I.name,K,xe,v.readableIdentifier(ve.requestShortener));K.add(q);for(const v of $){const I=v.range;const R=ot(P,v);if(R&&R.length>1){const v=R[1].type==="AssignmentPattern"&&R[1].left===R[0]?R[2]:R[1];if(v.type==="Property"&&v.shorthand){L.insert(I[1],`: ${q}`);continue}}L.replace(I[0],I[1]-1,q)}}else{K.add(be)}}xe.set(v,L)}return xe}}v.exports=JavascriptModulesPlugin;v.exports.chunkHasJs=chunkHasJs},31384:function(v,I,P){"use strict";const{Parser:R,tokTypes:$}=P(31988);const{SyncBailHook:L,HookMap:q}=P(84891);const K=P(26144);const ae=P(33157);const ge=P(9022);const be=P(1671);const{webpackCommentRegExp:xe,createMagicCommentContext:ve}=P(47559);const Ce=P(13594);const Ne=P(28665);const He=[];const Qe=1;const Je=2;const Ve=3;const Ke=Symbol("assert");const importAssertions=v=>class extends v{parseWithClause(){const v=[];const I=this.value==="assert";if(I){if(!this.eat($.name)){return v}}else if(!this.eat($._with)){return v}this.expect($.braceL);const P={};let R=true;while(!this.eat($.braceR)){if(!R){this.expect($.comma);if(this.afterTrailingComma($.braceR)){break}}else{R=false}const I=this.parseImportAttribute();const L=I.key.type==="Identifier"?I.key.name:I.key.value;if(Object.prototype.hasOwnProperty.call(P,L)){this.raiseRecoverable(I.key.start,`Duplicate attribute key '${L}'`)}P[L]=true;v.push(I)}if(I){v[Ke]=true}return v}};const Ye=R.extend(importAssertions);const getImportAttributes=v=>{if(v.type==="ImportExpression"){if(v.options&&v.options.type==="ObjectExpression"&&v.options.properties[0]&&v.options.properties[0].type==="Property"&&v.options.properties[0].key.type==="Identifier"&&(v.options.properties[0].key.name==="with"||v.options.properties[0].key.name==="assert")&&v.options.properties[0].value.type==="ObjectExpression"&&v.options.properties[0].value.properties.length>0){const I=v.options.properties[0].value.properties;const P={};for(const v of I){const I=v.key.type==="Identifier"?v.key.name:v.key.value;P[I]=v.value.value}const R=v.options.properties[0].key.type==="Identifier"?v.options.properties[0].key.name:v.options.properties[0].key.value;if(R==="assert"){P._isLegacyAssert=true}return P}return}if(v.attributes===undefined||v.attributes.length===0){return}const I={};for(const P of v.attributes){const v=P.key.type==="Identifier"?P.key.name:P.key.value;I[v]=P.value.value}if(v.attributes[Ke]){I._isLegacyAssert=true}return I};class VariableInfo{constructor(v,I,P){this.declaredScope=v;this.freeName=I;this.tagInfo=P}}const joinRanges=(v,I)=>{if(!I)return v;if(!v)return I;return[v[0],I[1]]};const objectAndMembersToName=(v,I)=>{let P=v;for(let v=I.length-1;v>=0;v--){P=`${P}.${I[v]}`}return P};const getRootName=v=>{switch(v.type){case"Identifier":return v.name;case"ThisExpression":return"this";case"MetaProperty":return`${v.meta.name}.${v.property.name}`;default:return undefined}};const Xe={ranges:true,locations:true,ecmaVersion:"latest",sourceType:"module",allowHashBang:true,onComment:undefined};const Ze={options:null,errors:null};class JavascriptParser extends ae{constructor(v="auto"){super();this.hooks=Object.freeze({evaluateTypeof:new q((()=>new L(["expression"]))),evaluate:new q((()=>new L(["expression"]))),evaluateIdentifier:new q((()=>new L(["expression"]))),evaluateDefinedIdentifier:new q((()=>new L(["expression"]))),evaluateNewExpression:new q((()=>new L(["expression"]))),evaluateCallExpression:new q((()=>new L(["expression"]))),evaluateCallExpressionMember:new q((()=>new L(["expression","param"]))),isPure:new q((()=>new L(["expression","commentsStartPosition"]))),preStatement:new L(["statement"]),blockPreStatement:new L(["declaration"]),statement:new L(["statement"]),statementIf:new L(["statement"]),classExtendsExpression:new L(["expression","classDefinition"]),classBodyElement:new L(["element","classDefinition"]),classBodyValue:new L(["expression","element","classDefinition"]),label:new q((()=>new L(["statement"]))),import:new L(["statement","source"]),importSpecifier:new L(["statement","source","exportName","identifierName"]),export:new L(["statement"]),exportImport:new L(["statement","source"]),exportDeclaration:new L(["statement","declaration"]),exportExpression:new L(["statement","declaration"]),exportSpecifier:new L(["statement","identifierName","exportName","index"]),exportImportSpecifier:new L(["statement","source","identifierName","exportName","index"]),preDeclarator:new L(["declarator","statement"]),declarator:new L(["declarator","statement"]),varDeclaration:new q((()=>new L(["declaration"]))),varDeclarationLet:new q((()=>new L(["declaration"]))),varDeclarationConst:new q((()=>new L(["declaration"]))),varDeclarationVar:new q((()=>new L(["declaration"]))),pattern:new q((()=>new L(["pattern"]))),canRename:new q((()=>new L(["initExpression"]))),rename:new q((()=>new L(["initExpression"]))),assign:new q((()=>new L(["expression"]))),assignMemberChain:new q((()=>new L(["expression","members"]))),typeof:new q((()=>new L(["expression"]))),importCall:new L(["expression"]),topLevelAwait:new L(["expression"]),call:new q((()=>new L(["expression"]))),callMemberChain:new q((()=>new L(["expression","members","membersOptionals","memberRanges"]))),memberChainOfCallMemberChain:new q((()=>new L(["expression","calleeMembers","callExpression","members","memberRanges"]))),callMemberChainOfCallMemberChain:new q((()=>new L(["expression","calleeMembers","innerCallExpression","members","memberRanges"]))),optionalChaining:new L(["optionalChaining"]),new:new q((()=>new L(["expression"]))),binaryExpression:new L(["binaryExpression"]),expression:new q((()=>new L(["expression"]))),expressionMemberChain:new q((()=>new L(["expression","members","membersOptionals","memberRanges"]))),unhandledExpressionMemberChain:new q((()=>new L(["expression","members"]))),expressionConditionalOperator:new L(["expression"]),expressionLogicalOperator:new L(["expression"]),program:new L(["ast","comments"]),finish:new L(["ast","comments"])});this.sourceType=v;this.scope=undefined;this.state=undefined;this.comments=undefined;this.semicolons=undefined;this.statementPath=undefined;this.prevStatement=undefined;this.destructuringAssignmentProperties=undefined;this.currentTagData=undefined;this.magicCommentContext=ve();this._initializeEvaluating()}_initializeEvaluating(){this.hooks.evaluate.for("Literal").tap("JavascriptParser",(v=>{const I=v;switch(typeof I.value){case"number":return(new Ne).setNumber(I.value).setRange(I.range);case"bigint":return(new Ne).setBigInt(I.value).setRange(I.range);case"string":return(new Ne).setString(I.value).setRange(I.range);case"boolean":return(new Ne).setBoolean(I.value).setRange(I.range)}if(I.value===null){return(new Ne).setNull().setRange(I.range)}if(I.value instanceof RegExp){return(new Ne).setRegExp(I.value).setRange(I.range)}}));this.hooks.evaluate.for("NewExpression").tap("JavascriptParser",(v=>{const I=v;const P=I.callee;if(P.type!=="Identifier")return;if(P.name!=="RegExp"){return this.callHooksForName(this.hooks.evaluateNewExpression,P.name,I)}else if(I.arguments.length>2||this.getVariableInfo("RegExp")!=="RegExp")return;let R;const $=I.arguments[0];if($){if($.type==="SpreadElement")return;const v=this.evaluateExpression($);if(!v)return;R=v.asString();if(!R)return}else{return(new Ne).setRegExp(new RegExp("")).setRange(I.range)}let L;const q=I.arguments[1];if(q){if(q.type==="SpreadElement")return;const v=this.evaluateExpression(q);if(!v)return;if(!v.isUndefined()){L=v.asString();if(L===undefined||!Ne.isValidRegExpFlags(L))return}}return(new Ne).setRegExp(L?new RegExp(R,L):new RegExp(R)).setRange(I.range)}));this.hooks.evaluate.for("LogicalExpression").tap("JavascriptParser",(v=>{const I=v;const P=this.evaluateExpression(I.left);let R=false;let $;if(I.operator==="&&"){const v=P.asBool();if(v===false)return P.setRange(I.range);R=v===true;$=false}else if(I.operator==="||"){const v=P.asBool();if(v===true)return P.setRange(I.range);R=v===false;$=true}else if(I.operator==="??"){const v=P.asNullish();if(v===false)return P.setRange(I.range);if(v!==true)return;R=true}else return;const L=this.evaluateExpression(I.right);if(R){if(P.couldHaveSideEffects())L.setSideEffects();return L.setRange(I.range)}const q=L.asBool();if($===true&&q===true){return(new Ne).setRange(I.range).setTruthy()}else if($===false&&q===false){return(new Ne).setRange(I.range).setFalsy()}}));const valueAsExpression=(v,I,P)=>{switch(typeof v){case"boolean":return(new Ne).setBoolean(v).setSideEffects(P).setRange(I.range);case"number":return(new Ne).setNumber(v).setSideEffects(P).setRange(I.range);case"bigint":return(new Ne).setBigInt(v).setSideEffects(P).setRange(I.range);case"string":return(new Ne).setString(v).setSideEffects(P).setRange(I.range)}};this.hooks.evaluate.for("BinaryExpression").tap("JavascriptParser",(v=>{const I=v;const handleConstOperation=v=>{const P=this.evaluateExpression(I.left);if(!P.isCompileTimeValue())return;const R=this.evaluateExpression(I.right);if(!R.isCompileTimeValue())return;const $=v(P.asCompileTimeValue(),R.asCompileTimeValue());return valueAsExpression($,I,P.couldHaveSideEffects()||R.couldHaveSideEffects())};const isAlwaysDifferent=(v,I)=>v===true&&I===false||v===false&&I===true;const handleTemplateStringCompare=(v,I,P,R)=>{const getPrefix=v=>{let I="";for(const P of v){const v=P.asString();if(v!==undefined)I+=v;else break}return I};const getSuffix=v=>{let I="";for(let P=v.length-1;P>=0;P--){const R=v[P].asString();if(R!==undefined)I=R+I;else break}return I};const $=getPrefix(v.parts);const L=getPrefix(I.parts);const q=getSuffix(v.parts);const K=getSuffix(I.parts);const ae=Math.min($.length,L.length);const ge=Math.min(q.length,K.length);const be=ae>0&&$.slice(0,ae)!==L.slice(0,ae);const xe=ge>0&&q.slice(-ge)!==K.slice(-ge);if(be||xe){return P.setBoolean(!R).setSideEffects(v.couldHaveSideEffects()||I.couldHaveSideEffects())}};const handleStrictEqualityComparison=v=>{const P=this.evaluateExpression(I.left);const R=this.evaluateExpression(I.right);const $=new Ne;$.setRange(I.range);const L=P.isCompileTimeValue();const q=R.isCompileTimeValue();if(L&&q){return $.setBoolean(v===(P.asCompileTimeValue()===R.asCompileTimeValue())).setSideEffects(P.couldHaveSideEffects()||R.couldHaveSideEffects())}if(P.isArray()&&R.isArray()){return $.setBoolean(!v).setSideEffects(P.couldHaveSideEffects()||R.couldHaveSideEffects())}if(P.isTemplateString()&&R.isTemplateString()){return handleTemplateStringCompare(P,R,$,v)}const K=P.isPrimitiveType();const ae=R.isPrimitiveType();if(K===false&&(L||ae===true)||ae===false&&(q||K===true)||isAlwaysDifferent(P.asBool(),R.asBool())||isAlwaysDifferent(P.asNullish(),R.asNullish())){return $.setBoolean(!v).setSideEffects(P.couldHaveSideEffects()||R.couldHaveSideEffects())}};const handleAbstractEqualityComparison=v=>{const P=this.evaluateExpression(I.left);const R=this.evaluateExpression(I.right);const $=new Ne;$.setRange(I.range);const L=P.isCompileTimeValue();const q=R.isCompileTimeValue();if(L&&q){return $.setBoolean(v===(P.asCompileTimeValue()==R.asCompileTimeValue())).setSideEffects(P.couldHaveSideEffects()||R.couldHaveSideEffects())}if(P.isArray()&&R.isArray()){return $.setBoolean(!v).setSideEffects(P.couldHaveSideEffects()||R.couldHaveSideEffects())}if(P.isTemplateString()&&R.isTemplateString()){return handleTemplateStringCompare(P,R,$,v)}};if(I.operator==="+"){const v=this.evaluateExpression(I.left);const P=this.evaluateExpression(I.right);const R=new Ne;if(v.isString()){if(P.isString()){R.setString(v.string+P.string)}else if(P.isNumber()){R.setString(v.string+P.number)}else if(P.isWrapped()&&P.prefix&&P.prefix.isString()){R.setWrapped((new Ne).setString(v.string+P.prefix.string).setRange(joinRanges(v.range,P.prefix.range)),P.postfix,P.wrappedInnerExpressions)}else if(P.isWrapped()){R.setWrapped(v,P.postfix,P.wrappedInnerExpressions)}else{R.setWrapped(v,null,[P])}}else if(v.isNumber()){if(P.isString()){R.setString(v.number+P.string)}else if(P.isNumber()){R.setNumber(v.number+P.number)}else{return}}else if(v.isBigInt()){if(P.isBigInt()){R.setBigInt(v.bigint+P.bigint)}}else if(v.isWrapped()){if(v.postfix&&v.postfix.isString()&&P.isString()){R.setWrapped(v.prefix,(new Ne).setString(v.postfix.string+P.string).setRange(joinRanges(v.postfix.range,P.range)),v.wrappedInnerExpressions)}else if(v.postfix&&v.postfix.isString()&&P.isNumber()){R.setWrapped(v.prefix,(new Ne).setString(v.postfix.string+P.number).setRange(joinRanges(v.postfix.range,P.range)),v.wrappedInnerExpressions)}else if(P.isString()){R.setWrapped(v.prefix,P,v.wrappedInnerExpressions)}else if(P.isNumber()){R.setWrapped(v.prefix,(new Ne).setString(String(P.number)).setRange(P.range),v.wrappedInnerExpressions)}else if(P.isWrapped()){R.setWrapped(v.prefix,P.postfix,v.wrappedInnerExpressions&&P.wrappedInnerExpressions&&v.wrappedInnerExpressions.concat(v.postfix?[v.postfix]:[]).concat(P.prefix?[P.prefix]:[]).concat(P.wrappedInnerExpressions))}else{R.setWrapped(v.prefix,null,v.wrappedInnerExpressions&&v.wrappedInnerExpressions.concat(v.postfix?[v.postfix,P]:[P]))}}else if(P.isString()){R.setWrapped(null,P,[v])}else if(P.isWrapped()){R.setWrapped(null,P.postfix,P.wrappedInnerExpressions&&(P.prefix?[v,P.prefix]:[v]).concat(P.wrappedInnerExpressions))}else{return}if(v.couldHaveSideEffects()||P.couldHaveSideEffects())R.setSideEffects();R.setRange(I.range);return R}else if(I.operator==="-"){return handleConstOperation(((v,I)=>v-I))}else if(I.operator==="*"){return handleConstOperation(((v,I)=>v*I))}else if(I.operator==="/"){return handleConstOperation(((v,I)=>v/I))}else if(I.operator==="**"){return handleConstOperation(((v,I)=>v**I))}else if(I.operator==="==="){return handleStrictEqualityComparison(true)}else if(I.operator==="=="){return handleAbstractEqualityComparison(true)}else if(I.operator==="!=="){return handleStrictEqualityComparison(false)}else if(I.operator==="!="){return handleAbstractEqualityComparison(false)}else if(I.operator==="&"){return handleConstOperation(((v,I)=>v&I))}else if(I.operator==="|"){return handleConstOperation(((v,I)=>v|I))}else if(I.operator==="^"){return handleConstOperation(((v,I)=>v^I))}else if(I.operator===">>>"){return handleConstOperation(((v,I)=>v>>>I))}else if(I.operator===">>"){return handleConstOperation(((v,I)=>v>>I))}else if(I.operator==="<<"){return handleConstOperation(((v,I)=>v<<I))}else if(I.operator==="<"){return handleConstOperation(((v,I)=>v<I))}else if(I.operator===">"){return handleConstOperation(((v,I)=>v>I))}else if(I.operator==="<="){return handleConstOperation(((v,I)=>v<=I))}else if(I.operator===">="){return handleConstOperation(((v,I)=>v>=I))}}));this.hooks.evaluate.for("UnaryExpression").tap("JavascriptParser",(v=>{const I=v;const handleConstOperation=v=>{const P=this.evaluateExpression(I.argument);if(!P.isCompileTimeValue())return;const R=v(P.asCompileTimeValue());return valueAsExpression(R,I,P.couldHaveSideEffects())};if(I.operator==="typeof"){switch(I.argument.type){case"Identifier":{const v=this.callHooksForName(this.hooks.evaluateTypeof,I.argument.name,I);if(v!==undefined)return v;break}case"MetaProperty":{const v=this.callHooksForName(this.hooks.evaluateTypeof,getRootName(I.argument),I);if(v!==undefined)return v;break}case"MemberExpression":{const v=this.callHooksForExpression(this.hooks.evaluateTypeof,I.argument,I);if(v!==undefined)return v;break}case"ChainExpression":{const v=this.callHooksForExpression(this.hooks.evaluateTypeof,I.argument.expression,I);if(v!==undefined)return v;break}case"FunctionExpression":{return(new Ne).setString("function").setRange(I.range)}}const v=this.evaluateExpression(I.argument);if(v.isUnknown())return;if(v.isString()){return(new Ne).setString("string").setRange(I.range)}if(v.isWrapped()){return(new Ne).setString("string").setSideEffects().setRange(I.range)}if(v.isUndefined()){return(new Ne).setString("undefined").setRange(I.range)}if(v.isNumber()){return(new Ne).setString("number").setRange(I.range)}if(v.isBigInt()){return(new Ne).setString("bigint").setRange(I.range)}if(v.isBoolean()){return(new Ne).setString("boolean").setRange(I.range)}if(v.isConstArray()||v.isRegExp()||v.isNull()){return(new Ne).setString("object").setRange(I.range)}if(v.isArray()){return(new Ne).setString("object").setSideEffects(v.couldHaveSideEffects()).setRange(I.range)}}else if(I.operator==="!"){const v=this.evaluateExpression(I.argument);const P=v.asBool();if(typeof P!=="boolean")return;return(new Ne).setBoolean(!P).setSideEffects(v.couldHaveSideEffects()).setRange(I.range)}else if(I.operator==="~"){return handleConstOperation((v=>~v))}else if(I.operator==="+"){return handleConstOperation((v=>+v))}else if(I.operator==="-"){return handleConstOperation((v=>-v))}}));this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser",(v=>(new Ne).setString("undefined").setRange(v.range)));this.hooks.evaluate.for("Identifier").tap("JavascriptParser",(v=>{if(v.name==="undefined"){return(new Ne).setUndefined().setRange(v.range)}}));const tapEvaluateWithVariableInfo=(v,I)=>{let P;let R;this.hooks.evaluate.for(v).tap("JavascriptParser",(v=>{const $=v;const L=I($);if(L!==undefined){return this.callHooksForInfoWithFallback(this.hooks.evaluateIdentifier,L.name,(v=>{P=$;R=L}),(v=>{const I=this.hooks.evaluateDefinedIdentifier.get(v);if(I!==undefined){return I.call($)}}),$)}}));this.hooks.evaluate.for(v).tap({name:"JavascriptParser",stage:100},(v=>{const $=v;const L=P===$?R:I($);if(L!==undefined){return(new Ne).setIdentifier(L.name,L.rootInfo,L.getMembers,L.getMembersOptionals,L.getMemberRanges).setRange($.range)}}));this.hooks.finish.tap("JavascriptParser",(()=>{P=R=undefined}))};tapEvaluateWithVariableInfo("Identifier",(v=>{const I=this.getVariableInfo(v.name);if(typeof I==="string"||I instanceof VariableInfo&&typeof I.freeName==="string"){return{name:I,rootInfo:I,getMembers:()=>[],getMembersOptionals:()=>[],getMemberRanges:()=>[]}}}));tapEvaluateWithVariableInfo("ThisExpression",(v=>{const I=this.getVariableInfo("this");if(typeof I==="string"||I instanceof VariableInfo&&typeof I.freeName==="string"){return{name:I,rootInfo:I,getMembers:()=>[],getMembersOptionals:()=>[],getMemberRanges:()=>[]}}}));this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser",(v=>{const I=v;return this.callHooksForName(this.hooks.evaluateIdentifier,getRootName(I),I)}));tapEvaluateWithVariableInfo("MemberExpression",(v=>this.getMemberExpressionInfo(v,Je)));this.hooks.evaluate.for("CallExpression").tap("JavascriptParser",(v=>{const I=v;if(I.callee.type==="MemberExpression"&&I.callee.property.type===(I.callee.computed?"Literal":"Identifier")){const v=this.evaluateExpression(I.callee.object);const P=I.callee.property.type==="Literal"?`${I.callee.property.value}`:I.callee.property.name;const R=this.hooks.evaluateCallExpressionMember.get(P);if(R!==undefined){return R.call(I,v)}}else if(I.callee.type==="Identifier"){return this.callHooksForName(this.hooks.evaluateCallExpression,I.callee.name,I)}}));this.hooks.evaluateCallExpressionMember.for("indexOf").tap("JavascriptParser",((v,I)=>{if(!I.isString())return;if(v.arguments.length===0)return;const[P,R]=v.arguments;if(P.type==="SpreadElement")return;const $=this.evaluateExpression(P);if(!$.isString())return;const L=$.string;let q;if(R){if(R.type==="SpreadElement")return;const v=this.evaluateExpression(R);if(!v.isNumber())return;q=I.string.indexOf(L,v.number)}else{q=I.string.indexOf(L)}return(new Ne).setNumber(q).setSideEffects(I.couldHaveSideEffects()).setRange(v.range)}));this.hooks.evaluateCallExpressionMember.for("replace").tap("JavascriptParser",((v,I)=>{if(!I.isString())return;if(v.arguments.length!==2)return;if(v.arguments[0].type==="SpreadElement")return;if(v.arguments[1].type==="SpreadElement")return;const P=this.evaluateExpression(v.arguments[0]);const R=this.evaluateExpression(v.arguments[1]);if(!P.isString()&&!P.isRegExp())return;const $=P.regExp||P.string;if(!R.isString())return;const L=R.string;return(new Ne).setString(I.string.replace($,L)).setSideEffects(I.couldHaveSideEffects()).setRange(v.range)}));for(const v of["substr","substring","slice"]){this.hooks.evaluateCallExpressionMember.for(v).tap("JavascriptParser",((I,P)=>{if(!P.isString())return;let R;let $;const L=P.string;switch(I.arguments.length){case 1:if(I.arguments[0].type==="SpreadElement")return;R=this.evaluateExpression(I.arguments[0]);if(!R.isNumber())return;$=L[v](R.number);break;case 2:{if(I.arguments[0].type==="SpreadElement")return;if(I.arguments[1].type==="SpreadElement")return;R=this.evaluateExpression(I.arguments[0]);const P=this.evaluateExpression(I.arguments[1]);if(!R.isNumber())return;if(!P.isNumber())return;$=L[v](R.number,P.number);break}default:return}return(new Ne).setString($).setSideEffects(P.couldHaveSideEffects()).setRange(I.range)}))}const getSimplifiedTemplateResult=(v,I)=>{const P=[];const R=[];for(let $=0;$<I.quasis.length;$++){const L=I.quasis[$];const q=L.value[v];if($>0){const v=R[R.length-1];const P=this.evaluateExpression(I.expressions[$-1]);const K=P.asString();if(typeof K==="string"&&!P.couldHaveSideEffects()){v.setString(v.string+K+q);v.setRange([v.range[0],L.range[1]]);v.setExpression(undefined);continue}R.push(P)}const K=(new Ne).setString(q).setRange(L.range).setExpression(L);P.push(K);R.push(K)}return{quasis:P,parts:R}};this.hooks.evaluate.for("TemplateLiteral").tap("JavascriptParser",(v=>{const I=v;const{quasis:P,parts:R}=getSimplifiedTemplateResult("cooked",I);if(R.length===1){return R[0].setRange(I.range)}return(new Ne).setTemplateString(P,R,"cooked").setRange(I.range)}));this.hooks.evaluate.for("TaggedTemplateExpression").tap("JavascriptParser",(v=>{const I=v;const P=this.evaluateExpression(I.tag);if(P.isIdentifier()&&P.identifier==="String.raw"){const{quasis:v,parts:P}=getSimplifiedTemplateResult("raw",I.quasi);return(new Ne).setTemplateString(v,P,"raw").setRange(I.range)}}));this.hooks.evaluateCallExpressionMember.for("concat").tap("JavascriptParser",((v,I)=>{if(!I.isString()&&!I.isWrapped())return;let P=null;let R=false;const $=[];for(let I=v.arguments.length-1;I>=0;I--){const L=v.arguments[I];if(L.type==="SpreadElement")return;const q=this.evaluateExpression(L);if(R||!q.isString()&&!q.isNumber()){R=true;$.push(q);continue}const K=q.isString()?q.string:String(q.number);const ae=K+(P?P.string:"");const ge=[q.range[0],(P||q).range[1]];P=(new Ne).setString(ae).setSideEffects(P&&P.couldHaveSideEffects()||q.couldHaveSideEffects()).setRange(ge)}if(R){const R=I.isString()?I:I.prefix;const L=I.isWrapped()&&I.wrappedInnerExpressions?I.wrappedInnerExpressions.concat($.reverse()):$.reverse();return(new Ne).setWrapped(R,P,L).setRange(v.range)}else if(I.isWrapped()){const R=P||I.postfix;const L=I.wrappedInnerExpressions?I.wrappedInnerExpressions.concat($.reverse()):$.reverse();return(new Ne).setWrapped(I.prefix,R,L).setRange(v.range)}const L=I.string+(P?P.string:"");return(new Ne).setString(L).setSideEffects(P&&P.couldHaveSideEffects()||I.couldHaveSideEffects()).setRange(v.range)}));this.hooks.evaluateCallExpressionMember.for("split").tap("JavascriptParser",((v,I)=>{if(!I.isString())return;if(v.arguments.length!==1)return;if(v.arguments[0].type==="SpreadElement")return;let P;const R=this.evaluateExpression(v.arguments[0]);if(R.isString()){P=I.string.split(R.string)}else if(R.isRegExp()){P=I.string.split(R.regExp)}else{return}return(new Ne).setArray(P).setSideEffects(I.couldHaveSideEffects()).setRange(v.range)}));this.hooks.evaluate.for("ConditionalExpression").tap("JavascriptParser",(v=>{const I=v;const P=this.evaluateExpression(I.test);const R=P.asBool();let $;if(R===undefined){const v=this.evaluateExpression(I.consequent);const P=this.evaluateExpression(I.alternate);$=new Ne;if(v.isConditional()){$.setOptions(v.options)}else{$.setOptions([v])}if(P.isConditional()){$.addOptions(P.options)}else{$.addOptions([P])}}else{$=this.evaluateExpression(R?I.consequent:I.alternate);if(P.couldHaveSideEffects())$.setSideEffects()}$.setRange(I.range);return $}));this.hooks.evaluate.for("ArrayExpression").tap("JavascriptParser",(v=>{const I=v;const P=I.elements.map((v=>v!==null&&v.type!=="SpreadElement"&&this.evaluateExpression(v)));if(!P.every(Boolean))return;return(new Ne).setItems(P).setRange(I.range)}));this.hooks.evaluate.for("ChainExpression").tap("JavascriptParser",(v=>{const I=v;const P=[];let R=I.expression;while(R.type==="MemberExpression"||R.type==="CallExpression"){if(R.type==="MemberExpression"){if(R.optional){P.push(R.object)}R=R.object}else{if(R.optional){P.push(R.callee)}R=R.callee}}while(P.length>0){const I=P.pop();const R=this.evaluateExpression(I);if(R.asNullish()){return R.setRange(v.range)}}return this.evaluateExpression(I.expression)}))}destructuringAssignmentPropertiesFor(v){if(!this.destructuringAssignmentProperties)return;return this.destructuringAssignmentProperties.get(v)}getRenameIdentifier(v){const I=this.evaluateExpression(v);if(I.isIdentifier()){return I.identifier}}walkClass(v){if(v.superClass&&!this.hooks.classExtendsExpression.call(v.superClass,v)){this.walkExpression(v.superClass)}if(v.body&&v.body.type==="ClassBody"){const I=[];if(v.id){I.push(v.id)}this.inClassScope(true,I,(()=>{for(const I of v.body.body){if(!this.hooks.classBodyElement.call(I,v)){if(I.computed&&I.key){this.walkExpression(I.key)}if(I.value){if(!this.hooks.classBodyValue.call(I.value,I,v)){const v=this.scope.topLevelScope;this.scope.topLevelScope=false;this.walkExpression(I.value);this.scope.topLevelScope=v}}else if(I.type==="StaticBlock"){const v=this.scope.topLevelScope;this.scope.topLevelScope=false;this.walkBlockStatement(I);this.scope.topLevelScope=v}}}}))}}preWalkStatements(v){for(let I=0,P=v.length;I<P;I++){const P=v[I];this.preWalkStatement(P)}}blockPreWalkStatements(v){for(let I=0,P=v.length;I<P;I++){const P=v[I];this.blockPreWalkStatement(P)}}walkStatements(v){for(let I=0,P=v.length;I<P;I++){const P=v[I];this.walkStatement(P)}}preWalkStatement(v){this.statementPath.push(v);if(this.hooks.preStatement.call(v)){this.prevStatement=this.statementPath.pop();return}switch(v.type){case"BlockStatement":this.preWalkBlockStatement(v);break;case"DoWhileStatement":this.preWalkDoWhileStatement(v);break;case"ForInStatement":this.preWalkForInStatement(v);break;case"ForOfStatement":this.preWalkForOfStatement(v);break;case"ForStatement":this.preWalkForStatement(v);break;case"FunctionDeclaration":this.preWalkFunctionDeclaration(v);break;case"IfStatement":this.preWalkIfStatement(v);break;case"LabeledStatement":this.preWalkLabeledStatement(v);break;case"SwitchStatement":this.preWalkSwitchStatement(v);break;case"TryStatement":this.preWalkTryStatement(v);break;case"VariableDeclaration":this.preWalkVariableDeclaration(v);break;case"WhileStatement":this.preWalkWhileStatement(v);break;case"WithStatement":this.preWalkWithStatement(v);break}this.prevStatement=this.statementPath.pop()}blockPreWalkStatement(v){this.statementPath.push(v);if(this.hooks.blockPreStatement.call(v)){this.prevStatement=this.statementPath.pop();return}switch(v.type){case"ImportDeclaration":this.blockPreWalkImportDeclaration(v);break;case"ExportAllDeclaration":this.blockPreWalkExportAllDeclaration(v);break;case"ExportDefaultDeclaration":this.blockPreWalkExportDefaultDeclaration(v);break;case"ExportNamedDeclaration":this.blockPreWalkExportNamedDeclaration(v);break;case"VariableDeclaration":this.blockPreWalkVariableDeclaration(v);break;case"ClassDeclaration":this.blockPreWalkClassDeclaration(v);break;case"ExpressionStatement":this.blockPreWalkExpressionStatement(v)}this.prevStatement=this.statementPath.pop()}walkStatement(v){this.statementPath.push(v);if(this.hooks.statement.call(v)!==undefined){this.prevStatement=this.statementPath.pop();return}switch(v.type){case"BlockStatement":this.walkBlockStatement(v);break;case"ClassDeclaration":this.walkClassDeclaration(v);break;case"DoWhileStatement":this.walkDoWhileStatement(v);break;case"ExportDefaultDeclaration":this.walkExportDefaultDeclaration(v);break;case"ExportNamedDeclaration":this.walkExportNamedDeclaration(v);break;case"ExpressionStatement":this.walkExpressionStatement(v);break;case"ForInStatement":this.walkForInStatement(v);break;case"ForOfStatement":this.walkForOfStatement(v);break;case"ForStatement":this.walkForStatement(v);break;case"FunctionDeclaration":this.walkFunctionDeclaration(v);break;case"IfStatement":this.walkIfStatement(v);break;case"LabeledStatement":this.walkLabeledStatement(v);break;case"ReturnStatement":this.walkReturnStatement(v);break;case"SwitchStatement":this.walkSwitchStatement(v);break;case"ThrowStatement":this.walkThrowStatement(v);break;case"TryStatement":this.walkTryStatement(v);break;case"VariableDeclaration":this.walkVariableDeclaration(v);break;case"WhileStatement":this.walkWhileStatement(v);break;case"WithStatement":this.walkWithStatement(v);break}this.prevStatement=this.statementPath.pop()}walkNestedStatement(v){this.prevStatement=undefined;this.walkStatement(v)}preWalkBlockStatement(v){this.preWalkStatements(v.body)}walkBlockStatement(v){this.inBlockScope((()=>{const I=v.body;const P=this.prevStatement;this.blockPreWalkStatements(I);this.prevStatement=P;this.walkStatements(I)}))}walkExpressionStatement(v){this.walkExpression(v.expression)}preWalkIfStatement(v){this.preWalkStatement(v.consequent);if(v.alternate){this.preWalkStatement(v.alternate)}}walkIfStatement(v){const I=this.hooks.statementIf.call(v);if(I===undefined){this.walkExpression(v.test);this.walkNestedStatement(v.consequent);if(v.alternate){this.walkNestedStatement(v.alternate)}}else if(I){this.walkNestedStatement(v.consequent)}else if(v.alternate){this.walkNestedStatement(v.alternate)}}preWalkLabeledStatement(v){this.preWalkStatement(v.body)}walkLabeledStatement(v){const I=this.hooks.label.get(v.label.name);if(I!==undefined){const P=I.call(v);if(P===true)return}this.walkNestedStatement(v.body)}preWalkWithStatement(v){this.preWalkStatement(v.body)}walkWithStatement(v){this.walkExpression(v.object);this.walkNestedStatement(v.body)}preWalkSwitchStatement(v){this.preWalkSwitchCases(v.cases)}walkSwitchStatement(v){this.walkExpression(v.discriminant);this.walkSwitchCases(v.cases)}walkTerminatingStatement(v){if(v.argument)this.walkExpression(v.argument)}walkReturnStatement(v){this.walkTerminatingStatement(v)}walkThrowStatement(v){this.walkTerminatingStatement(v)}preWalkTryStatement(v){this.preWalkStatement(v.block);if(v.handler)this.preWalkCatchClause(v.handler);if(v.finalizer)this.preWalkStatement(v.finalizer)}walkTryStatement(v){if(this.scope.inTry){this.walkStatement(v.block)}else{this.scope.inTry=true;this.walkStatement(v.block);this.scope.inTry=false}if(v.handler)this.walkCatchClause(v.handler);if(v.finalizer)this.walkStatement(v.finalizer)}preWalkWhileStatement(v){this.preWalkStatement(v.body)}walkWhileStatement(v){this.walkExpression(v.test);this.walkNestedStatement(v.body)}preWalkDoWhileStatement(v){this.preWalkStatement(v.body)}walkDoWhileStatement(v){this.walkNestedStatement(v.body);this.walkExpression(v.test)}preWalkForStatement(v){if(v.init&&v.init.type==="VariableDeclaration"){this.preWalkStatement(v.init)}this.preWalkStatement(v.body)}walkForStatement(v){this.inBlockScope((()=>{if(v.init){if(v.init.type==="VariableDeclaration"){this.blockPreWalkVariableDeclaration(v.init);this.prevStatement=undefined;this.walkStatement(v.init)}else{this.walkExpression(v.init)}}if(v.test){this.walkExpression(v.test)}if(v.update){this.walkExpression(v.update)}const I=v.body;if(I.type==="BlockStatement"){const v=this.prevStatement;this.blockPreWalkStatements(I.body);this.prevStatement=v;this.walkStatements(I.body)}else{this.walkNestedStatement(I)}}))}preWalkForInStatement(v){if(v.left.type==="VariableDeclaration"){this.preWalkVariableDeclaration(v.left)}this.preWalkStatement(v.body)}walkForInStatement(v){this.inBlockScope((()=>{if(v.left.type==="VariableDeclaration"){this.blockPreWalkVariableDeclaration(v.left);this.walkVariableDeclaration(v.left)}else{this.walkPattern(v.left)}this.walkExpression(v.right);const I=v.body;if(I.type==="BlockStatement"){const v=this.prevStatement;this.blockPreWalkStatements(I.body);this.prevStatement=v;this.walkStatements(I.body)}else{this.walkNestedStatement(I)}}))}preWalkForOfStatement(v){if(v.await&&this.scope.topLevelScope===true){this.hooks.topLevelAwait.call(v)}if(v.left.type==="VariableDeclaration"){this.preWalkVariableDeclaration(v.left)}this.preWalkStatement(v.body)}walkForOfStatement(v){this.inBlockScope((()=>{if(v.left.type==="VariableDeclaration"){this.blockPreWalkVariableDeclaration(v.left);this.walkVariableDeclaration(v.left)}else{this.walkPattern(v.left)}this.walkExpression(v.right);const I=v.body;if(I.type==="BlockStatement"){const v=this.prevStatement;this.blockPreWalkStatements(I.body);this.prevStatement=v;this.walkStatements(I.body)}else{this.walkNestedStatement(I)}}))}preWalkFunctionDeclaration(v){if(v.id){this.defineVariable(v.id.name)}}walkFunctionDeclaration(v){const I=this.scope.topLevelScope;this.scope.topLevelScope=false;this.inFunctionScope(true,v.params,(()=>{for(const I of v.params){this.walkPattern(I)}if(v.body.type==="BlockStatement"){this.detectMode(v.body.body);const I=this.prevStatement;this.preWalkStatement(v.body);this.prevStatement=I;this.walkStatement(v.body)}else{this.walkExpression(v.body)}}));this.scope.topLevelScope=I}blockPreWalkExpressionStatement(v){const I=v.expression;switch(I.type){case"AssignmentExpression":this.preWalkAssignmentExpression(I)}}preWalkAssignmentExpression(v){if(v.left.type!=="ObjectPattern"||!this.destructuringAssignmentProperties)return;const I=this._preWalkObjectPattern(v.left);if(!I)return;if(this.destructuringAssignmentProperties.has(v)){const P=this.destructuringAssignmentProperties.get(v);this.destructuringAssignmentProperties.delete(v);for(const v of P)I.add(v)}this.destructuringAssignmentProperties.set(v.right.type==="AwaitExpression"?v.right.argument:v.right,I);if(v.right.type==="AssignmentExpression"){this.preWalkAssignmentExpression(v.right)}}blockPreWalkImportDeclaration(v){const I=v.source.value;this.hooks.import.call(v,I);for(const P of v.specifiers){const R=P.local.name;switch(P.type){case"ImportDefaultSpecifier":if(!this.hooks.importSpecifier.call(v,I,"default",R)){this.defineVariable(R)}break;case"ImportSpecifier":if(!this.hooks.importSpecifier.call(v,I,P.imported.name||P.imported.value,R)){this.defineVariable(R)}break;case"ImportNamespaceSpecifier":if(!this.hooks.importSpecifier.call(v,I,null,R)){this.defineVariable(R)}break;default:this.defineVariable(R)}}}enterDeclaration(v,I){switch(v.type){case"VariableDeclaration":for(const P of v.declarations){switch(P.type){case"VariableDeclarator":{this.enterPattern(P.id,I);break}}}break;case"FunctionDeclaration":this.enterPattern(v.id,I);break;case"ClassDeclaration":this.enterPattern(v.id,I);break}}blockPreWalkExportNamedDeclaration(v){let I;if(v.source){I=v.source.value;this.hooks.exportImport.call(v,I)}else{this.hooks.export.call(v)}if(v.declaration&&!this.hooks.exportDeclaration.call(v,v.declaration)){const I=this.prevStatement;this.preWalkStatement(v.declaration);this.prevStatement=I;this.blockPreWalkStatement(v.declaration);let P=0;this.enterDeclaration(v.declaration,(I=>{this.hooks.exportSpecifier.call(v,I,I,P++)}))}if(v.specifiers){for(let P=0;P<v.specifiers.length;P++){const R=v.specifiers[P];switch(R.type){case"ExportSpecifier":{const $=R.local.name||R.local.value;const L=R.exported.name||R.exported.value;if(I){this.hooks.exportImportSpecifier.call(v,I,$,L,P)}else{this.hooks.exportSpecifier.call(v,$,L,P)}break}}}}}walkExportNamedDeclaration(v){if(v.declaration){this.walkStatement(v.declaration)}}blockPreWalkExportDefaultDeclaration(v){const I=this.prevStatement;this.preWalkStatement(v.declaration);this.prevStatement=I;this.blockPreWalkStatement(v.declaration);if(v.declaration.id&&v.declaration.type!=="FunctionExpression"&&v.declaration.type!=="ClassExpression"){const I=v.declaration;this.hooks.exportSpecifier.call(v,I.id.name,"default",undefined)}}walkExportDefaultDeclaration(v){this.hooks.export.call(v);if(v.declaration.id&&v.declaration.type!=="FunctionExpression"&&v.declaration.type!=="ClassExpression"){const I=v.declaration;if(!this.hooks.exportDeclaration.call(v,I)){this.walkStatement(I)}}else{if(v.declaration.type==="FunctionDeclaration"||v.declaration.type==="ClassDeclaration"){this.walkStatement(v.declaration)}else{this.walkExpression(v.declaration)}if(!this.hooks.exportExpression.call(v,v.declaration)){this.hooks.exportSpecifier.call(v,v.declaration,"default",undefined)}}}blockPreWalkExportAllDeclaration(v){const I=v.source.value;const P=v.exported?v.exported.name||v.exported.value:null;this.hooks.exportImport.call(v,I);this.hooks.exportImportSpecifier.call(v,I,null,P,0)}preWalkVariableDeclaration(v){if(v.kind!=="var")return;this._preWalkVariableDeclaration(v,this.hooks.varDeclarationVar)}blockPreWalkVariableDeclaration(v){if(v.kind==="var")return;const I=v.kind==="const"?this.hooks.varDeclarationConst:this.hooks.varDeclarationLet;this._preWalkVariableDeclaration(v,I)}_preWalkVariableDeclaration(v,I){for(const P of v.declarations){switch(P.type){case"VariableDeclarator":{this.preWalkVariableDeclarator(P);if(!this.hooks.preDeclarator.call(P,v)){this.enterPattern(P.id,((v,P)=>{let R=I.get(v);if(R===undefined||!R.call(P)){R=this.hooks.varDeclaration.get(v);if(R===undefined||!R.call(P)){this.defineVariable(v)}}}))}break}}}}_preWalkObjectPattern(v){const I=new Set;const P=v.properties;for(let v=0;v<P.length;v++){const R=P[v];if(R.type!=="Property")return;if(R.shorthand&&R.value.type==="Identifier"){this.scope.inShorthand=R.value.name}const $=R.key;if($.type==="Identifier"){I.add({id:$.name,range:$.range,shorthand:this.scope.inShorthand})}else{const v=this.evaluateExpression($);const P=v.asString();if(P){I.add({id:P,range:$.range,shorthand:this.scope.inShorthand})}else{return}}this.scope.inShorthand=false}return I}preWalkVariableDeclarator(v){if(!v.init||v.id.type!=="ObjectPattern"||!this.destructuringAssignmentProperties)return;const I=this._preWalkObjectPattern(v.id);if(!I)return;this.destructuringAssignmentProperties.set(v.init.type==="AwaitExpression"?v.init.argument:v.init,I);if(v.init.type==="AssignmentExpression"){this.preWalkAssignmentExpression(v.init)}}walkVariableDeclaration(v){for(const I of v.declarations){switch(I.type){case"VariableDeclarator":{const P=I.init&&this.getRenameIdentifier(I.init);if(P&&I.id.type==="Identifier"){const v=this.hooks.canRename.get(P);if(v!==undefined&&v.call(I.init)){const v=this.hooks.rename.get(P);if(v===undefined||!v.call(I.init)){this.setVariable(I.id.name,P)}break}}if(!this.hooks.declarator.call(I,v)){this.walkPattern(I.id);if(I.init)this.walkExpression(I.init)}break}}}}blockPreWalkClassDeclaration(v){if(v.id){this.defineVariable(v.id.name)}}walkClassDeclaration(v){this.walkClass(v)}preWalkSwitchCases(v){for(let I=0,P=v.length;I<P;I++){const P=v[I];this.preWalkStatements(P.consequent)}}walkSwitchCases(v){this.inBlockScope((()=>{const I=v.length;for(let P=0;P<I;P++){const I=v[P];if(I.consequent.length>0){const v=this.prevStatement;this.blockPreWalkStatements(I.consequent);this.prevStatement=v}}for(let P=0;P<I;P++){const I=v[P];if(I.test){this.walkExpression(I.test)}if(I.consequent.length>0){this.walkStatements(I.consequent)}}}))}preWalkCatchClause(v){this.preWalkStatement(v.body)}walkCatchClause(v){this.inBlockScope((()=>{if(v.param!==null){this.enterPattern(v.param,(v=>{this.defineVariable(v)}));this.walkPattern(v.param)}const I=this.prevStatement;this.blockPreWalkStatement(v.body);this.prevStatement=I;this.walkStatement(v.body)}))}walkPattern(v){switch(v.type){case"ArrayPattern":this.walkArrayPattern(v);break;case"AssignmentPattern":this.walkAssignmentPattern(v);break;case"MemberExpression":this.walkMemberExpression(v);break;case"ObjectPattern":this.walkObjectPattern(v);break;case"RestElement":this.walkRestElement(v);break}}walkAssignmentPattern(v){this.walkExpression(v.right);this.walkPattern(v.left)}walkObjectPattern(v){for(let I=0,P=v.properties.length;I<P;I++){const P=v.properties[I];if(P){if(P.type==="RestElement"){continue}if(P.computed)this.walkExpression(P.key);if(P.value)this.walkPattern(P.value)}}}walkArrayPattern(v){for(let I=0,P=v.elements.length;I<P;I++){const P=v.elements[I];if(P)this.walkPattern(P)}}walkRestElement(v){this.walkPattern(v.argument)}walkExpressions(v){for(const I of v){if(I){this.walkExpression(I)}}}walkExpression(v){switch(v.type){case"ArrayExpression":this.walkArrayExpression(v);break;case"ArrowFunctionExpression":this.walkArrowFunctionExpression(v);break;case"AssignmentExpression":this.walkAssignmentExpression(v);break;case"AwaitExpression":this.walkAwaitExpression(v);break;case"BinaryExpression":this.walkBinaryExpression(v);break;case"CallExpression":this.walkCallExpression(v);break;case"ChainExpression":this.walkChainExpression(v);break;case"ClassExpression":this.walkClassExpression(v);break;case"ConditionalExpression":this.walkConditionalExpression(v);break;case"FunctionExpression":this.walkFunctionExpression(v);break;case"Identifier":this.walkIdentifier(v);break;case"ImportExpression":this.walkImportExpression(v);break;case"LogicalExpression":this.walkLogicalExpression(v);break;case"MetaProperty":this.walkMetaProperty(v);break;case"MemberExpression":this.walkMemberExpression(v);break;case"NewExpression":this.walkNewExpression(v);break;case"ObjectExpression":this.walkObjectExpression(v);break;case"SequenceExpression":this.walkSequenceExpression(v);break;case"SpreadElement":this.walkSpreadElement(v);break;case"TaggedTemplateExpression":this.walkTaggedTemplateExpression(v);break;case"TemplateLiteral":this.walkTemplateLiteral(v);break;case"ThisExpression":this.walkThisExpression(v);break;case"UnaryExpression":this.walkUnaryExpression(v);break;case"UpdateExpression":this.walkUpdateExpression(v);break;case"YieldExpression":this.walkYieldExpression(v);break}}walkAwaitExpression(v){if(this.scope.topLevelScope===true)this.hooks.topLevelAwait.call(v);this.walkExpression(v.argument)}walkArrayExpression(v){if(v.elements){this.walkExpressions(v.elements)}}walkSpreadElement(v){if(v.argument){this.walkExpression(v.argument)}}walkObjectExpression(v){for(let I=0,P=v.properties.length;I<P;I++){const P=v.properties[I];this.walkProperty(P)}}walkProperty(v){if(v.type==="SpreadElement"){this.walkExpression(v.argument);return}if(v.computed){this.walkExpression(v.key)}if(v.shorthand&&v.value&&v.value.type==="Identifier"){this.scope.inShorthand=v.value.name;this.walkIdentifier(v.value);this.scope.inShorthand=false}else{this.walkExpression(v.value)}}walkFunctionExpression(v){const I=this.scope.topLevelScope;this.scope.topLevelScope=false;const P=[...v.params];if(v.id){P.push(v.id)}this.inFunctionScope(true,P,(()=>{for(const I of v.params){this.walkPattern(I)}if(v.body.type==="BlockStatement"){this.detectMode(v.body.body);const I=this.prevStatement;this.preWalkStatement(v.body);this.prevStatement=I;this.walkStatement(v.body)}else{this.walkExpression(v.body)}}));this.scope.topLevelScope=I}walkArrowFunctionExpression(v){const I=this.scope.topLevelScope;this.scope.topLevelScope=I?"arrow":false;this.inFunctionScope(false,v.params,(()=>{for(const I of v.params){this.walkPattern(I)}if(v.body.type==="BlockStatement"){this.detectMode(v.body.body);const I=this.prevStatement;this.preWalkStatement(v.body);this.prevStatement=I;this.walkStatement(v.body)}else{this.walkExpression(v.body)}}));this.scope.topLevelScope=I}walkSequenceExpression(v){if(!v.expressions)return;const I=this.statementPath[this.statementPath.length-1];if(I===v||I.type==="ExpressionStatement"&&I.expression===v){const I=this.statementPath.pop();const P=this.prevStatement;for(const I of v.expressions){this.statementPath.push(I);this.walkExpression(I);this.prevStatement=this.statementPath.pop()}this.prevStatement=P;this.statementPath.push(I)}else{this.walkExpressions(v.expressions)}}walkUpdateExpression(v){this.walkExpression(v.argument)}walkUnaryExpression(v){if(v.operator==="typeof"){const I=this.callHooksForExpression(this.hooks.typeof,v.argument,v);if(I===true)return;if(v.argument.type==="ChainExpression"){const I=this.callHooksForExpression(this.hooks.typeof,v.argument.expression,v);if(I===true)return}}this.walkExpression(v.argument)}walkLeftRightExpression(v){this.walkExpression(v.left);this.walkExpression(v.right)}walkBinaryExpression(v){if(this.hooks.binaryExpression.call(v)===undefined){this.walkLeftRightExpression(v)}}walkLogicalExpression(v){const I=this.hooks.expressionLogicalOperator.call(v);if(I===undefined){this.walkLeftRightExpression(v)}else if(I){this.walkExpression(v.right)}}walkAssignmentExpression(v){if(v.left.type==="Identifier"){const I=this.getRenameIdentifier(v.right);if(I&&this.callHooksForInfo(this.hooks.canRename,I,v.right)){if(!this.callHooksForInfo(this.hooks.rename,I,v.right)){this.setVariable(v.left.name,typeof I==="string"?this.getVariableInfo(I):I)}return}this.walkExpression(v.right);this.enterPattern(v.left,((I,P)=>{if(!this.callHooksForName(this.hooks.assign,I,v)){this.walkExpression(v.left)}}));return}if(v.left.type.endsWith("Pattern")){this.walkExpression(v.right);this.enterPattern(v.left,((I,P)=>{if(!this.callHooksForName(this.hooks.assign,I,v)){this.defineVariable(I)}}));this.walkPattern(v.left)}else if(v.left.type==="MemberExpression"){const I=this.getMemberExpressionInfo(v.left,Je);if(I&&this.callHooksForInfo(this.hooks.assignMemberChain,I.rootInfo,v,I.getMembers())){return}this.walkExpression(v.right);this.walkExpression(v.left)}else{this.walkExpression(v.right);this.walkExpression(v.left)}}walkConditionalExpression(v){const I=this.hooks.expressionConditionalOperator.call(v);if(I===undefined){this.walkExpression(v.test);this.walkExpression(v.consequent);if(v.alternate){this.walkExpression(v.alternate)}}else if(I){this.walkExpression(v.consequent)}else if(v.alternate){this.walkExpression(v.alternate)}}walkNewExpression(v){const I=this.callHooksForExpression(this.hooks.new,v.callee,v);if(I===true)return;this.walkExpression(v.callee);if(v.arguments){this.walkExpressions(v.arguments)}}walkYieldExpression(v){if(v.argument){this.walkExpression(v.argument)}}walkTemplateLiteral(v){if(v.expressions){this.walkExpressions(v.expressions)}}walkTaggedTemplateExpression(v){if(v.tag){this.scope.inTaggedTemplateTag=true;this.walkExpression(v.tag);this.scope.inTaggedTemplateTag=false}if(v.quasi&&v.quasi.expressions){this.walkExpressions(v.quasi.expressions)}}walkClassExpression(v){this.walkClass(v)}walkChainExpression(v){const I=this.hooks.optionalChaining.call(v);if(I===undefined){if(v.expression.type==="CallExpression"){this.walkCallExpression(v.expression)}else{this.walkMemberExpression(v.expression)}}}_walkIIFE(v,I,P){const getVarInfo=v=>{const I=this.getRenameIdentifier(v);if(I&&this.callHooksForInfo(this.hooks.canRename,I,v)&&!this.callHooksForInfo(this.hooks.rename,I,v)){return typeof I==="string"?this.getVariableInfo(I):I}this.walkExpression(v)};const{params:R,type:$}=v;const L=$==="ArrowFunctionExpression";const q=P?getVarInfo(P):null;const K=I.map(getVarInfo);const ae=this.scope.topLevelScope;this.scope.topLevelScope=ae&&L?"arrow":false;const ge=R.filter(((v,I)=>!K[I]));if(v.type==="FunctionExpression"&&v.id){ge.push(v.id.name)}this.inFunctionScope(true,ge,(()=>{if(q&&!L){this.setVariable("this",q)}for(let v=0;v<K.length;v++){const I=K[v];if(!I)continue;if(!R[v]||R[v].type!=="Identifier")continue;this.setVariable(R[v].name,I)}if(v.body.type==="BlockStatement"){this.detectMode(v.body.body);const I=this.prevStatement;this.preWalkStatement(v.body);this.prevStatement=I;this.walkStatement(v.body)}else{this.walkExpression(v.body)}}));this.scope.topLevelScope=ae}walkImportExpression(v){const I=this.hooks.importCall.call(v);if(I===true)return;this.walkExpression(v.source)}walkCallExpression(v){const isSimpleFunction=v=>v.params.every((v=>v.type==="Identifier"));if(v.callee.type==="MemberExpression"&&v.callee.object.type.endsWith("FunctionExpression")&&!v.callee.computed&&(v.callee.property.name==="call"||v.callee.property.name==="bind")&&v.arguments.length>0&&isSimpleFunction(v.callee.object)){this._walkIIFE(v.callee.object,v.arguments.slice(1),v.arguments[0])}else if(v.callee.type.endsWith("FunctionExpression")&&isSimpleFunction(v.callee)){this._walkIIFE(v.callee,v.arguments,null)}else{if(v.callee.type==="MemberExpression"){const I=this.getMemberExpressionInfo(v.callee,Qe);if(I&&I.type==="call"){const P=this.callHooksForInfo(this.hooks.callMemberChainOfCallMemberChain,I.rootInfo,v,I.getCalleeMembers(),I.call,I.getMembers(),I.getMemberRanges());if(P===true)return}}const I=this.evaluateExpression(v.callee);if(I.isIdentifier()){const P=this.callHooksForInfo(this.hooks.callMemberChain,I.rootInfo,v,I.getMembers(),I.getMembersOptionals?I.getMembersOptionals():I.getMembers().map((()=>false)),I.getMemberRanges?I.getMemberRanges():[]);if(P===true)return;const R=this.callHooksForInfo(this.hooks.call,I.identifier,v);if(R===true)return}if(v.callee){if(v.callee.type==="MemberExpression"){this.walkExpression(v.callee.object);if(v.callee.computed===true)this.walkExpression(v.callee.property)}else{this.walkExpression(v.callee)}}if(v.arguments)this.walkExpressions(v.arguments)}}walkMemberExpression(v){const I=this.getMemberExpressionInfo(v,Ve);if(I){switch(I.type){case"expression":{const P=this.callHooksForInfo(this.hooks.expression,I.name,v);if(P===true)return;const R=I.getMembers();const $=I.getMembersOptionals();const L=I.getMemberRanges();const q=this.callHooksForInfo(this.hooks.expressionMemberChain,I.rootInfo,v,R,$,L);if(q===true)return;this.walkMemberExpressionWithExpressionName(v,I.name,I.rootInfo,R.slice(),(()=>this.callHooksForInfo(this.hooks.unhandledExpressionMemberChain,I.rootInfo,v,R)));return}case"call":{const P=this.callHooksForInfo(this.hooks.memberChainOfCallMemberChain,I.rootInfo,v,I.getCalleeMembers(),I.call,I.getMembers(),I.getMemberRanges());if(P===true)return;this.walkExpression(I.call);return}}}this.walkExpression(v.object);if(v.computed===true)this.walkExpression(v.property)}walkMemberExpressionWithExpressionName(v,I,P,R,$){if(v.object.type==="MemberExpression"){const L=v.property.name||`${v.property.value}`;I=I.slice(0,-L.length-1);R.pop();const q=this.callHooksForInfo(this.hooks.expression,I,v.object);if(q===true)return;this.walkMemberExpressionWithExpressionName(v.object,I,P,R,$)}else if(!$||!$()){this.walkExpression(v.object)}if(v.computed===true)this.walkExpression(v.property)}walkThisExpression(v){this.callHooksForName(this.hooks.expression,"this",v)}walkIdentifier(v){this.callHooksForName(this.hooks.expression,v.name,v)}walkMetaProperty(v){this.hooks.expression.for(getRootName(v)).call(v)}callHooksForExpression(v,I,...P){return this.callHooksForExpressionWithFallback(v,I,undefined,undefined,...P)}callHooksForExpressionWithFallback(v,I,P,R,...$){const L=this.getMemberExpressionInfo(I,Je);if(L!==undefined){const I=L.getMembers();return this.callHooksForInfoWithFallback(v,I.length===0?L.rootInfo:L.name,P&&(v=>P(v,L.rootInfo,L.getMembers)),R&&(()=>R(L.name)),...$)}}callHooksForName(v,I,...P){return this.callHooksForNameWithFallback(v,I,undefined,undefined,...P)}callHooksForInfo(v,I,...P){return this.callHooksForInfoWithFallback(v,I,undefined,undefined,...P)}callHooksForInfoWithFallback(v,I,P,R,...$){let L;if(typeof I==="string"){L=I}else{if(!(I instanceof VariableInfo)){if(R!==undefined){return R()}return}let P=I.tagInfo;while(P!==undefined){const I=v.get(P.tag);if(I!==undefined){this.currentTagData=P.data;const v=I.call(...$);this.currentTagData=undefined;if(v!==undefined)return v}P=P.next}if(I.freeName===true){if(R!==undefined){return R()}return}L=I.freeName}const q=v.get(L);if(q!==undefined){const v=q.call(...$);if(v!==undefined)return v}if(P!==undefined){return P(L)}}callHooksForNameWithFallback(v,I,P,R,...$){return this.callHooksForInfoWithFallback(v,this.getVariableInfo(I),P,R,...$)}inScope(v,I){const P=this.scope;this.scope={topLevelScope:P.topLevelScope,inTry:false,inShorthand:false,inTaggedTemplateTag:false,isStrict:P.isStrict,isAsmJs:P.isAsmJs,definitions:P.definitions.createChild()};this.undefineVariable("this");this.enterPatterns(v,(v=>{this.defineVariable(v)}));I();this.scope=P}inClassScope(v,I,P){const R=this.scope;this.scope={topLevelScope:R.topLevelScope,inTry:false,inShorthand:false,inTaggedTemplateTag:false,isStrict:R.isStrict,isAsmJs:R.isAsmJs,definitions:R.definitions.createChild()};if(v){this.undefineVariable("this")}this.enterPatterns(I,(v=>{this.defineVariable(v)}));P();this.scope=R}inFunctionScope(v,I,P){const R=this.scope;this.scope={topLevelScope:R.topLevelScope,inTry:false,inShorthand:false,inTaggedTemplateTag:false,isStrict:R.isStrict,isAsmJs:R.isAsmJs,definitions:R.definitions.createChild()};if(v){this.undefineVariable("this")}this.enterPatterns(I,(v=>{this.defineVariable(v)}));P();this.scope=R}inBlockScope(v){const I=this.scope;this.scope={topLevelScope:I.topLevelScope,inTry:I.inTry,inShorthand:false,inTaggedTemplateTag:false,isStrict:I.isStrict,isAsmJs:I.isAsmJs,definitions:I.definitions.createChild()};v();this.scope=I}detectMode(v){const I=v.length>=1&&v[0].type==="ExpressionStatement"&&v[0].expression.type==="Literal";if(I&&v[0].expression.value==="use strict"){this.scope.isStrict=true}if(I&&v[0].expression.value==="use asm"){this.scope.isAsmJs=true}}enterPatterns(v,I){for(const P of v){if(typeof P!=="string"){this.enterPattern(P,I)}else if(P){I(P)}}}enterPattern(v,I){if(!v)return;switch(v.type){case"ArrayPattern":this.enterArrayPattern(v,I);break;case"AssignmentPattern":this.enterAssignmentPattern(v,I);break;case"Identifier":this.enterIdentifier(v,I);break;case"ObjectPattern":this.enterObjectPattern(v,I);break;case"RestElement":this.enterRestElement(v,I);break;case"Property":if(v.shorthand&&v.value.type==="Identifier"){this.scope.inShorthand=v.value.name;this.enterIdentifier(v.value,I);this.scope.inShorthand=false}else{this.enterPattern(v.value,I)}break}}enterIdentifier(v,I){if(!this.callHooksForName(this.hooks.pattern,v.name,v)){I(v.name,v)}}enterObjectPattern(v,I){for(let P=0,R=v.properties.length;P<R;P++){const R=v.properties[P];this.enterPattern(R,I)}}enterArrayPattern(v,I){for(let P=0,R=v.elements.length;P<R;P++){const R=v.elements[P];if(R){this.enterPattern(R,I)}}}enterRestElement(v,I){this.enterPattern(v.argument,I)}enterAssignmentPattern(v,I){this.enterPattern(v.left,I)}evaluateExpression(v){try{const I=this.hooks.evaluate.get(v.type);if(I!==undefined){const P=I.call(v);if(P!==undefined&&P!==null){P.setExpression(v);return P}}}catch(v){console.warn(v)}return(new Ne).setRange(v.range).setExpression(v)}parseString(v){switch(v.type){case"BinaryExpression":if(v.operator==="+"){return this.parseString(v.left)+this.parseString(v.right)}break;case"Literal":return String(v.value)}throw new Error(`${v.type} is not supported as parameter for require`)}parseCalculatedString(v){switch(v.type){case"BinaryExpression":if(v.operator==="+"){const I=this.parseCalculatedString(v.left);const P=this.parseCalculatedString(v.right);if(I.code){return{range:I.range,value:I.value,code:true,conditional:false}}else if(P.code){return{range:[I.range[0],P.range?P.range[1]:I.range[1]],value:I.value+P.value,code:true,conditional:false}}return{range:[I.range[0],P.range[1]],value:I.value+P.value,code:false,conditional:false}}break;case"ConditionalExpression":{const I=this.parseCalculatedString(v.consequent);const P=this.parseCalculatedString(v.alternate);const R=[];if(I.conditional){R.push(...I.conditional)}else if(!I.code){R.push(I)}else{break}if(P.conditional){R.push(...P.conditional)}else if(!P.code){R.push(P)}else{break}return{range:undefined,value:"",code:true,conditional:R}}case"Literal":return{range:v.range,value:String(v.value),code:false,conditional:false}}return{range:undefined,value:"",code:true,conditional:false}}parse(v,I){let P;let R;const $=new Set;if(v===null){throw new Error("source must not be null")}if(Buffer.isBuffer(v)){v=v.toString("utf-8")}if(typeof v==="object"){P=v;R=v.comments}else{R=[];P=JavascriptParser._parse(v,{sourceType:this.sourceType,onComment:R,onInsertedSemicolon:v=>$.add(v)})}const L=this.scope;const q=this.state;const K=this.comments;const ae=this.semicolons;const be=this.statementPath;const xe=this.prevStatement;this.scope={topLevelScope:true,inTry:false,inShorthand:false,inTaggedTemplateTag:false,isStrict:false,isAsmJs:false,definitions:new ge};this.state=I;this.comments=R;this.semicolons=$;this.statementPath=[];this.prevStatement=undefined;if(this.hooks.program.call(P,R)===undefined){this.destructuringAssignmentProperties=new WeakMap;this.detectMode(P.body);this.preWalkStatements(P.body);this.prevStatement=undefined;this.blockPreWalkStatements(P.body);this.prevStatement=undefined;this.walkStatements(P.body);this.destructuringAssignmentProperties=undefined}this.hooks.finish.call(P,R);this.scope=L;this.state=q;this.comments=K;this.semicolons=ae;this.statementPath=be;this.prevStatement=xe;return I}evaluate(v){const I=JavascriptParser._parse(`(${v})`,{sourceType:this.sourceType,locations:false});if(I.body.length!==1||I.body[0].type!=="ExpressionStatement"){throw new Error("evaluate: Source is not a expression")}return this.evaluateExpression(I.body[0].expression)}isPure(v,I){if(!v)return true;const P=this.hooks.isPure.for(v.type).call(v,I);if(typeof P==="boolean")return P;switch(v.type){case"ClassDeclaration":case"ClassExpression":{if(v.body.type!=="ClassBody")return false;if(v.superClass&&!this.isPure(v.superClass,v.range[0])){return false}const I=v.body.body;return I.every((I=>{if(I.computed&&I.key&&!this.isPure(I.key,I.range[0])){return false}if(I.static&&I.value&&!this.isPure(I.value,I.key?I.key.range[1]:I.range[0])){return false}if(I.type==="StaticBlock"){return false}if(v.superClass&&I.type==="MethodDefinition"&&I.kind==="constructor"){return false}return true}))}case"FunctionDeclaration":case"FunctionExpression":case"ArrowFunctionExpression":case"ThisExpression":case"Literal":case"TemplateLiteral":case"Identifier":case"PrivateIdentifier":return true;case"VariableDeclaration":return v.declarations.every((v=>this.isPure(v.init,v.range[0])));case"ConditionalExpression":return this.isPure(v.test,I)&&this.isPure(v.consequent,v.test.range[1])&&this.isPure(v.alternate,v.consequent.range[1]);case"LogicalExpression":return this.isPure(v.left,I)&&this.isPure(v.right,v.left.range[1]);case"SequenceExpression":return v.expressions.every((v=>{const P=this.isPure(v,I);I=v.range[1];return P}));case"CallExpression":{const P=v.range[0]-I>12&&this.getComments([I,v.range[0]]).some((v=>v.type==="Block"&&/^\s*(#|@)__PURE__\s*$/.test(v.value)));if(!P)return false;I=v.callee.range[1];return v.arguments.every((v=>{if(v.type==="SpreadElement")return false;const P=this.isPure(v,I);I=v.range[1];return P}))}}const R=this.evaluateExpression(v);return!R.couldHaveSideEffects()}getComments(v){const[I,P]=v;const compare=(v,I)=>v.range[0]-I;const R=this.comments;let $=be.ge(R,I,compare);const L=[];while(R[$]&&R[$].range[1]<=P){L.push(R[$]);$++}return L}isAsiPosition(v){const I=this.statementPath[this.statementPath.length-1];if(I===undefined)throw new Error("Not in statement");const P=I.range;return P[1]===v&&this.semicolons.has(v)||P[0]===v&&this.prevStatement!==undefined&&this.semicolons.has(this.prevStatement.range[1])}setAsiPosition(v){this.semicolons.add(v)}unsetAsiPosition(v){this.semicolons.delete(v)}isStatementLevelExpression(v){const I=this.statementPath[this.statementPath.length-1];return v===I||I.type==="ExpressionStatement"&&I.expression===v}getTagData(v,I){const P=this.scope.definitions.get(v);if(P instanceof VariableInfo){let v=P.tagInfo;while(v!==undefined){if(v.tag===I)return v.data;v=v.next}}}tagVariable(v,I,P){const R=this.scope.definitions.get(v);let $;if(R===undefined){$=new VariableInfo(this.scope,v,{tag:I,data:P,next:undefined})}else if(R instanceof VariableInfo){$=new VariableInfo(R.declaredScope,R.freeName,{tag:I,data:P,next:R.tagInfo})}else{$=new VariableInfo(R,true,{tag:I,data:P,next:undefined})}this.scope.definitions.set(v,$)}defineVariable(v){const I=this.scope.definitions.get(v);if(I instanceof VariableInfo&&I.declaredScope===this.scope)return;this.scope.definitions.set(v,this.scope)}undefineVariable(v){this.scope.definitions.delete(v)}isVariableDefined(v){const I=this.scope.definitions.get(v);if(I===undefined)return false;if(I instanceof VariableInfo){return I.freeName===true}return true}getVariableInfo(v){const I=this.scope.definitions.get(v);if(I===undefined){return v}return I}setVariable(v,I){if(typeof I==="string"){if(I===v){this.scope.definitions.delete(v)}else{this.scope.definitions.set(v,new VariableInfo(this.scope,I,undefined))}}else{this.scope.definitions.set(v,I)}}evaluatedVariable(v){return new VariableInfo(this.scope,undefined,v)}parseCommentOptions(v){const I=this.getComments(v);if(I.length===0){return Ze}const P={};const R=[];for(const v of I){const{value:I}=v;if(I&&xe.test(I)){try{for(let[v,R]of Object.entries(K.runInContext(`(function(){return {${I}};})()`,this.magicCommentContext))){if(typeof R==="object"&&R!==null){R=R.constructor.name==="RegExp"?new RegExp(R):JSON.parse(JSON.stringify(R))}P[v]=R}}catch(I){const P=new Error(String(I.message));P.stack=String(I.stack);Object.assign(P,{comment:v});R.push(P)}}}return{options:P,errors:R}}extractMemberExpressionChain(v){let I=v;const P=[];const R=[];const $=[];while(I.type==="MemberExpression"){if(I.computed){if(I.property.type!=="Literal")break;P.push(`${I.property.value}`);$.push(I.object.range)}else{if(I.property.type!=="Identifier")break;P.push(I.property.name);$.push(I.object.range)}R.push(I.optional);I=I.object}return{members:P,membersOptionals:R,memberRanges:$,object:I}}getFreeInfoFromVariable(v){const I=this.getVariableInfo(v);let P;if(I instanceof VariableInfo){P=I.freeName;if(typeof P!=="string")return}else if(typeof I!=="string"){return}else{P=I}return{info:I,name:P}}getMemberExpressionInfo(v,I){const{object:P,members:R,membersOptionals:$,memberRanges:L}=this.extractMemberExpressionChain(v);switch(P.type){case"CallExpression":{if((I&Qe)===0)return;let v=P.callee;let q=He;if(v.type==="MemberExpression"){({object:v,members:q}=this.extractMemberExpressionChain(v))}const K=getRootName(v);if(!K)return;const ae=this.getFreeInfoFromVariable(K);if(!ae)return;const{info:ge,name:be}=ae;const xe=objectAndMembersToName(be,q);return{type:"call",call:P,calleeName:xe,rootInfo:ge,getCalleeMembers:Ce((()=>q.reverse())),name:objectAndMembersToName(`${xe}()`,R),getMembers:Ce((()=>R.reverse())),getMembersOptionals:Ce((()=>$.reverse())),getMemberRanges:Ce((()=>L.reverse()))}}case"Identifier":case"MetaProperty":case"ThisExpression":{if((I&Je)===0)return;const v=getRootName(P);if(!v)return;const q=this.getFreeInfoFromVariable(v);if(!q)return;const{info:K,name:ae}=q;return{type:"expression",name:objectAndMembersToName(ae,R),rootInfo:K,getMembers:Ce((()=>R.reverse())),getMembersOptionals:Ce((()=>$.reverse())),getMemberRanges:Ce((()=>L.reverse()))}}}}getNameForExpression(v){return this.getMemberExpressionInfo(v,Je)}static _parse(v,I){const P=I?I.sourceType:"module";const R={...Xe,allowReturnOutsideFunction:P==="script",...I,sourceType:P==="auto"?"module":P};let $;let L;let q=false;try{$=Ye.parse(v,R)}catch(v){L=v;q=true}if(q&&P==="auto"){R.sourceType="script";if(!("allowReturnOutsideFunction"in I)){R.allowReturnOutsideFunction=true}if(Array.isArray(R.onComment)){R.onComment.length=0}try{$=Ye.parse(v,R);q=false}catch(v){}}if(q){throw L}return $}}v.exports=JavascriptParser;v.exports.ALLOWED_MEMBER_TYPES_ALL=Ve;v.exports.ALLOWED_MEMBER_TYPES_EXPRESSION=Je;v.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION=Qe;v.exports.getImportAttributes=getImportAttributes;v.exports.VariableInfo=VariableInfo},59932:function(v,I,P){"use strict";const R=P(53966);const $=P(34022);const L=P(28665);v.exports.toConstantDependency=(v,I,P)=>function constDependency(R){const L=new $(I,R.range,P);L.loc=R.loc;v.state.module.addPresentationalDependency(L);return true};v.exports.evaluateToString=v=>function stringExpression(I){return(new L).setString(v).setRange(I.range)};v.exports.evaluateToNumber=v=>function stringExpression(I){return(new L).setNumber(v).setRange(I.range)};v.exports.evaluateToBoolean=v=>function booleanExpression(I){return(new L).setBoolean(v).setRange(I.range)};v.exports.evaluateToIdentifier=(v,I,P,R)=>function identifierExpression($){const q=(new L).setIdentifier(v,I,P).setSideEffects(false).setRange($.range);switch(R){case true:q.setTruthy();break;case null:q.setNullish(true);break;case false:q.setFalsy();break}return q};v.exports.expressionIsUnsupported=(v,I)=>function unsupportedExpression(P){const L=new $("(void 0)",P.range,null);L.loc=P.loc;v.state.module.addPresentationalDependency(L);if(!v.state.module)return;v.state.module.addWarning(new R(I,P.loc));return true};v.exports.skipTraversal=()=>true;v.exports.approve=()=>true},46511:function(v,I,P){"use strict";const R=P(5205);const $=P(57227);const{isSubset:L}=P(81956);const{getAllChunks:q}=P(52326);const K=`var ${R.exports} = `;v.exports.generateEntryStartup=(v,I,P,ae,ge)=>{const be=[`var __webpack_exec__ = ${I.returningFunction(`${R.require}(${R.entryModuleId} = moduleId)`,"moduleId")}`];const runModule=v=>`__webpack_exec__(${JSON.stringify(v)})`;const outputCombination=(v,P,$)=>{if(v.size===0){be.push(`${$?K:""}(${P.map(runModule).join(", ")});`)}else{const L=I.returningFunction(P.map(runModule).join(", "));be.push(`${$&&!ge?K:""}${ge?R.onChunksLoaded:R.startupEntrypoint}(0, ${JSON.stringify(Array.from(v,(v=>v.id)))}, ${L});`);if($&&ge){be.push(`${K}${R.onChunksLoaded}();`)}}};let xe;let ve;for(const[I,R]of P){const P=R.getRuntimeChunk();const $=v.getModuleId(I);const K=q(R,ae,P);if(xe&&xe.size===K.size&&L(xe,K)){ve.push($)}else{if(xe){outputCombination(xe,ve)}xe=K;ve=[$]}}if(xe){outputCombination(xe,ve,true)}be.push("");return $.asString(be)};v.exports.updateHashForEntryStartup=(v,I,P,R)=>{for(const[$,L]of P){const P=L.getRuntimeChunk();const K=I.getModuleId($);v.update(`${K}`);for(const I of q(L,R,P)){v.update(`${I.id}`)}}};v.exports.getInitialChunkIds=(v,I,P)=>{const R=new Set(v.ids);for(const $ of v.getAllInitialChunks()){if($===v||P($,I))continue;for(const v of $.ids){R.add(v)}}return R}},14879:function(v,I,P){"use strict";const{register:R}=P(32589);class JsonData{constructor(v){this._buffer=undefined;this._data=undefined;if(Buffer.isBuffer(v)){this._buffer=v}else{this._data=v}}get(){if(this._data===undefined&&this._buffer!==undefined){this._data=JSON.parse(this._buffer.toString())}return this._data}updateHash(v){if(this._buffer===undefined&&this._data!==undefined){this._buffer=Buffer.from(JSON.stringify(this._data))}if(this._buffer)v.update(this._buffer)}}R(JsonData,"webpack/lib/json/JsonData",null,{serialize(v,{write:I}){if(v._buffer===undefined&&v._data!==undefined){v._buffer=Buffer.from(JSON.stringify(v._data))}I(v._buffer)},deserialize({read:v}){return new JsonData(v())}});v.exports=JsonData},77871:function(v,I,P){"use strict";const{RawSource:R}=P(51255);const $=P(40255);const{UsageState:L}=P(21311);const q=P(52402);const{JS_TYPES:K}=P(30021);const ae=P(5205);const stringifySafe=v=>{const I=JSON.stringify(v);if(!I){return}return I.replace(/\u2028|\u2029/g,(v=>v==="\u2029"?"\\u2029":"\\u2028"))};const createObjectForExportsInfo=(v,I,P)=>{if(I.otherExportsInfo.getUsed(P)!==L.Unused)return v;const R=Array.isArray(v);const $=R?[]:{};for(const R of Object.keys(v)){const q=I.getReadOnlyExportInfo(R);const K=q.getUsed(P);if(K===L.Unused)continue;const ae=K===L.OnlyPropertiesUsed&&q.exportsInfo?createObjectForExportsInfo(v[R],q.exportsInfo,P):v[R];const ge=q.getUsedName(R,P);$[ge]=ae}if(R){const R=I.getReadOnlyExportInfo("length").getUsed(P)!==L.Unused?v.length:undefined;let q=0;for(let v=0;v<$.length;v++){if($[v]===undefined){q-=2}else{q+=`${v}`.length+3}}if(R!==undefined){q+=`${R}`.length+8-(R-$.length)*2}if(q<0)return Object.assign(R===undefined?{}:{length:R},$);const K=R!==undefined?Math.max(R,$.length):$.length;for(let v=0;v<K;v++){if($[v]===undefined){$[v]=0}}}return $};class JsonGenerator extends q{getTypes(v){return K}getSize(v,I){const P=v.buildInfo&&v.buildInfo.jsonData&&v.buildInfo.jsonData.get();if(!P)return 0;return stringifySafe(P).length+10}getConcatenationBailoutReason(v,I){return undefined}generate(v,{moduleGraph:I,runtimeTemplate:P,runtimeRequirements:q,runtime:K,concatenationScope:ge}){const be=v.buildInfo&&v.buildInfo.jsonData&&v.buildInfo.jsonData.get();if(be===undefined){return new R(P.missingModuleStatement({request:v.rawRequest}))}const xe=I.getExportsInfo(v);const ve=typeof be==="object"&&be&&xe.otherExportsInfo.getUs